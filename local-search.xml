<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>时间序列分析自学笔记</title>
    <link href="/2025/09/13/Time%20Series%20Note/"/>
    <url>/2025/09/13/Time%20Series%20Note/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ul><li>【Author】：Jack Zhang, SYSU</li><li>【Textbook】：Applied Econometric Time Series(4e), by WalterEnders</li><li>【Original Slides】：https://www.time-series.net/powerpoint_slides</li></ul><h1 id="chapter-1-difference-equations-差分方程">Chapter 1: DifferenceEquations 差分方程</h1><blockquote><p>[!IMPORTANT] 本章学习目标</p><ol type="1"><li>阐述随机差分方程如何用来预测，说明该方程如何产生于熟悉的经济模型。</li><li>阐述差分方程的解的含义。</li><li>阐述如何用迭代求解随机差分方程。</li><li>阐述如何求差分方程的齐次解。</li><li>阐述求齐次解的过程。</li><li>阐述如何求高阶差分方程的齐次解。</li><li>阐述如何求确定的差分方程的特解。</li><li>阐述如何用待定系数法求随机差分方程的特解。</li><li>阐述如何用滞后因子求随机差分方程的特解。</li></ol></blockquote><h2 id="11-时间序列模型">1.1 时间序列模型</h2><p>当我们拿到一个时间序列模型，我们可能不假思索地就能说出一些直观的信息。比如，GDP逐年增长的趋势、增速放缓的趋势。这就是直观的描述性分析。</p><p><imgsrc="https://files.mdnice.com/user/77043/f24960d4-5001-4d7b-8e77-a815329da5bd.png"alt="可能思路" /></p><p>但是，很多规律并不那么容易发现——他们潜藏在大量的复杂的数据背后。我们研究模型的目的就是理解这些潜在的规律，并用以预测。这时，模型的作用就是<strong>提取特征</strong>，用统计学的语言使得这些特征从模糊的感觉转变为确切的定理。</p><p><strong>那么，有什么方法可以 “提取特征” 呢？</strong>当前，时间序列分析主要有两大“流派”——<strong>统计时间序列分析</strong> 和<strong>机器学习方法</strong>。统计时间序列分析基于统计学方法对时间序列的概率特性进行估计，一般基于（线性）随机过程假设。我们之前学习的 AR 模型、MA 模型、ARMA模型等都属于这一类。另一类是机器学习方法，顾名思义，是基于机器学习方法从历史或相关序列中学习时间序列预测的方法。比如基于近邻的方法、RNN/LSTM、Transformer、TCN、Meta-Learning等。我们目前主要学习的是统计时间序列分析方法。</p><h3 id="111-时间序列分析的用途">1.1.1 时间序列分析的用途</h3><ul><li><p><strong>传统用途</strong>：预测</p><ul><li><p>基于线性模型 <span class="math inline">\(y_{t+1} = a_0 + a_1 y_t+ \varepsilon_{t+1}\)</span>，已知当期 <spanclass="math inline">\(y_t\)</span>，预测下一期期望 <spanclass="math inline">\(E_t[y_{t+1}] = a_0 + a_1 y_t\)</span>。</p></li><li><p>那么，<span class="math inline">\(t+2\)</span>期？在第一期的基础上递推。</p><ul><li><spanclass="math inline">\(y_{t+2}=a_0+a_1y_{t+1}+\varepsilon_{t+2}\)</span></li><li><spanclass="math inline">\(E_{y_{t+2}}=a_0+a_1E_{y_{t+1}}=a_0+a_1(a_0+a_1y_t)=a_0+a_1a_0+(a_1)^2y_t\)</span></li></ul></li><li><p>“递推”的本质就是【迭代】，即本章的核心内容。</p></li><li><p>例如：通过滞后一期的价格预测下一期价格，GDP 预测。</p></li></ul></li><li><p><strong>现代用途</strong>：</p><ul><li><strong>动态关系捕捉</strong>：分析变量间的滞后影响（如货币政策对经济的滞后效应）。</li><li><strong>假设检验</strong>：验证经济理论（如随机游走假设）。</li><li><strong>发展“典型事实”</strong>：从数据中提炼规律（如商业周期的波动特征）。</li></ul></li></ul><h3 id="112-典型的时间序列问题">1.1.2 典型的时间序列问题</h3><ul><li><p><strong>【单方程模型】随机游走假设</strong>：</p><ul><li><strong>模型</strong>：<span class="math inline">\(y_{t+1} = y_t +\varepsilon_{t+1}\)</span>，即 <span class="math inline">\(\Deltay_{t+1} = \varepsilon_{t+1}\)</span>。</li><li><strong>检验</strong>：对更一般的方程 <spanclass="math inline">\(\Delta y_{t+1} = a_0 + a_1 y_t +\varepsilon_{t+1}\)</span>，需验证 <span class="math inline">\(a_0 = a_1= 0\)</span>。</li><li>第 2 章到第 4 章将再次讨论如何恰当地估计单方程模型。</li></ul></li><li><p><strong>【诱导方程和结构方程】</strong></p><ul><li><strong>结构方程</strong>（structuralequation）的内生因变量依赖于另一个内生变量（自变量）的当期实现值。</li><li><strong>诱导方程</strong>（reduced-formequation，我们也常说是简约式，例如计量中的 IV估计）则是将内生变量表示成该变量 <strong>滞后值</strong>、其他内生变量的<strong>滞后值</strong>、<strong>外生变量</strong> 的当期和过去值以及<strong>扰动项</strong> 的函数。</li><li>我们可以简单的用“是否自变量纯粹为滞后变量”来判别。</li></ul></li></ul><blockquote><p>[!Example]</p><p>【例】 <span class="math display">\[\begin{cases}y_t = c_t + i_t \\c_t = \alpha y_{t-1} + \varepsilon_{ct} \quad 0 &lt; \alpha &lt; 1 \\i_t = \beta (c_t - c_{t-1}) + \varepsilon_{it} \quad \beta &gt; 0\end{cases}\notag\]</span></p><p>消费函数中的当期消费仅仅依赖于滞后收入 <spanclass="math inline">\(y_{t-1}\)</span> 和扰动项 <spanclass="math inline">\(\varepsilon\)</span>，它已经表示成了诱导方程。</p><p>而投资函数还不是诱导方程，因为当期投资还依赖于当期消费。那么，它的投资函数的诱导方程是什么？</p><p><span class="math display">\[\begin{align}i_t &amp;= \beta (c_t - c_{t-1}) + \varepsilon_{it} \notag \\&amp;= \beta (\alpha y_{t-1} + \varepsilon_{ct} - c_{t-1}) +\varepsilon_{it} \notag \\&amp;= \alpha \beta y_{t-1} - \beta c_{t-1} + \beta \varepsilon_t +\varepsilon_{it} \notag\end{align} \notag\]</span></p><p><strong>【练习】：请推导 <span class="math inline">\(y_t\)</span>的诱导方程。如果消去所有 <span class="math inline">\(c\)</span>呢？</strong></p><p>我们可以进一步简化得到下面的形式：</p><p><span class="math display">\[y_t = ay_{t-1} + by_{t-2} + x_t \notag\]</span></p><p>这是一个单变量诱导方程，<span class="math inline">\(y_t\)</span>完全被表示为其滞后值和干扰项的函数。单变量模型用于预测特别有效，我们只需根据它当期和过去的实现值，就可对序列进行预测。</p></blockquote><p>在学完第 2 章到第 4 章阐述的单变量时间序列分析方法后，第 5章讨论当所有变量都被当作联合内生变量时的多变量模型估计。该章也讨论从已估诱导模型还原到结构模型所需的约束条件。</p><ul><li><strong>【误差纠正】无偏远期汇率（UFR）假设</strong>：<ul><li><strong>模型</strong>：<span class="math inline">\(s_{t+1} = f_t +\varepsilon_{t+1}\)</span>，其中 <spanclass="math inline">\(s_{t+1}\)</span> 为未来即期汇率，<spanclass="math inline">\(f_t\)</span> 为当前远期汇率。</li><li><strong>回归检验</strong>：<span class="math inline">\(s_{t+1} = a_0+ a_1 f_t + \varepsilon_{t+1}\)</span>，要求 <spanclass="math inline">\(a_0 = 0\)</span>、<span class="math inline">\(a_1= 1\)</span>，且残差 <spanclass="math inline">\(\varepsilon_{t+1}\)</span> 均值为零。</li><li><strong>调整机制</strong>：若 <span class="math inline">\(s_{t+1}\neq f_t\)</span>，后续汇率和远期利率会通过下面的误差纠正模型联立调整：<ul><li>如果即期汇率与远期汇率相等（<span class="math inline">\(s_{t+1} =f_t\)</span>），则即期和远期汇率倾向于保持不变。</li><li>如果即期与远期汇率之差为正，即 <span class="math inline">\(s_{t+1} -f_t&gt;0\)</span>，则预期：即期汇率会趋于下降，远期汇率会趋于上升。</li></ul></li></ul></li></ul><p><span class="math display">\[\begin{cases}s_{t+2} = s_{t+1} - a(s_{t+1} - f_t) + \varepsilon_{s, t+2} \\f_{t+1} = f_t + b(s_{t+1} - f_t) + \varepsilon_{f, t+1} \notag\end{cases}\]</span></p><ul><li><strong>【非线性动态模型】趋势-周期关系</strong>：<ul><li><strong>分解公式</strong>：<span class="math inline">\(y_t = Trend +Cycle + Noise\)</span>。</li><li><strong>趋势</strong>：长期稳定增长或下降（如 GDP的长期趋势）。</li><li><strong>周期</strong>：围绕趋势的短期波动（如商业周期）。</li><li><strong>噪声</strong>：随机不可预测部分（如突发政策冲击）。</li><li><strong>应用</strong>：摩擦性失业（Noise）、结构性失业（Trend，如房地产业）、周期性失业（Cycle，如经济危机）</li></ul></li></ul><p>第 7 章将专门讨论一些具有更为复杂的 <strong>动态结构模型</strong>的估计。</p><h2 id="12-平稳性">1.2 平稳性</h2><p><strong>平稳性是时间序列分析的基础。</strong></p><p>平稳性的存在使得不同时间点的随机变量具有类似的统计性质，这是统计推断和预测的基础。类比随机实验，任何一次实验的统计性质是一致的，因此，可以进行统计推断。</p><p><strong>平稳序列围绕 x轴上下波动，非平稳序列则无序波动</strong>。平稳的本质是让系统稳定，让变量收敛。</p><p>平稳性有 <strong>严平稳</strong>（strictly stationary）和<strong>弱平稳</strong>（weakly stationary）之分。</p><ul><li><p>严平稳是非常强的假设，它认为只有当序列所有的统计性质都不会随着时间的推移而发生变化时，该序列才被认为平稳。该假设使时间序列与无数次随机实验一致，这难以用经验方法验证。</p></li><li><p>弱平稳又被称为宽平稳。弱平稳不对随机变量的分布作要求，这就类似于每一次随机实验，可以是不同的实验，但任意两次实验之间存在一定关系，即均值和协方差。弱平稳下数据的时间序列图是围绕一个常数水平以相同的幅度上下波动。弱平稳性使我们可以对未来观测进行推断，即预测。</p></li><li><p><strong>严平稳太过严格，我们通常考虑弱平稳序列</strong>。</p></li></ul><blockquote><p>[!NOTE] 弱平稳的定义：</p><p>对于任意整数 <span class="math inline">\(l\)</span>，如果 <spanclass="math inline">\(y_t\)</span> 的均值，以及 <spanclass="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_t-l\)</span>的协方差不随时间而改变，那么时间序列 <spanclass="math inline">\(y_t\)</span> 是弱平稳的。</p><p>换言之，当：<span class="math inline">\(\mathbb{E}(y_t)\)</span>是常数、<span class="math inline">\(\mathbb{Cov}(y_t, y_{t-l})\)</span>只依赖于 <span class="math inline">\(l\)</span> 时，时间序列 <spanclass="math inline">\(y_t\)</span> 是弱平稳的。</p><p>其中，<span class="math inline">\(\gamma_l = \mathbb{Cov}(y_t,y_{t-l})\)</span> 称为 <span class="math inline">\(y_t\)</span> 的间隔为<span class="math inline">\(l\)</span> 的<strong>自协方差</strong>，它满足： （1）当 <spanclass="math inline">\(l=0\)</span> 时， <spanclass="math inline">\(\gamma_0 = \mathbb{Cov}(y_t, y_t) =\mathbb{Var}(y_t)\)</span>； （2）<span class="math inline">\(\gamma_l =\gamma_{-l}\)</span>这表明自协方差对于“预测未来“和”追溯过去”都是适用的。</p><p>对应的，我们也可以定义 <strong>自相关系数</strong>。<spanclass="math inline">\(\rho = \dfrac{\gamma_l}{\gamma_0}\)</span>，也即是<span class="math inline">\(\rho = \dfrac{\mathbb{Cov}(y_t,y_{t-l})}{\mathbb{Var}(y_t)}\)</span></p></blockquote><p>或者，我们更通俗地认识：</p><blockquote><p>[!Tip] <strong>弱平稳</strong>（协方差平稳）需满足的条件：</p><ol type="1"><li><strong>均值恒定</strong>：<span class="math inline">\(E(y_t) =\mu\)</span>（各时期数学期望恒定）</li><li><strong>方差恒定</strong>：<spanclass="math inline">\(\text{Var}(y_t) =\sigma^2\)</span>（各时期方差恒定）</li><li><strong>协方差仅依赖时间间隔（而不随时间变化）</strong>：<spanclass="math inline">\(\text{Cov}(y_i, y_j) =\gamma_{|i-j|}\)</span>（任意两时期的协方差仅与时间间隔绝对值有关）</li></ol><p>怎么好像多了一个条件？事实上，方差恒定可以被涵盖在协方差不随时间变化的条件中。</p></blockquote><h2 id="13-差分方程及其解">1.3 差分方程及其解</h2><h3 id="131-什么是差分">1.3.1 什么是差分？</h3><ul><li>我们首先认识一下“<strong>差分算子</strong>”，虽然名字很陌生，但事实上我们在学习微积分的时候就已经了解它了。让我们回忆亿下高数的导数内容：</li></ul><blockquote><p>[!Note] 导数的定义</p><p>导数描述了一个函数在某一点处的变化率。导数的定义基于极限的概念。</p><p>给定一个实数函数 <spanclass="math inline">\(f(x)\)</span>，如果存在极限 <spanclass="math display">\[f&#39;(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h} \notag\]</span> 那么，这个极限值称为函数 <spanclass="math inline">\(f(x)\)</span> 在点 <spanclass="math inline">\(x\)</span> 处的导数 。或者，我们常简写为： <spanclass="math display">\[f&#39;(x) = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} \notag\]</span></p></blockquote><p><span class="math inline">\(\Delta\)</span>就是差分算子。一阶差分本质上就是做差。</p><ul><li><p>微积分中允许自变量的变化趋近于零。但由于大多数经济数据都是离散型的，所以，允许时间跨度大于零会更有益。运用差分方程时，我们将单位标准化，使<span class="math inline">\(h\)</span> 代表时期（例如，<spanclass="math inline">\(h=1\)</span>）的单位变化。</p></li><li><p>一阶差分 <span class="math inline">\(\Delta y_t = y_t -y_{t-1}\)</span>。</p></li><li><p>二阶差分 <span class="math inline">\(\Delta^2 y_t \equiv\Delta(\Delta y_t) = \Delta(y_t - y_{t-1}) = (y_t - y_{t-1}) - (y_{t-1}- y_{t-2}) = y_t - 2y_{t-1} + y_{t-2}\)</span></p></li><li><p>类似地，可以给出 n 阶差分的定义。此时，我们已<strong>冒险</strong>将差分方程理论推广得过远。在时间序列分析中，很少需要使用差分。在实际应用中，几乎不会使用3 阶及更高阶的差分方程。</p></li><li><p>为什么是<strong>“冒险”</strong>？——类比于天气预报，更长期限的预测更失真。在第1.4.2.1 节中（<a href="#1.4.2.1%20迭代法">1.4.2.1迭代法</a>），我们有更数理直观的解释。</p></li></ul><h3 id="132-什么是差分方程">1.3.2 什么是差分方程？</h3><p>通常形式下，<strong>差分方程</strong>将变量表示为该变量滞后值、时间和其他变量的函数。</p><div class="note"><div class="title"><p>Note</p></div><p>趋势性：<span class="math inline">\(T_t = 1 + 0.1t\)</span></p><p>季节性：<span class="math inline">\(S_t =1.6\sin\left(\frac{t\pi}{6}\right)\)</span></p><p>无规则：<span class="math inline">\(I_t = 0.7I_{t-1} +\varepsilon_t\)</span></p><p>其中，趋势成分和季节成分都是时间 <spanclass="math inline">\(t\)</span>的函数，而无规则成分则是它的滞后值和随机变量 <spanclass="math inline">\(\varepsilon\)</span> 的函数。</p></div><p>由于大部分情况下，我们讨论的是线性时间序列，可以只考察带常数系数的<span class="math inline">\(n\)</span>​阶线性差分方程的特例。这种特殊类型的差分方程的形式为：</p><p><span class="math display">\[y_t = a_0 + \sum_{i = 1}^{n} a_i y_{t-i} + x_t \notag\]</span></p><p>公式的结构可以分解为以下几个部分：</p><ol type="1"><li><p>常数项 <span class="math inline">\(a_0\)</span></p></li><li><p>过去输出值的加权和：<span class="math inline">\(\sum_{i=1}^{n}a_i y_{t-i}\)</span>，即从 <span class="math inline">\(t-1\)</span> 到<span class="math inline">\(t-n\)</span>的所有过去输出值的线性组合。<span class="math inline">\(a_i\)</span>是权重。</p></li><li><p>当前外部输入 <spanclass="math inline">\(x_t\)</span>（驱动因素、激励、推动过程）。它可能是时间、其他变量的当期值或滞后值，和（或）随机干扰项的任一函数。通过恰当地选择推动过程，我们就可以得到大量重要的宏观经济模型。</p></li></ol><p>你可能会差评：这个差分方程看起来一点也不差分。的确，让我们给它变个形：</p><p><span class="math display">\[\Delta y_{t} = y_{t}-y_{t-1}= a_0+(a_1-1) y_{t-1}+\sum_{i =2}^{n}a_{i}y_{t-i}+x_{t}\notag\]</span></p><p>它变丑了，也变得更让人眼熟了。</p><h2 id="14-差分方程的求解方法">1.4 差分方程的求解方法</h2><h3 id="141-差分方程的解">1.4.1 差分方程的解</h3><p>好了，我们现在认识了差分方程。这就够了吗？当然不。我们的目标是估计它，换言之，我们要：<strong>求解差分方程</strong>。</p><p>在求解之前，我们最好还是先明确我们的预期目标，也就是<strong>差分方程的解</strong>（solution）。</p><p>差分方程的解是将 <span class="math inline">\(y_t\)</span>值表示为序列 <span class="math inline">\(x_t\)</span> 的元素和 <spanclass="math inline">\(t\)</span>的函数。解式中可能包括一些初始条件（initial condtion，即 <spanclass="math inline">\(y_t\)</span> 的一些给定值）。</p><div class="tip"><div class="title"><p>Tip</p></div><p>解的主要特征在于：<strong>当时间 <spanclass="math inline">\(t\)</span> 和外部输入的 <spanclass="math inline">\(x\)</span>取任何允许值时，它都满足差分方程</strong>。这使得我们可以对解进行验证。</p><p>换言之，只要满足差分方程，它就是差分方程的解。</p></div><p><strong>【引例】</strong>：<strong>考察简单差分方程 <spanclass="math inline">\(\Delta y_t = 2\)</span> 的解</strong></p><p>由于 <span class="math inline">\(\Delta y_t = y_t - y_{t-1} =2\)</span>，我们很容易证明 <span class="math inline">\(y_t\)</span>是公差为 2 的等差数列。<span class="math inline">\(y_t = 2t + c\)</span>是差分方程 <span class="math inline">\(\Delta y_t = 2\)</span>的解，这里 <span class="math inline">\(c\)</span> 为任意常数。</p><p>根据定义，如果 <span class="math inline">\(2t + c\)</span>为一个解，则必定满足 <span class="math inline">\(t\)</span>的所有允许值。因此，对于 <span class="math inline">\(t-1\)</span> 期，有<span class="math inline">\(y_{t-1} = 2(t-1) +c\)</span>，现在将解代入方程得：<span class="math inline">\(2t + c\equiv 2(t-1) + c +2\)</span>。这是一个恒等式。这也说明差分方程的解不是唯一的，<spanclass="math inline">\(c\)</span> 的任意一个取值都对应着一个解。</p><p>我们发现，差分方程的解有点像通项公式。事实上，一阶线性递推数列的通项公式是“常数+等比”；二阶线性递推数列的通项公式是“等比+等比”的形式。</p><div class="tip"><div class="title"><p>Tip</p></div><p>解是一个函数而非数字。类似于数列的通项公式，我们最终求解差分方程的目标是一个涵盖每一个“特解”的函数，称为“通解”。我们将在后面的迭代法中介绍（尽管这些概念并不依赖于迭代求解方法）。</p></div><h3 id="142-迭代法求解差分方程">1.4.2 迭代法求解差分方程</h3><p>尽管迭代法是一种最麻烦、最耗时的方法，但它很直观。</p><h4 id="1421-迭代法">1.4.2.1 迭代法</h4><ul><li><p><strong>一阶方程迭代</strong>：</p><ul><li><p><strong>方程</strong>：<span class="math inline">\(y_t = a_0 +a_1 y_{t-1} + \varepsilon_t\)</span>。</p></li><li><p><strong>迭代过程</strong>：</p><ul><li>第一期 <span class="math inline">\(y_1 = a_0 + a_1 y_0 +\varepsilon_1\)</span>。</li><li>第二期 <span class="math inline">\(y_2 = a_0 + a_1 y_1 +\varepsilon_2 = a_0(1 + a_1) + a_1^2 y_0 + a_1 \varepsilon_1 +\varepsilon_2\)</span>。</li><li>第三期 <span class="math inline">\(y_3 =a_0 + a_1 y_2 +\varepsilon_3 = a_0(1 + a_1 + a_1^2) + a_1^3 y_0 + a_1^2 \varepsilon_1 +a_1 \varepsilon_2 + \varepsilon_3\)</span>。</li><li>第 <span class="math inline">\(t\)</span> 期 ？</li></ul></li></ul></li></ul><p><span class="math display">\[y_t = a_0 \sum_{i = 0}^{t-1} a_1^i + a_1^t y_0 + \sum_{i = 0}^{t-1}a_1^i \varepsilon_{t-i} \notag\]</span></p><div class="tip"><div class="title"><p>Tip</p></div><p>更多次的迭代，就有更大的误差。这在数理上呼应了 <ahref="#1.3.1%20什么是差分？">1.3.1 什么是差分？</a>关于更长时间序列预测的“冒险”。</p></div><ul><li><p><strong>极限情况：当 <span class="math inline">\(t \rightarrow∞\)</span> 时</strong></p></li><li><p><strong>当 <span class="math inline">\(|a_1| &lt; 1\)</span>时</strong>：【第一项是几何级数，第二项趋于 0】</p></li></ul><p><span class="math display">\[y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^∞ a_1^i \varepsilon_{t-i}\notag\]</span></p><ul><li><p><strong>思考</strong>：相对于其他情况，我们更关心 <spanclass="math inline">\(|a_1| &lt; 1\)</span> 的情况。为什么？</p><ul><li>数理上，这时收敛。站在 <span class="math inline">\(t\)</span>期的节点上，上一期的 <span class="math inline">\(y_{t-1}\)</span>是已知的参数。当 <span class="math inline">\(|a_1| \geq1\)</span>，无穷级数发散。</li><li>仅仅是因为数理上收敛可以求出吗？经济意义是什么？（Hint：类似于WLS，你认为 2015 年 GDP 对今年 GDP 影响大还是 2024 年 GDP 对今年 GDP影响大？所以我们应该怎么赋予权重？）</li></ul></li><li><p><strong>验证</strong>：这是 <span class="math inline">\(y_t = a_0+ a_1 y_{t-1} + \varepsilon_t\)</span>的解吗？代入公式验证是成立的。</p></li><li><p>如果 <strong>反向迭代</strong>，这个式子还成立吗？</p></li></ul><p><span class="math display">\[y_t = a_0 + a_1 y_{t-1} + \varepsilon_t \notag\]</span></p><p>将 <span class="math inline">\(y_{t-1}\)</span>代入上述表达式中：</p><p><span class="math display">\[\begin{align}y_t &amp;= a_0 + a_1 [a_0 + a_1 y_{t-2} + \varepsilon_{t-1}] +\varepsilon_t  \notag\\&amp; = a_0 (1 + a_1) + a_1 \varepsilon_{t-1} + \varepsilon_t + a_1^2[a_0 + a_1 y_{t-3} + \varepsilon_{t-2}]  \notag\end{align}\notag\]</span></p><p>当 <span class="math inline">\(|a_1| &lt; 1\)</span> 时，<spanclass="math inline">\(t \rightarrow ∞\)</span> 的极限情况：</p><p><span class="math display">\[y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^\infty a_1^i\varepsilon_{t-i}\notag\]</span></p><p><span class="math display">\[y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^\infty a_1^i\varepsilon_{t-i}\notag\]</span></p><ul><li><strong>通解</strong>：在第 1.4.1 节（<ahref="#1.4.1%20差分方程的解">1.4.1差分方程的解</a>）最后，我们提到：差分方程的解有点像通项公式。那么，应该能够写出一个<strong>通解</strong>，以涵盖前面的各个解（称为<strong>特解</strong>）。课本对通解的提出比较突兀，这是因为涉及了齐次解的内容，我们在第1.4.2.2 节讨论这一点。</li></ul><h4 id="1422-齐次解和通解">1.4.2.2 齐次解和通解</h4><ul><li><strong>齐次解</strong>：<ul><li>前面我们提到的是 <span class="math inline">\(y_t = a_0 + a_1 y_{t-1}+ \varepsilon_t\)</span>，仅考虑其中的齐次部分，就是齐次方程。</li><li><strong>一阶齐次方程</strong>：<span class="math inline">\(y_t = a_1y_{t-1}\)</span>，这可以被视作等比数列，通项公式还记得吗？</li><li>该齐次方程的解称为 <strong>齐次解</strong>（homogeneoussolution），为 <span class="math inline">\(y_t =A×(a_1)^t= Aa_1^t\)</span>（A 任取）。</li><li><strong>收敛条件</strong>：<span class="math inline">\(|a_1| &lt;1\)</span>。这与 <a href="#1.2%20平稳性">1.2 平稳性</a> 是呼应的。</li></ul></li></ul><blockquote><p>[!Note] 一阶齐次方程的齐次解与平稳性</p><ol type="1"><li><strong>当 <span class="math inline">\(|a_1| &lt; 1\)</span>时</strong>：<ul><li>当 <span class="math inline">\(t\)</span> 趋于无穷大时，<spanclass="math inline">\(a_1^t\)</span> 收敛于零。</li><li>如果 <span class="math inline">\(0 &lt; a_1 &lt;1\)</span>，则称为直接收敛。</li><li>如果 <span class="math inline">\(-1 &lt; a_1 &lt;0\)</span>，则称为震荡收敛。</li></ul></li><li><strong>当 <span class="math inline">\(|a_1| &gt; 1\)</span>时</strong>：<ul><li>齐次解不稳定。</li><li>如果 <span class="math inline">\(a_1 &gt; 1\)</span>，齐次解随 <spanclass="math inline">\(t\)</span> 的增大趋于无穷大。</li><li>如果 <span class="math inline">\(a_1 &lt;-1\)</span>，齐次解是震荡发散性的。</li></ul></li><li><strong>当 <span class="math inline">\(a_1 = 1\)</span>时</strong>：任意一个常数 <span class="math inline">\(A\)</span>都满足齐次方程 <span class="math inline">\(y_t = y_{t-1}\)</span>。</li><li><strong>当 <span class="math inline">\(a_1 = -1\)</span>时</strong>，方程的解正负交替变化：<spanclass="math inline">\(t\)</span> 取偶数，<spanclass="math inline">\(a_1^t = 1\)</span>；<spanclass="math inline">\(t\)</span> 取奇数，<spanclass="math inline">\(a_1^t = -1\)</span>。</li></ol></blockquote><ul><li><strong>通解</strong>： 正如我们在第 1.4.1 节（<ahref="#1.4.1%20差分方程的解">1.4.1差分方程的解</a>）最后部分所指出的，差分方程的解更像一种通项公式。那么，应该能够写出一个<strong>通解</strong>，以涵盖 <span class="math inline">\(y_t = a_0 +a_1 y_{t-1} + \varepsilon_t\)</span> 的所有 <strong>特解</strong>。在第1.4.2.1 节（<a href="#1.4.2.1%20迭代法">1.4.2.1迭代法</a>）中，我们考虑到了一个比较特殊的特解：当 <spanclass="math inline">\(t \rightarrow ∞\)</span> 时的特解：</li></ul><p><span class="math display">\[y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^∞ a_1^i \varepsilon_{t-i}\notag\]</span></p><p>现在，我们构造<strong>通解</strong>：其两个组成部分正是齐次解、特解。如上所述，齐次解为<span class="math inline">\(y_t = A a_1^t\)</span>，A 可以任意取值。</p><p><span class="math display">\[y_t = A a_1^t + \frac{a_0}{1 - a_1} + \sum_{i = 0}^{\infty} a_1^i\varepsilon_{t-i} \notag\]</span></p><p>在通解的基础上，如果我们再施加初始条件 <spanclass="math inline">\(y_0\)</span>，就可以消去任意常数 A 了。</p><h3 id="143-解差分方程的通用步骤">1.4.3 解差分方程的通用步骤</h3><p>我们已经分析了一阶的情况，现在考虑更高阶的。迭代法求解方程不宜用于高阶方程，在复杂的代数式面前，任何试图求解的努力都是徒劳的。那么，有什么好办法呢？</p><p>在经济分析中，出现更高阶的差分方程并不奇怪。根据萨缪尔森模型(1939)得到的GDP 的诱导方程（见 <a href="#1.1.2%20典型的时间序列问题">1.1.2典型的时间序列问题</a>），就是 <strong>二阶差分方程</strong>的例子。此外，在时间序列计量经济学中对二阶和更高阶差分方程的估计也相当典型。</p><blockquote><p>[!TIP] <strong>【通用步骤】</strong> 一阶例子中的结论直接适用于 n阶差分方程。一般情况下，寻找特解更为困难，并且还有 n个不同的齐次解。但是，解答时总是遵照以下四个步骤。</p><p>第 1 步：建立齐次方程，求出 n 个齐次解；</p><p>第 2 步：求出一个特解；</p><p>第 3 步：求特解和所有齐次解的一个线性组合，求和得出通解；</p><p>第 4 步：将初始条件代入通解中，消去任意常数。</p></blockquote><p>要考察齐次差分方程的解法，首先，我们考察二阶差分。按照上面的步骤，我们做个例题：</p><blockquote><p>[!Note] 【例 1】 求解 <span class="math inline">\(y_t = 0.9y_{t-1} -0.2y_{t-2} + 3\)</span>，初始条件 <spanclass="math inline">\(y_{0}=13\)</span>，<spanclass="math inline">\(y_{1}=11.4\)</span></p><p><strong>第 1 步：建立齐次方程</strong></p><p><span class="math display">\[y_t - 0.9y_{t-1} + 0.2y_{t-2} = 0 \notag\]</span></p><p><strong>找到齐次解</strong>：稍后我们将说明如何找到完整的齐次解。现在，我们直接给出两个齐次解为：</p><p><span class="math inline">\(y^h_{1t} = (0.5)^t \quad \text{和} \quady^h_{2t} = (0.4)^t\)</span></p><p>要证明第一个解，应注意到 <span class="math inline">\(y^h_{1,t-1} =(0.5)^{t-1}\)</span> 和 <span class="math inline">\(y^h_{1,t-2} =(0.5)^{t-2}\)</span>。因此，如果满足：<spanclass="math inline">\((0.5)^t - 0.9(0.5)^{t-1} + 0.2(0.5)^{t-2} =0\)</span>， 那么 <span class="math inline">\(y^h_{1t}\)</span>就是一个解。等式两边同除以 <spanclass="math inline">\((0.5)^{t-2}\)</span>，问题就变为是否满足下式：<spanclass="math inline">\((0.5)^2 - 0.9(0.5) + 0.2 =0\)</span>。显而易见，确实等于零，同理也可验证另一个。</p><p><strong>第 2 步：求出一个特解</strong>。</p><p>显然，很容易证明特解 <spanclass="math inline">\(y_{t}^{p}=10\)</span> 也是一个解，因为 <spanclass="math inline">\(10=0.9\cdot(10)-0.2\cdot(10)+3\)</span>。</p><p><strong>第 3 步：合并特解和两个齐次解的线性组合</strong></p><p><span class="math display">\[y_{t}= a_1(0.5)^{t}+A_{2}(0.4)^{t}+10 \notag\]</span></p><p>这里，<span class="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(A_{2}\)</span> 为任意常数。</p><p><strong>第 4 步：序列初始条件</strong></p><p>在 0 期和 1 期，解必须满足</p><p><span class="math display">\[\begin{cases}13 = a_1+A_{2}+10 \\11.3 = a_1\cdot(0.5)+A_{2}\cdot(0.4)+10\end{cases}\notag\]</span></p><p>联立求解，得 <spanclass="math inline">\(a_1=1,A_{2}=2\)</span>。因此，<spanclass="math inline">\(y_t\)</span> 的解为</p><p><span class="math display">\[y_{t}=(0.5)^{t}+2(0.4)^{t}+10 \notag\]</span></p></blockquote><h3 id="144-高阶齐次解特征根">1.4.4 高阶齐次解：特征根</h3><p>第一步很麻烦，有没有什么办法？事实上，从验证齐次解的方式中，我们可以窥见特征根分析的端倪。下面，我们更系统地介绍如何得到齐次解。</p><p>设数列 <span class="math inline">\(\{x_n\}\)</span> 的前两项 <spanclass="math inline">\(x_1\)</span> 和 <spanclass="math inline">\(x_2\)</span> 已知，且满足递推关系 <spanclass="math inline">\(x_{n+1} = px_n + qx_{n-1}\)</span>。则称方程 <spanclass="math inline">\(x^2 - px - q = 0\)</span> 为该数列的<strong>特征方程</strong>。特征方程的根为该数列的<strong>特征根</strong>。</p><div class="tip"><div class="title"><p>Tip</p></div><ul><li><strong>方程</strong>：<span class="math inline">\(y_t - a_1 y_{t-1}- a_2 y_{t-2} = 0\)</span>。</li><li><strong>特征方程</strong>：<span class="math inline">\(\alpha^2 -a_1 \alpha - a_2 = 0\)</span>。</li><li><strong>根的情况</strong>：<ul><li><strong>实根且不同</strong>：<span class="math inline">\(y_t = A_1\alpha_1^t + A_2 \alpha_2^t\)</span>。</li><li><strong>实根且相同</strong>：<span class="math inline">\(y_t = (A_1+ A_2 t) \alpha^t\)</span>。</li><li><strong>虚根</strong>：用欧拉公式表示为 <spanclass="math inline">\(y_t = r^t (C_1 \cos \theta t + C_2 \sin \thetat)\)</span>，其中 <span class="math inline">\(r =\sqrt{a_2}\)</span>，<span class="math inline">\(\theta =\arctan\left(\frac{\sqrt{4a_2 - a_1^2}}{a_1}\right)\)</span>。</li></ul></li><li><strong>稳定性条件</strong>：所有特征根绝对值小于 1。稳定性条件要求r &lt; 1，因此，当把根绘制在复数平面上时，必须让它们位于一个半径为 1的圆内。在时间序列文献中，稳定性条件的简单表述是：<strong>所有的特征根都位于单位圆之内</strong>。</li></ul></div><p>我们再看个例子：</p><blockquote><p>[!note] 【例 2】：求齐次解</p><ul><li><strong>方程</strong>：<span class="math inline">\(y_t = 0.2 y_{t-1}+ 0.35 y_{t-2}\)</span>。</li><li><strong>特征方程</strong>：<span class="math inline">\(\alpha^2 -0.2 \alpha - 0.35 = 0\)</span>，解得特征根 <spanclass="math inline">\(\alpha_1 = 0.7\)</span>，<spanclass="math inline">\(\alpha_2 = -0.5\)</span>。</li><li><strong>齐次解</strong>：<span class="math inline">\(y_t = A_1(0.7)^t + A_2 (-0.5)^t\)</span>。</li></ul></blockquote><p>很好！我们会算第一步了。返回刚才的例 1，我们可以重新算一下。</p><h3 id="145-特解的处理">1.4.5 特解的处理</h3><p>除了第一步对于高阶齐次解计算有着精妙的技巧，在例 1中，我们非常不负责任的“显然易得”了特解。也很显然，我们的运气可能不总是能让我们“显然”发现特解。基于此，我们这一小节讨论特解的情况。需要强调的是，由于特解本就是“妙手偶得”的，我们在（<ahref="#1.4.4%20高阶齐次解：特征根">1.4.4高阶齐次解：特征根</a>）中讨论的所有找特解方法都只是方便找特解的技巧。</p><h4 id="1451-推动过程为零的特解">1.4.5.1 推动过程为零的特解</h4><p>寻找差分方程的特解需要智慧和毅力，方法的选取主要取决于序列 <spanclass="math inline">\(\{x\}\)</span>的形式。遵循由浅入深的原则，我们先讨论一种特殊情况的特解，即 <strong>当<span class="math inline">\(x_t=0\)</span> 时</strong> 的特解。</p><p>当序列 <span class="math inline">\(\{x_{t}\}\)</span>的所有元素均为零时，差分方程变为</p><p><span class="math display">\[y_{i} = a_0 + a_1y_{i-1} + a_2y_{i-2} + \cdots + a_ny_{i-n}\notag\]</span></p><p>这和前面的例 2 非常相似，事实上，例 2 是给定参数的二阶特例。在第1.4.4 节（<a href="#1.4.4%20高阶齐次解：特征根">1.4.4高阶齐次解：特征根</a>）中，我们只算出了例 2的齐次解，还没有得到方程的通解。遵循第 1.4.3 节（<ahref="#1.4.3%20解差分方程的通用步骤">1.4.3解差分方程的通用步骤</a>）的通用步骤，我们对方程 <spanclass="math inline">\(y_t = 0.2 y_{t-1} + 0.35 y_{t-2}\)</span>的求解还需要找到特解。通过下面对 <span class="math inline">\(n\)</span>阶情况的讨论，我们应该能够为例 2 的求解画上圆满的句号。</p><p>由于我们正在找的是特解，所以我们不用顾及任何“大而全”的普适性，只需要找最特殊的就足够了。直觉告诉我们，<spanclass="math inline">\(y\)</span> 取相同值（即 <spanclass="math inline">\(y_i=y_{i-1}=\cdots=c\)</span>）应该是目标差分方程最特殊的解了。虽然我们在这里也不可避免的“显然易得”了，但相较于例1 的“显然”，这里的直觉容易得多。将常解 <spanclass="math inline">\(y_i=c\)</span> 代入得到 <spanclass="math inline">\(c=a_0+a_1c+a_2c+\cdots+a_nc\)</span>，因而</p><p><span class="math display">\[c =\dfrac{a_0}{1-a_1-a_2-\cdots-a_n}\notag\]</span></p><p>由于分式的分母不能为 0，我们分类讨论：</p><p>只要 <span class="math inline">\((1-a_1-a_2-\cdots-a_n)\)</span>不等于零，<span class="math inline">\(c\)</span>值就是差分方程的解。因此，差分方程的特解就为 <spanclass="math inline">\(y^p_i=\dfrac{a_0}{1-a_1-a_2-\cdots-a_n}\)</span>。</p><p>如果 <spanclass="math inline">\(1-a_1-a_2-\cdots-a_n=0\)</span>，<spanclass="math inline">\(c\)</span>值是待定的，必须寻找解的其他形式。课本的讨论为我们提供了下一步的方向：我们应该考虑尝试<span class="math inline">\(y^p_i=ct\)</span>作为解，如果还不成立，就继续尝试 <span class="math inline">\(y^p_i=c\cdot t^2\)</span>、<span class="math inline">\(y^p_i=c \cdott^3\)</span>…… 总有一个会是特解的。</p><p>接下来，我们兑现前面的承诺，对例 2 的特解进行讨论。</p><blockquote><p>[!Note] 【例 2】 的特解</p><p>对于方程：<span class="math inline">\(y_t = 0.2 y_{t-1} + 0.35y_{t-2}\)</span>，我们取常解 <span class="math inline">\(y_i=c\)</span>的特殊情况。代入得：</p><p><span class="math display">\[c =\dfrac{a_0}{1-a_1-a_2}\notag\]</span></p><p>其中，<span class="math inline">\(a_0=0\)</span>，<spanclass="math inline">\(a_1=0.2\)</span>，<spanclass="math inline">\(a_2=0.35\)</span>。我们得到差分方程的特解 <spanclass="math inline">\(c\)</span>，发现就等于 0。更正式一点的写法是：</p><p><span class="math display">\[y^p_i =\dfrac{a_0}{1-a_1-a_2}= 0 \notag\]</span></p><p>有了特解 <span class="math inline">\(y^p_i=0\)</span> 和齐次解 <spanclass="math inline">\(y_t = A_1 (0.7)^t + A_2(-0.5)^t\)</span>，我们就可以得到该差分方程的通解了。</p></blockquote><h4 id="1452-待定系数法">1.4.5.2 待定系数法</h4><p>那么，如果特解比较随机，怎么处理？</p><p>当序列 <span class="math inline">\(\{y_t\}\)</span>含有随机成分时，有两种求特解的方法。我们先讨论待定系数法。</p><p>待定系数法的关键在于，线性方程具有线性解。因此，一个线性差分方程的特解必定是线性的。此外，求得的解仅依赖于时间、常数和推动过程的元素。因此，即使解的系数未知，仍有可能求得解的准确形式。这种方法涉及一个假设的解，可称这个假设的解为<strong>挑战解</strong>(challengesolution)，它是实际方程中应当出现的所有项的线性函数。这样，问题就转化成了寻找所有满足差分方程解的待定系数的值。</p><h5 id="14521-含有确定性成分的情况">1.4.5.2.1 含有确定性成分的情况</h5><p>我们首先看两个含有确定性成分的情况：</p><ul><li><strong>情况 1：含指数的例子</strong>。</li></ul><p>在这种情况下，我们令 <span class="math inline">\(x_t\)</span>取指数形式 <span class="math inline">\(b \cdot(d)^{rt}\)</span>，其中，b、d、r 都为常数。由于 r通常被解释为增长率，我们在有关增长的研究中更可能碰到它。我们运用一阶差分方程阐述求解过程：</p><p><span class="math display">\[y_{i} = a_0 + a_1y_{i-1} +b \cdot (d)^{rt} \notag\]</span></p><p>特别地，当 <span class="math inline">\(b=0\)</span>的时候，差分方程退化为 <span class="math inline">\(x_t=0\)</span>的差分方程。事实上，我们可以把 <spanclass="math inline">\((d)^{rt}\)</span> 看作 <spanclass="math inline">\({(d^{r})^t}\)</span>，即把 <spanclass="math inline">\(d^{r}\)</span> 看作整体。</p><p>我们可以 <strong>假设特解的形式</strong> 为：（即挑战解为）</p><p><span class="math display">\[y_{t}^{p}= c_0+c_1({d^{r})}^t \notag\]</span></p><p>其中，<span class="math inline">\(c_0\)</span> 和 <spanclass="math inline">\(c_1\)</span>都是常数。如果该方程确实是一个解，可以将其代入递推公式得到一个恒等式。通过恰当的代换，得到</p><p><span class="math display">\[c_0+c_1{d^r}^t = a_0+a_1 [c_0+c_1 {d^r}^{(t-1)}]+b{d^r}^t \notag\]</span></p><p>整理这个公式，如果这个公式成立，有 <spanclass="math inline">\(c_0\)</span> 和 <spanclass="math inline">\(c_1\)</span> 满足</p><p><span class="math display">\[c_0 =\frac{a_0}{1-a_1}, c_1 =\frac{bd^r}{d^r-a_1} \notag\]</span></p><p>因此，特解就为</p><p><span class="math display">\[y^p_t =\frac{a_0}{1-a_1}+\frac{bd^r}{d^r-a_1} \cdot {d^r}^t  \notag\]</span></p><p>这个解的特点就是：<span class="math inline">\(y^p_t\)</span> 等于常数<span class="math inline">\(\dfrac{a_0}{1-a_1}\)</span> 加上一个增速为<span class="math inline">\(r\)</span> 的表达式。</p><p>注意，对于 <spanclass="math inline">\(|d^r|&lt;1\)</span>，特解会收敛为 <spanclass="math inline">\(\dfrac{a_0}{1-a_1}\)</span>。</p><p>同样地，在 <span class="math inline">\(a_1=1\)</span> 或 <spanclass="math inline">\(a_1=d^r\)</span>的时候，必须寻找解的其他形式。这时的技巧是：当 <spanclass="math inline">\(a_1 =1\)</span> 时，尝试使用 <spanclass="math inline">\(c_0=ct\)</span> 作为解；而当 <spanclass="math inline">\(a_1=d^r\)</span> 时，尝试使用 <spanclass="math inline">\(c_1=tb\)</span>作为解。其中所用的方法完全适用于高阶方程。</p><ul><li><strong>情况 2：确定性时间趋势</strong>。 这时，序列 <spanclass="math inline">\(\{x_t\}\)</span> 可表示为关系式 <spanclass="math inline">\(x_t= bt^d\)</span>，其中 b 为常数，d为正整数。</li></ul><p><span class="math display">\[y_t = a_0 + \sum_{i = 1}^{t} a_i y_{t-i} + d \cdot t^d \notag\]</span></p><p>由于 <span class="math inline">\(y_t\)</span> 依赖于 <spanclass="math inline">\(t^d\)</span>，则 <spanclass="math inline">\(y_{t-1}\)</span> 依赖于 <spanclass="math inline">\((t-1)^d\)</span>，<spanclass="math inline">\(y_{t-2}\)</span> 依赖于 <spanclass="math inline">\((t-2)^d\)</span>，等等。这样，特解的形式为：</p><p><span class="math display">\[y_t^p = c_0 + c_1 t + c_2 t^2 + \cdots + c_d t^d \notag\]</span></p><p>为找到 <span class="math inline">\(c_i\)</span>的取值，可将特解代入，从 <span class="math inline">\(c_i\)</span>的恒等式中得到每个 <span class="math inline">\(c_i\)</span> 的取值。</p><p><strong>【发现】</strong>：这个特解的假设和情况 2 正好形成对照：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tx">[**特解的情况**]<br>|         $x_t$ 形式          |         假设的特解（一阶差分）          |<br>| :-----------------------: | :--------------------------: |<br>| 令$x_t$取指数形式$b \cdot d^t$  | $y_&#123;t&#125;^&#123;p&#125;= c_0+c_1 d^t$ |<br>| 令 $x_t$ 取幂函数形式 $b \cdot t^d$ |   $y_t^p = c_0 + c_1 t^d$    |<br></code></pre></td></tr></table></figure><p>尽管 <span class="math inline">\(d\)</span>可以取多个值，但在经济应用中，模型中通常含有一个线性时间趋势 (<spanclass="math inline">\(d=1\)</span>)。 举个例子，请考察 2 阶差分方程<span class="math inline">\(y_t = a_0 + a_1 y_{t-1} + a_2 y_{t-2} +bt\)</span>。假设解为：</p><p><span class="math display">\[y_t^p = c_0 + c_1 t \notag\]</span></p><p>其中，<span class="math inline">\(c_0\)</span> 和 <spanclass="math inline">\(c_1\)</span>都是待定系数，试着将这个“挑战解”代入该 2 阶差分方程，得到</p><p><span class="math display">\[c_0 + c_1 t = a_0 + a_1 [c_0 + c_1 (t - 1)] + a_2 [c_0 + c_1 (t - 2)] +bt \notag\]</span></p><p>现在选择 <span class="math inline">\(c_0\)</span> 和 <spanclass="math inline">\(c_1\)</span> 的值，使得对 <spanclass="math inline">\(t\)</span>的所有可能取值都为恒等式。如果合并所有常数项和包括 <spanclass="math inline">\(t\)</span> 在内的所有项，则所要求的 <spanclass="math inline">\(c_0\)</span> 和 <spanclass="math inline">\(c_1\)</span> 的取值就为</p><p><span class="math display">\[\begin{cases}c_1 = \dfrac{b}{1 - a_1 - a_2} \\\\c_0 = \dfrac{a_0 - (2a_2 + a_1)c_1}{1 - a_1 - a_2} =\dfrac{a_0}{1 - a_1- a_2} - \dfrac{b \cdot (2a_2 + a_1) }{(1 - a_1 - a_2)^2}\end{cases}\notag\]</span></p><h5 id="14522-一般化">1.4.5.2.2 一般化</h5><p>我们已经考虑了含有确定性成分的情况，现在我们外推到一般化的情况。也就是说，我们考虑包含<span class="math inline">\(\varepsilon_t\)</span> 的 <spanclass="math inline">\(\{x_t\}\)</span>。这时，我们应该如何使用待定系数法？</p><ul><li><strong>一阶方程</strong>：<span class="math inline">\(y_t = a_0 +a_1 y_{t-1} + \varepsilon_t\)</span>。</li></ul><p>序列 <span class="math inline">\(\{y_t\}\)</span>的特点是特征解仅依赖于常数项、时间 <spanclass="math inline">\(t\)</span> 和序列 <spanclass="math inline">\(\{\varepsilon_t\}\)</span>。因此，我们设定的挑战解应该包括常数项、时间趋势项和关于<span class="math inline">\(\varepsilon\)</span> 的项。</p><p>考虑到 <span class="math inline">\(\varepsilon\)</span>是白噪声（零均值、无自相关），其特解需体现历史扰动的累积效应，即：过去每一期误差项<span class="math inline">\(\varepsilon\)</span> 各自对当前值 <spanclass="math inline">\(y_t\)</span>的影响求和。由于各期对现在的影响不尽相同（越接近现在的权重应该更高，这在第1.3.2 节中曾阐释过），因此对于每个误差项都应该配有对应的权重参数（记为<span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(0&lt;\alpha&lt;1\)</span>）。由此，特解中应该包含<span class="math inline">\(\sum_{i=0}^{\infty} \alpha_i\varepsilon_{t-i}\)</span>。</p><p>综上，我们设定的挑战解为：</p><p><span class="math display">\[y_t = b_0 + b_1 t + \sum_{i = 0}^{\infty} \alpha_i\varepsilon_{t-i}  \notag\]</span></p><p>代入求解得，<span class="math inline">\(b_1=0\)</span>，<spanclass="math inline">\(b_0 = \frac{a_0}{1 - a_1}\)</span>。</p><ul><li><strong>二阶方程</strong>：<span class="math inline">\(y_t = a_0 +a_1 y_{t-1} + a_2 y_{t-2} + \varepsilon_t\)</span><ul><li><strong>挑战解</strong>：<span class="math inline">\(y_t = b_0 + b_1t + b_2 t^2 + \sum_{i=0}^\infty \alpha_i\varepsilon_{t-i}\)</span>。</li><li><strong>代入求解</strong>：通过比较系数确定 <spanclass="math inline">\(b_0, b_1, b_2\)</span> 及 <spanclass="math inline">\(\alpha_i\)</span>​。</li></ul></li></ul><p>首先，考虑当 <span class="math inline">\(a_1 + a_2 \neq 1\)</span>时的情况，由于 <span class="math inline">\((1 - a_1 - a_2)\)</span>不为零，那么，<span class="math inline">\(b_2\)</span> 的取值必须等于0。在 <span class="math inline">\(b_2 = 0\)</span> 的情况下，又因为<span class="math inline">\(t\)</span> 的系数必须等于零，所以，<spanclass="math inline">\(b_1\)</span> 也应为 0。在给定 <spanclass="math inline">\(b_1 = b_2 = 0\)</span> 时，必得 <spanclass="math inline">\(b_0 = \dfrac{a_0}{1 - a_1 - a_2}\)</span>。</p><p>相反，如果 <span class="math inline">\(a_1 + a_2 = 1\)</span>，则<span class="math inline">\(b_t\)</span> 的解的取值取决于 <spanclass="math inline">\(a_0, a_1\)</span> 和 <spanclass="math inline">\(a_2\)</span> 的特定取值。</p><p>关键在于齐次方程的稳定性条件就是特解的收敛条件。如果齐次方程的任意特征根都等于1，那么，多项式时间趋势就将出现在特解中。多项式的阶数就是单位特征根的个数，这一结论也可推广到高阶方程。</p><h4 id="1453-滞后算子">1.4.5.3 滞后算子</h4><p>如果不需要知道特解中的系数的实际值，则运用滞后算子（lagoperator）的方法通常比待定系数法更为方便。</p><ul><li><strong>定义</strong>：滞后算子 <spanclass="math inline">\(L\)</span> 被定义为线性算子，因而对 <spanclass="math inline">\(y_t\)</span> 取任意值，均有：</li></ul><p><span class="math display">\[L^i y_t = y_{t-i} \notag\]</span></p><p><strong>滞后算子 <span class="math inline">\(L\)</span></strong>仅意味着将序列 <span class="math inline">\(y_t\)</span> 向后移动一期，即<span class="math inline">\(L{y_t} = y_{t-1}\)</span>。请问，<spanclass="math inline">\(L^2_{y_t}=?\)</span></p><ul><li><p><strong>性质</strong>:</p><ol type="1"><li>常数的滞后值为常数： <span class="math inline">\(L_c =c\)</span>。</li><li>分配律：<span class="math inline">\(L(y_1 + y_2) = Ly_1 + Ly_2 =y_{t-1,1} + y_{t-1,2}\)</span>。</li><li>结合律： <span class="math inline">\(L^iLy_j = L^{i+j}y =y_{t-i-j}\)</span>，注意 <span class="math inline">\(L^iy_t =y_{t-i}\)</span>。</li><li>取负次方： 实际上为超前算子: <span class="math inline">\(L^{-1}y_t =y_{t+1}\)</span>。为了便于解释，可定义 <span class="math inline">\(j =-i\)</span>，并设 <span class="math inline">\(L^jy_t =y_{t+j}\)</span>。</li><li>无限求和：<ul><li>对于 <span class="math inline">\(|\alpha| &lt; 1\)</span>，有 <spanclass="math inline">\((1 + a L + a^2 L^2 + \cdots)L^n y_t =\dfrac{y_t}{1 - a L}\)</span>。</li><li>对于 <span class="math inline">\(|\alpha| &gt; 1\)</span>，有 <spanclass="math inline">\([1 + (aL)^{-1} + (aL)^{-2} + (aL)^{-3} +\cdots]y_t = \dfrac{-aL{y_t}}{1 - aL}\)</span>。</li></ul></li></ol></li><li><p><strong>滞后算子的应用</strong>：</p></li></ul><ol type="1"><li>滞后算子为书写差分方程提供了一种简洁的记号。运用滞后算子，可以将 p阶方程 <span class="math inline">\(y_t = a_0 + a_1 y_{t-1} + \cdots +a_p y_{t-p} + \varepsilon_t\)</span> 写为：</li></ol><p><span class="math display">\[(1 - a_1 L - a_2 L^2 - \cdots - a_p L^p) y_t = A(L) y_t = a_0 +\varepsilon_t \notag\]</span></p><p>其中，<span class="math inline">\(A(L)\)</span> 为多项式 <spanclass="math inline">\((1 - a_1 L - a_2 L^2 - \cdots - a_pL^p)\)</span>。它的成立是基于此前的 <spanclass="math inline">\(y\)</span> 对于现在而言都是参数。</p><ol start="2" type="1"><li>由于 <span class="math inline">\(A(L)\)</span>可被视为滞后算子的多项式，因此记号 <spanclass="math inline">\(A(1)\)</span> 可用于表示所有系数之和：</li></ol><p><span class="math display">\[A(1) = 1 - a_1 - a_2 - \cdots - a_p \notag\]</span></p><ul><li><strong>用滞后算子解线性差分方程</strong>： 再次考虑一阶方程 <spanclass="math inline">\(y_{t}=a_0+a_1y_{t-1}+\varepsilon_{t}\)</span>，式中，<spanclass="math inline">\(\mid a_1 \mid &lt;1\)</span>。根据 L的定义，构造</li></ul><p><span class="math display">\[y_t = a_0+a_1Ly_t+\varepsilon_t \notag\]</span></p><p>解 <span class="math inline">\(y_t\)</span>，我们得到：</p><p><span class="math display">\[y_{t}=\frac{a_0+\varepsilon _{t}}{1-a_1L} \notag\]</span></p><p>根据性质(1)，可知 <span class="math inline">\(La_0=a_0\)</span>，因而<spanclass="math inline">\(\dfrac{a_0}{1-a_1L}=a_0+a_1a_0+a_1^{2}a_0+\cdots=\dfrac{a_0}{1-a_1}\)</span>。</p><p>根据性质(5)，可知 <spanclass="math inline">\(\dfrac{\varepsilon_{t}}{1-a_1L}=\varepsilon_{t}+a_1\varepsilon_{t-1}+a_1^{2}\varepsilon_{t-2}+\cdots\)</span>，合并解的两个部分，便得到迭代法得到的特解。</p><ul><li>【<strong>一般化</strong>】滞后算子可以把方程表示为：</li></ul><p><span class="math display">\[y_t = a_0 + a_1 y_{t-1} + \cdots + a_p y_{t-p} + \varepsilon_t + \beta_1\varepsilon_{t-1} + \cdots + \beta_q \varepsilon_{t-q} \Rightarrow A(L)y_t = a_0 + B(L) \varepsilon_t \notag\]</span></p><p>其中，<span class="math inline">\(A(L)\)</span> 和 <spanclass="math inline">\(B(L)\)</span> 分别为 p 阶和 q阶的多项式。该模型的特解为：</p><p><span class="math display">\[y_t = \frac{a_0}{A(L)} + \frac{B(L)\varepsilon_t}{A(L)}\notag\]</span></p><p>如果想了解序列的实际系数，最好采用待定系数法，滞后算子的魅力在于能够简洁地标记特解。</p><h2 id="15-自回归ar模型">1.5 自回归（AR）模型</h2><p>不知道你是否有注意到，在 1.4 节中，我们对差分方程的讨论主要围绕着的是1.3.2节提出的“一种特殊类型的差分方程”。现在，我们正式认识下这个“威名赫赫”的重要模型——<strong>自回归模型</strong>（Auto-regressionModel），简称 AR(<spanclass="math inline">\(p\)</span>)。值得注意的是，这一节的内容大多数都已经在前面讲过，如果说前面的讲法更偏数学，这一节的讲法则是更统计学的。</p><h3 id="151-自回归模型">1.5.1 自回归模型</h3><blockquote><p>[!Note] 定义（自回归模型） 如果时间序列 <spanclass="math inline">\(\{y_t\}\)</span> 能用如下形式表示：</p><p><span class="math display">\[\begin{split}y_t &amp;= a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \cdots + a_p y_{t-p} +\varepsilon_t \\&amp;= a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + \varepsilon_t \notag\end{split}\]</span></p><p>则称 <span class="math inline">\(\{y_t\}\)</span> 服从 <spanclass="math inline">\(p\)</span> 阶自回归模型，记为 AR(<spanclass="math inline">\(p\)</span>)，其中，p 为模型的阶数， <spanclass="math inline">\(\varepsilon_t\)</span> 是均值为 0、标准差为 <spanclass="math inline">\(\sigma_\varepsilon\)</span> 的白噪声序列。</p><p>AR(<span class="math inline">\(p\)</span>)模型表示：给定过去的数据时，过去的 <spanclass="math inline">\(p\)</span> 个值 <spanclass="math inline">\(y_{t-i}(i=1,2,\ldots,p)\)</span> 联合决定 <spanclass="math inline">\(y_t\)</span> 的条件期望。</p></blockquote><h3 id="152-ar1模型">1.5.2 AR(1)模型</h3><ul><li><p>当阶数 <span class="math inline">\(p = 1\)</span> 时，AR(<spanclass="math inline">\(p\)</span>)模型简化为 AR(1)模型，即 <spanclass="math display">\[ y_t = a_0 + a_1 y_{t-1} + \varepsilon_t, \quad\varepsilon_t \sim i.i.d. N(0, \sigma_\varepsilon^2)\notag\]</span></p></li><li><p>AR(1)模型刻画了一个随机过程或时间序列：<spanclass="math inline">\(\{r_t, t \in Z\}\)</span>；</p></li><li><p>根据 AR(1)模型定义有：</p><ul><li>条件期望：<span class="math inline">\(E(y_t | y_{t-1}) = a_0 + a_1y_{t-1}\)</span></li><li>条件方差：<span class="math inline">\(Var(y_t | y_{t-1}) =\sigma_\varepsilon^2\)</span></li></ul></li></ul><h4 id="1521-ar1的线性特征">1.5.2.1 AR(1)的线性特征</h4><p>正如我们在 <a href="#1.4.2.1%20迭代法">1.4.2.1 迭代法</a>中所做的，将 AR(1)模型的递推可以得到</p><p><span class="math display">\[y_t = a_0 \sum_{i = 0}^{t-1} a_1^i + a_1^t y_0 + \sum_{i = 0}^{t-1}a_1^i \varepsilon_{t-i} \notag\]</span></p><ul><li>当 <span class="math inline">\(|a_1| &lt; 1 \quad t \rightarrow∞\)</span>，第一项是几何级数，第二项趋于 0，有：</li></ul><p><span class="math display">\[y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^∞ a_1^i \varepsilon_{t-i}\notag\]</span></p><ul><li>这是一个线性时间序列，被称为 MA(<spanclass="math inline">\(∞\)</span>) 形式。自然地，我们会问：什么是 MA？MA是移动平均模型的简写，我们会在 <ahref="#2.1.2%20移动平均模型（MA）">2.1.2 移动平均模型（MA）</a>内容中更详细的介绍它。关于 AR 和 MA 的互推条件，我们也将在 <ahref="#2.3.5.2%20可逆性">2.3.5.2 可逆性</a> 中进一步论述。</li></ul><h4 id="1522-ar1的平稳性">1.5.2.2 AR(1)的平稳性</h4><ul><li><p>AR(1)模型的平稳性指时间序列 <spanclass="math inline">\(\{y_t\}\)</span>是否是一个平稳时间序列。直观理解，任意给定一个初始值 <spanclass="math inline">\(y_0\)</span>，经过一段时间后，序列可以稳定下来，即围绕某个固定值以相同的幅度上下波动。</p></li><li><p>不是所有 AR(1)模型刻画的随机过程都是平稳时间序列：当AR(1)模型刻画了一个平稳的时间序列，则称 AR(1)模型是平稳的；当AR(1)模型刻画了一个非平稳的时间序列，则称 AR(1)模型是非平稳的。平稳的AR(1) 模型才能用于预测。</p></li><li><p><strong>AR(1)模型平稳性的充要条件是：<spanclass="math inline">\(|a_1| &lt; 1\)</span></strong>。</p></li></ul><blockquote><p>[!Note] 证明：AR(1)模型平稳性的充要条件是：<spanclass="math inline">\(|a_1| &lt; 1\)</span>。</p><p>首先，我们简单回顾 <a href="#1.2%20平稳性">1.2 平稳性</a>节对平稳性的介绍：</p><ul><li><p>严平稳太过严格，我们通常考虑弱平稳序列。</p></li><li><p><strong>弱平稳的定义</strong>：当 <spanclass="math inline">\(E(y_t)\)</span> 是常数、<spanclass="math inline">\(Cov(y_t, y_{t-l})\)</span> 只依赖于 <spanclass="math inline">\(l\)</span> 时，时间序列 <spanclass="math inline">\(y_t\)</span> 是弱平稳的。</p></li></ul><p>然后，我们开始证明：</p><p><strong>1. 充分性：</strong> （1）当 <spanclass="math inline">\(|a_1| &lt; 1\)</span>，我们先考察 <spanclass="math inline">\(E(y_t)\)</span> 是否为常数：</p><p><span class="math display">\[y_t = \dfrac{a_0}{1-a_1} + \sum_{i = 0}^{\infty} a_1^i \varepsilon_{t-i}\quad \Rightarrow \quad \mathbb{E}(y_t) = \dfrac{a_0}{1-a_1} \quad(\text{常数})\]</span></p><p>（2）然后，我们考察 <span class="math inline">\(|a_1| &lt; 1\)</span>时的协方差：</p><p><span class="math display">\[\mathbb{Cov}(y_t, y_{t-l}) = \mathbb{Cov}\left(\sum_{i = 0}^{\infty}a_1^i \varepsilon_{t-i}, \sum_{j = 0}^{\infty} a_1^j\varepsilon_{t-l-j}\right)\]</span></p><p>根据协方差的定义，我们可以将其展开为双重求和：</p><p><span class="math display">\[\mathbb{Cov}(y_t, y_{t-l}) = \mathbb{Cov}\left (\sum_{i = 0}^\inftya_1^i \varepsilon_{t-i}, \sum_{j = 0}^\infty a_1^j\varepsilon_{t-l-j}\right) = \sum_{i = 0}^\infty \sum_{j = 0}^\inftya_1^i a_1^j \mathbb{Cov}(\varepsilon_{t-i}, \varepsilon_{t-l-j})\]</span></p><p>由于 <span class="math inline">\(\varepsilon\)</span> 是一个方差为<span class="math inline">\(\sigma^2\)</span> 的白噪声过程，不同时间的<span class="math inline">\(\varepsilon\)</span>不相关，则协方差项仅在时间点相等时非零（<spanclass="math inline">\(=\sigma^2\)</span>），即当 <spanclass="math inline">\(t - i = t - l - j\)</span> 时，也就是 <spanclass="math inline">\(i = l + j\)</span>。因此，双重求和中只有当 <spanclass="math inline">\(i = l + j\)</span> 时才有贡献。将 <spanclass="math inline">\(i\)</span> 替换为 <span class="math inline">\(l +j\)</span>，我们得到单重求和：</p><p><span class="math display">\[\mathbb{Cov}(y_t, y_{t-l}) = \sum_{j = 0}^\infty a_1^{l+j} a_1^j\mathbb{Cov}(\varepsilon_{t-l-j}, \varepsilon_{t-l-j})= \sigma^2 \sum_{j= 0}^\infty a_1^{l+2j} = a_1^l \cdot \sigma^2 \sum_{j = 0}^\infty(a_1^2)^j = \frac{a_1^l \sigma^2 }{1-a_1^2}\]</span></p><p>这表明，协方差只依赖于 <span class="math inline">\(l\)</span>，与<span class="math inline">\(t\)</span>无关。如果认为双重求和转化为单重求和太复杂，<ahref="#2.3.3.1%20自相关函数（ACF）">2.3.3.1 自相关函数（ACF）</a>还提供了另一种递推的方法。</p><p>综上，AR(1)模型在 <span class="math inline">\(|a_1| &lt; 1\)</span>时满足弱平稳的定义。</p><p><strong>2. 必要性</strong> 假设 <spanclass="math inline">\(\{y_t\}\)</span> 是平稳时间序列，对 AR(1)公式<span class="math inline">\(y_t = a_0 + a_1 y_{t-1} +\varepsilon_t\)</span> 两边取期望得到：</p><p><span class="math display">\[\mathbb{E}(y_t) = a_0 + a_1 \mathbb{E}(y_{t-1}) \quad \Rightarrow \quad\mathbb{E}(y_t) = \frac{a_0}{1 - a_1}\]</span></p><p>两边取方差得到：</p><p><span class="math display">\[\mathbb{Var}(y_t) = \mathbb{Var}(a_0 + a_1 y_{t-1} + \varepsilon_t) =a_1^2 \mathbb{Var}(y_{t-1}) + \mathbb{Var}(\varepsilon_t) + a_1\mathbb{Cov}(y_{t-1}, \varepsilon_t)\]</span></p><ul><li>根据 <span class="math inline">\(y_t = \frac{a_0}{1 - a_1} + \sum_{i= 0}^∞ a_1^i \varepsilon_{t-i}\)</span>，<spanclass="math inline">\(y_t\)</span> 完全由 <spanclass="math inline">\(t\)</span> 期及以前的冲击决定，进而 <spanclass="math inline">\(y_{t-1}\)</span> 完全由 <spanclass="math inline">\(t-1\)</span>期及以前的冲击决定，由于冲击之间的独立性，<spanclass="math inline">\(\mathbb{Cov}(y_{t-1}, \varepsilon_t) =0\)</span>；</li><li>【<font color="#245bdb"> 非常重要 </font>】<strong>基于 <spanclass="math inline">\(\{y_t\}\)</span> 平稳的假设，方差在时间上恒定，即<spanclass="math inline">\(\mathbb{Var}(y_t)=\mathbb{Var}(y_{t-1})\)</span>。</strong></li><li>由此可得到：<span class="math display">\[\mathbb{Var}(y_t) =\frac{\sigma_\varepsilon^2}{1 - a_1^2}\]</span></li></ul><p>为了使 <span class="math inline">\(\mathbb{E}(y_t) = \dfrac{a_0}{1 -a_1}\)</span> 存在且为常数，则要求 <span class="math inline">\(a_1 \neq1\)</span> ；</p><p>为了使 <span class="math inline">\(\mathbb{Var}(y_t) =\dfrac{\sigma_a^2}{1 - a_1^2}\)</span> 存在且为正常数，则要求 <spanclass="math inline">\(|a_1| &lt; 1\)</span> 。 即 <spanclass="math inline">\(\{y_t\}\)</span> 为平稳序列要求 <spanclass="math inline">\(|a_1| &lt; 1\)</span>。</p></blockquote><h4 id="1523-ar1的统计特征">1.5.2.3 AR(1)的统计特征</h4><p>在上一节中我们得到：对于平稳 AR(1)序列 <spanclass="math inline">\(y_t = a_0 + a_1 y_{t-1} + \varepsilon_t\)</span>，有：<span class="math inline">\(\mathbb{E}(y_t) = \dfrac{a_0}{1 -a_1}\)</span> ，<span class="math inline">\(\mathbb{Var}(y_t) =\dfrac{\sigma_\varepsilon^2}{1 - a_1^2}\)</span>。其中 <spanclass="math inline">\(a_0\)</span> 是截距项，<spanclass="math inline">\(a_1\)</span> 是滞后项系数。</p><ul><li><p>当 <span class="math inline">\(a_0 = 0\)</span> 时，<spanclass="math inline">\(\mathbb{E}(y_t) = 0\)</span>，这表明没有截距项的AR(1)模型，时间序列的均值为 0。</p></li><li><p>当 <span class="math inline">\(a_1 = 0\)</span> 时，此时时间序列<span class="math inline">\(\{y_t\}\)</span>变为白噪声序列，方差最小；当 <span class="math inline">\(a_1 ≠0\)</span> 时，序列 <span class="math inline">\(\{y_t\}\)</span>的方差变大，这说明时间序列 <span class="math inline">\(\{y_t\}\)</span>自相关系数越大，时间序列的方差越大，波动越剧烈。</p></li><li><p>下面，我们考察 AR(1)模型的自相关系数。根据方程，由于 <spanclass="math display">\[ \mathbb{Cov}(y_t, y_{t-l}) = \frac{a_1^l}{1 -a_1^2} \sigma_\varepsilon^2, \]</span>因此自相关系数（如果忘记了自相关系数，请参阅 <a href="#1.2%20平稳性">1.2平稳性</a>）为： <span class="math display">\[ \rho =\dfrac{\mathbb{Cov}(y_t, y_{t-l})}{\mathbb{Var}(y_t)} =\dfrac{\dfrac{a_1^l}{1 - a_1^2} \sigma_\varepsilon^2}{\dfrac{1}{1 -a_1^2} \sigma_\varepsilon^2} = a_1^l. \]</span> 这说明：当 <spanclass="math inline">\(∣a_1​∣&lt;1\)</span> 时，弱平稳 AR(1)序列的自相关函数随滞后阶数 <spanclass="math inline">\(l\)</span> 增大而指数衰减。</p></li></ul><h3 id="153-ar2模型">1.5.3 AR(2)模型</h3><p>当阶数 <span class="math inline">\(p = 2\)</span> 时，AR(p)模型简化为 AR(2) 模型，形式如下：</p><p><span class="math display">\[y_t = a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \varepsilon_t, \quad\varepsilon_t \text{ 是白噪声过程}\]</span></p><ul><li><strong>1. AR(2)模型的线性性质</strong>： 首先，将 AR(2) 转换为VAR(1) 形式：</li></ul><p><span class="math display">\[\begin{pmatrix}  y_t \\  y_{t-1} \end{pmatrix}  = \begin{pmatrix}  a_0 \\  0 \end{pmatrix}  + \begin{pmatrix}  a_1 &amp; a_2 \\  1 &amp; 0  \end{pmatrix} \begin{pmatrix}  y_{t-1} \\  y_{t-2} \end{pmatrix}  + \begin{pmatrix}  \varepsilon_t \\  0 \end{pmatrix}\]</span></p><p>设 <span class="math inline">\(\mathbf{Y}_t = (y_t,y_{t-1})^\top\)</span>，<span class="math inline">\(\mathbf{u}_t =(\varepsilon_t, 0)^\top\)</span>，则方程可改写为：</p><p><span class="math display">\[\mathbf{Y}_t = \mathbf{A}_0 + \mathbf{A}_1 \mathbf{Y}_{t-1} +\mathbf{u}_t\]</span></p><p>向前递推得到：</p><p><span class="math display">\[\mathbf{Y}_t = \mathbf{A}_0 + \mathbf{A}_1 \mathbf{A}_0 + \mathbf{A}_1^2\mathbf{Y}_{t-2} + \mathbf{A}_1 \mathbf{u}_{t-1} + \mathbf{u}_t = \cdots= (1 - \mathbf{A}_1)^{-1} \mathbf{A}_0 + \mathbf{A}_1^\infty\mathbf{Y}_{t-\infty} + \sum_{i = 0}^\infty \mathbf{A}_1^i\mathbf{u}_{t-i}  \]</span></p><p>当矩阵 <span class="math inline">\(\mathbf{A}_1\)</span>的特征值都位于单位圆内时，<spanclass="math inline">\(\mathbf{A}_1^\infty =0\)</span>，方程可简化为：<span class="math display">\[ \mathbf{Y}_t =(1 - \mathbf{A}_1)^{-1} \mathbf{A}_0 + \sum_{i=0}^\infty \mathbf{A}_1^i\mathbf{u}_{t-i} \]</span> 进一步得到 <spanclass="math inline">\(y_t\)</span> 的表达式：</p><p><span class="math display">\[y_t = (1, 0)(1 - \mathbf{A}_1)^{-1} \mathbf{A}_0 + \sum_{i=0}^\infty b_i\varepsilon_{t-i}\]</span></p><p>其中 <span class="math inline">\(b_i = (1, 0)\mathbf{A}_1^i(1,0)^\top\)</span>，即 <span class="math inline">\(\mathbf{A}_1^i\)</span>的第 <span class="math inline">\((1, 1)\)</span> 个元素。 <spanclass="math inline">\(\mu = (1, 0)(1 - \mathbf{A}_1)^{-1}\mathbf{A}_0\)</span> 。</p><ul><li><strong>2. AR(2)模型平稳条件</strong></li></ul><p>利用 1.4.5.3 节讲到的滞后算子改写：<span class="math inline">\(y_t =a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \varepsilon_t\)</span> ，得到： <spanclass="math display">\[\begin{align*}  \Big(1 - a_1 L - a_2 L^2\Big) y_t = A(L) y_t = a_0 + \varepsilon_t  \end{align*}  \]</span></p><p>其中：<span class="math inline">\(A(L)\)</span> 称为AR(2)模型的<strong>特征多项式</strong>。根据特征多项式得到AR(2)模型的<del><strong>特征方程</strong></del>：</p><p><span class="math display">\[\begin{align*}  A(x) = 1 - a_1 x - a_2 x^2 = 0  \end{align*}  \]</span></p><center> <b><span style="background:#fff88f">AR (2) 模型平稳的充要条件是：上述特征方程的根全在单位圆外。</span></b> </center><ul><li><p>不对啊！这和我们前面 1.4.4 节讲的不一样！在 1.4.4节中，我们要求特征根在单位圆内！</p><ul><li>这里用词很讲究：“特征方程的根”而不是“特征根”！</li><li>1.4.4节中，特征根对应的特征方程和这个不一样！当时我们的特征方程是：<spanclass="math inline">\(\lambda^2 - p\lambda - q =0\)</span>。这里的特征方程可以看作是 <spanclass="math inline">\(x=\dfrac{1}{\lambda}\)</span>的改写。所以，这里的特征方程应该被叫做<strong>“逆特征方程”</strong>。</li><li>本质上讲，在这里，滞后算子 <span class="math inline">\(L\)</span>的影响相当于整体除以 <span class="math inline">\(y_t\)</span>。而在1.4.4 节，我们的整体除以 <spanclass="math inline">\(y_{t-2}\)</span>！（对于 AR(p)，1.4.4节的方法是整体除以 <span class="math inline">\(y_{t-p}\)</span>）。</li></ul></li><li><p><strong>AR(2)平稳的充要条件为：AR(2)模型的特征根均在单位圆内</strong>。</p></li><li><p>【或者】：<strong>AR(2)模型平稳的充要条件是：AR(2)模型的逆特征方程的根全在单位圆外。</strong></p></li></ul><blockquote><p>[!Excercise] 考虑四组 <span class="math inline">\(\{a_1,a_2\}\)</span> 组合下的 AR(2) 过程平稳性：</p><ol type="1"><li><span class="math inline">\(a_1 = 0.4, a_2 = 0.5\)</span></li><li><span class="math inline">\(a_1 = -0.6, a_2 = 0.5\)</span></li><li><span class="math inline">\(a_1 = 0.7, a_2 = -0.1\)</span></li><li><span class="math inline">\(a_1 = 1.2, a_2 = -0.8\)</span></li></ol></blockquote><h3 id="154-arp模型">1.5.4 AR(p)模型</h3><p>我们先写出 AR(p) 模型的形式，然后分析它的线性特征和平稳性特征：</p><p><span class="math display">\[\begin{split}y_t &amp;= a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \cdots + a_p y_{t-p} +\varepsilon_t \\&amp;= a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + \varepsilon_t \notag\end{split}\]</span></p><ol type="1"><li><strong>线性特征</strong>：类似于 AR(2)，最后递推得到：</li></ol><p><span class="math display">\[y_t = \mathbf{A}_0 (I_p - \mathbf{A}_1)^{-1} + \mathbf{A}_1^\inftyy_{t-\infty} + \sum_{i = 0}^\infty \mathbf{A}_1^i \boldsymbol{u}_{t-i}  \]</span></p><p>当特征根均在单位圆内时，为线性时间序列。</p><ol start="2" type="1"><li><strong>平稳性</strong>：</li></ol><ul><li><strong>AR(p) 模型的特征多项式</strong>：</li></ul><p><span class="math display">\[A(L) = 1 - a_1 L - a_2 L^2 - \cdots - a_p L^p  \]</span></p><ul><li><strong>AR(p) 模型对应的逆特征方程</strong>：</li></ul><p><span class="math display">\[A(L) = 1 - a_1 L - a_2 L^2 - \cdots - a_p L^p = 0\]</span></p><ul><li><strong>AR(p) 模型平稳的充要条件</strong>：</li></ul><p><span class="math display">\[1 - a_1 L - a_2 L^2 - \cdots - a_p L^p = 0  \]</span></p><p>逆特征方程的所有根均位于 <strong>单位圆外</strong>（模长 &gt; 1）。或通过变量替换 <span class="math inline">\(x =1/L\)</span>，方程改写为</p><p><span class="math display">\[x^p - a_1 x^{p-1} - \cdots - a_p = 0  \]</span></p><p>要求所有特征根均位于 <strong>单位圆内</strong>（模长 &lt; 1）。</p><h1 id="chapter-2-平稳时间序列模型">Chapter 2: 平稳时间序列模型</h1><blockquote><p>[!IMPORTANT] 本章学习目标</p><ol type="1"><li><p>阐述随机线性差分方程理论。</p></li><li><p>拓展在估计 ARMA 模型中使用的工具。</p></li><li><p>考察平稳和非平稳模型的时间序列性质。</p></li><li><p>考察多种统计检验方法来检验模型的充分性。文中举了几个例子，详细地分析了估计出的AR-MA 模型，并说明如何运用恰当的已估模型进行预测。</p></li><li><p>推导不同 ARMA 过程的理论自相关函数。</p></li><li><p>推导不同 ARMA 过程的理论偏自相关函数。</p></li><li><p>阐述 Box-Jenkins方法在模型选择过程中是怎样依赖于自相关和偏自相关的，</p></li><li><p>扩展 Box-Jenkins 模型选择工具的完备集。</p></li><li><p>检验时间序列预测的性质。</p></li><li><p>以利率期限结构模型为例证明 Box-Jenkins 方法。</p></li><li><p>阐述模型序列如何包含季节因素。</p></li><li><p>扩展模型精确度的诊断性检验。</p></li><li><p>阐述组合预测为何明显优于单个模型的预测。</p></li></ol></blockquote><h2 id="21-随机差分方程模型">2.1 随机差分方程模型</h2><p>目标：模拟动态经济过程</p><h3 id="211-白噪声过程">2.1.1 白噪声过程</h3><p>白噪声（white-noise）过程是一种特殊的时间序列模型，对应的是纯随机序列。</p><blockquote><p>[!Note] 定义：白噪声若序列中每个元素均值都为零，同时具有同方差，且与所有其他的实现值之间不存在自相关，则序列<span class="math inline">\({\varepsilon_t}\)</span> 为白噪声过程。</p><p><strong><font color="#c00000">白噪声过程的统计特征：零均值，同方差，无自相关（协方差为0）</font></strong>。对于正态分布而言，不相关即可推出独立，所以如果该白噪声如果服从正态分布，则其还将互相独立。</p></blockquote><p>根据 <strong>白噪声过程的统计特征</strong>，我们可以得到：如果序列<span class="math inline">\({\varepsilon_t}\)</span>为白噪声过程，有：</p><p><strong>【零均值】</strong>：若符号 <spanclass="math inline">\(E(x)\)</span> 代表 <spanclass="math inline">\(x\)</span> 的理论均值，对每个时期 <spanclass="math inline">\(t\)</span>，有：</p><p><span class="math display">\[E(\varepsilon_t)=E(\varepsilon_{t-1})=\cdots=0\]</span></p><p><strong>【同方差】</strong>：用 <spanclass="math inline">\(Var(x)\)</span> 代表 <spanclass="math inline">\(x\)</span> 的方差，对每个时期 <spanclass="math inline">\(t\)</span>，有：</p><p><span class="math display">\[\operatorname{Var}(\varepsilon_t)=\operatorname{Var}(\varepsilon_{t-1})=\cdots=\sigma^2\]</span></p><p>或者，由于 <span class="math inline">\(Var(x)= E(x^2)-[E(x)]^2\)</span> ，结合零均值特征 <spanclass="math inline">\(E(x)≡0\)</span>，有：</p><p><span class="math display">\[E(\varepsilon_t^2)=E(\varepsilon_{t-1}^2)=\cdots=\sigma^2\]</span></p><p><strong>【无自相关（协方差为 0）】</strong> 对所有的 <spanclass="math inline">\(j\)</span> 和 <spanclass="math inline">\(s\)</span>，有：</p><p><span class="math display">\[\operatorname{Cov}(\varepsilon_t,\varepsilon_{t-j})=\operatorname{Cov}(\varepsilon_{t-j},\varepsilon_{t-j-s})=0\]</span></p><p>或者，由于 <spanclass="math inline">\(Cov(x，y)=E(xy)-E(x)E(y)\)</span>，结合零均值特征<span class="math inline">\(E(x)=E(y)=0\)</span>，有：</p><p><span class="math display">\[E(\varepsilon_t\varepsilon_{t-j})=E(\varepsilon_{t-1}\varepsilon_{t-j-s})=0\]</span></p><blockquote><p>[!Tip] 思考：<strong>白噪声</strong> 是平稳过程吗？ （提示：结合 <ahref="#1.2%20平稳性">1.2 平稳性</a> 对于时间序列弱平稳的讨论）</p><ol type="1"><li><strong>均值恒定</strong>：<span class="math inline">\(E(y_t) =\mu\)</span>（各时期数学期望恒定）</li><li><strong>方差恒定</strong>：<spanclass="math inline">\(\text{Var}(y_t) =\sigma^2\)</span>（各时期方差恒定）</li><li><strong>协方差仅依赖时间间隔（而不随时间变化）</strong>：<spanclass="math inline">\(\text{Cov}(y_i, y_j) =\gamma_{|i-j|}\)</span>（任意两时期的协方差仅与时间间隔绝对值有关）</li></ol><p><strong><font color="#c00000">我们发现，白噪声符合以上三个要求，白噪声是平稳过程。</font></strong></p><p>事实上，白噪声序列一定是平稳序列,而且是最简单的平稳序列。若给定时间序列是白噪声序列，则无需预测。</p></blockquote><h3 id="212-移动平均模型ma">2.1.2 移动平均模型（MA）</h3><p>现在，我们用白噪声过程来构造移动平均模型（MA 模型）。MA模型基于白噪声序列的假设，描述的是当前时间点的数据与过去噪声的关系。</p><h4 id="2121-移动平均模型是什么">2.1.2.1 移动平均模型是什么？</h4><p>移动平均模型（MA）的 <strong>核心思想</strong>是：我们可以把一个时间序列看作是过去若干期噪声的加权平均，即当前的观察值是由过去的白噪声通过一定的线性组合得到的。</p><p>即，MA(q)模型可以写成：</p><p><span class="math display">\[x_t = \beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} + \cdots+\beta_q \varepsilon_{t-q} = \sum_{i = 0}^{q} \beta_i \varepsilon_{t-i}\notag\]</span></p><p>对任意时期 <span class="math inline">\(t\)</span>，对 <spanclass="math inline">\(\varepsilon_t\)</span>，<spanclass="math inline">\(\varepsilon_{t-1}\)</span>，…，<spanclass="math inline">\(\varepsilon_{t-q}\)</span> 依次取值并乘以对应的<span class="math inline">\(\beta_i\)</span> 即可计算出 <spanclass="math inline">\(x_t\)</span>，我们把这样的序列称为 <spanclass="math inline">\(q\)</span> 阶移动平均（moving average），用 MA<span class="math inline">\((q)\)</span> 表示。</p><ul><li><span class="math inline">\(x_t\)</span>是我们感兴趣的时间序列在时间点 <span class="math inline">\(t\)</span>的观察值。</li><li><span class="math inline">\(\varepsilon_t, \varepsilon_{t-1},\varepsilon_{t-2}, \dots,\varepsilon_{t-q}\)</span>：这些是白噪声项，每个时间点的值都是独立同分布的，通常假设为正态分布。这些项的均值为<span class="math inline">\(0\)</span>，方差为 <spanclass="math inline">\(\sigma^2\)</span>（常数）。<spanclass="math inline">\(\varepsilon_t\)</span> 是当前时刻的白噪声，<spanclass="math inline">\(\varepsilon_{t-1}\)</span>是上一时刻的白噪声，依此类推，<spanclass="math inline">\(\varepsilon_{t-q}\)</span> 是 <spanclass="math inline">\(q\)</span> 个时刻前的白噪声。</li><li><span class="math inline">\(\beta_1, \beta_2, \dots,\beta_q\)</span>：这些是 MA 模型的参数，每个参数 <spanclass="math inline">\(\beta\)</span>都对应一个白噪声项。它们衡量的是对应的白噪声对当前时间点的影响程度。</li><li><span class="math inline">\(q\)</span>是阶数，表示有多少个过去的白噪声项被纳入模型，指的是在模型中包含的过去白噪声项的数量。例如，如果<span class="math inline">\(q=2\)</span>，那么模型就包含了 <spanclass="math inline">\(\varepsilon_{t-1}\)</span> 和 <spanclass="math inline">\(\varepsilon_{t-2}\)</span> 两个白噪声项。</li></ul><blockquote><p>[!Excercise] 练一练：请写出 MA(<spanclass="math inline">\(∞\)</span>)</p></blockquote><p><strong>【补充】</strong>：在一些版本的 MA 模型中，模型被写作</p><p><span class="math display">\[x_t = \mu + \varepsilon_t + \beta_1 \varepsilon_{t-1} + \cdots +\beta_q\varepsilon_{t-q} \notag\]</span></p><p>它较上面模型有两处改变：（1）多包括时间序列的均值或期望值 <spanclass="math inline">\(\mu\)</span> ，<spanclass="math inline">\(\mu\)</span> 对所有的时间点都是相同的。不加 <spanclass="math inline">\(\mu\)</span> 的时间序列可以被视为<strong>已经通过差分或去趋势转换为均值为零</strong>的序列。（2）为方便采用标准化，使 <spanclass="math inline">\(\beta_0\)</span> 恒等于 1。</p><blockquote><p>[!Tip] 为什么叫做【移动平均模型】？移动平均模型（MA）认为：大部分时候时间序列应当是相对稳定的。在稳定的基础上，每个时间点上的值受过去一段时间内、不可预料的各种偶然事件影响而波动。</p><p>即在一段时间内，<strong>时间序列应该是围绕着某个均值上下波动的序列</strong>，时间点上的值会围绕着某个均值移动，因此模型才被称为“移动平均模型“。<strong>它的预测值是过去白噪声的加权平均</strong>。</p></blockquote><blockquote><p>[!Note] MA 模型的前提假设移动平均模型（MA）的基本假设可以从以下几个方面来理解：</p><ol type="1"><li><p><strong>平稳性</strong>：MA模型假设时间序列是平稳的。这意味着序列的主要统计属性，如均值和方差，不随时间变化。这个假设强调了序列在长期内保持稳定的行为，而在短期内可能会受到随机因素的影响。</p></li><li><p><strong>白噪声</strong>：MA模型假设存在一个白噪声序列。白噪声是随机误差项，它的均值为0，方差为常数，且各个时间点上的值是相互独立的。这个假设强调了在一段较短的时间内，时间序列的波动可能受到不可预测的随机因素的影响。</p></li><li><p><strong>线性</strong>：MA模型假设时间序列可以被过去的白噪声项的线性组合表示。这就是模型被称为“移动平均”模型的原因，因为它的预测值是过去白噪声的加权平均。</p></li><li><p><strong>有限历史影响</strong>：MA 模型假设只有过去的 q个白噪声才对当前时间点的值有影响，其中 q是模型的阶数。换言之，<span style="color: blue">过去更久的白噪声对当前值没有直接影响</span>（如<span class="math inline">\(cov(x_t,x_{t-q-1})=0\)</span>）。</p></li><li><p><strong>值的关联性与白噪声的独立性</strong>：MA模型假设不同时间点的值之间是关联的，这反映了历史影响时间序列的长期趋势。而偶然事件在不同时间点上产生的影响（即白噪声）是相互独立的，这反映了在短期内，时间序列的波动可能受到不可预测的随机因素的影响。</p></li></ol></blockquote><p><strong>【举个例子】</strong>：影响明日会不会下雨的真正因素并不是“今天”或“昨天”这些时间概念本身，而是风、云、日照等更加客观和科学的因素（这些其实就是MA模型认为的“偶然因素”）。不过也能够理解，随着季节的变化、时间自有自己的周期，因此天气也会存在季节性的周期，因此从长期来看时间序列的趋势是恒定的。</p><h4 id="2122-maq-的平稳性">2.1.2.2 MA(q) 的平稳性</h4><p>我们先展示结论：</p><blockquote><p>[!Note] MA(q) 的平稳性：</p><ul><li><strong>当 <span class="math inline">\(q\)</span> 为有限值时，MA(q)一定是平稳过程。</strong></li><li><strong>当 <span class="math inline">\(q \to \infty\)</span>（无穷阶MA），若对任意 <span class="math inline">\(s\)</span> 有 <spanclass="math inline">\(\beta_0 + \beta_1 \beta_{s+1} + \beta_2\beta_{s+2} + \cdots\)</span> 收敛，则 MA(<spanclass="math inline">\(\infty\)</span>) 也是平稳过程。</strong></li></ul></blockquote><p>下面我们为上述结论给出证据。我们的逻辑是：先针对 MA(1)、MA(2)的情况讨论，然后外推。</p><p><span style="background:#fff88f">【MA(1)的平稳性】</span>：<strong>考虑 MA(1)：<span class="math inline">\(x_t =\beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1}\)</span></strong></p><p>为体现一般性，我们考虑未经过【去趋势 <spanclass="math inline">\(\mu=0\)</span> 】和【标准化校准 <spanclass="math inline">\(\beta_0=1\)</span> 】 的 MA(1)。</p><p><span class="math display">\[x_t = \mu + \beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} \notag\]</span></p><p>结合 <a href="#1.2%20平稳性">1.2 平稳性</a>对于时间序列弱平稳的讨论，我们要说明 MA(1) 平稳，就要证明其满足：</p><ol type="1"><li><strong>均值恒定</strong>：<span class="math inline">\(E(x_t) =\mu\)</span>（各时期数学期望恒定）</li><li><strong>方差恒定</strong>：<spanclass="math inline">\(\text{Var}(x_t) =\sigma^2\)</span>（各时期方差恒定）</li><li><strong>协方差仅依赖时间间隔（而不随时间变化）</strong>：<spanclass="math inline">\(\text{Cov}(x_i, x_j) =\gamma_{|i-j|}\)</span>（任意两时期的协方差仅与时间间隔绝对值有关）</li></ol><p><font color="#c00000">（1）均值恒定 </font> 通过对 MA(1)左右两边同时取期望，我们得到： <span class="math inline">\(E(x_t) = \mu+ \beta_0 E(\varepsilon_t)+ \beta_1 E(\varepsilon_{t-1})\)</span> 。回忆<a href="#2.1.1%20白噪声过程">2.1.1 白噪声过程</a>中白噪声的统计特征，<spanclass="math inline">\(E(\varepsilon_t)=E(\varepsilon_{t-1})≡0\)</span>，因此有：<span class="math inline">\(E(x_t) = \mu\)</span> 为常数。</p><p><font color="#c00000">（2）方差恒定 </font>然后，我们考虑方差是否恒定。我们得到：<spanclass="math inline">\(Var(x_t) = \beta_0^2Var(\varepsilon_t) + \beta_1^2Var(\varepsilon_{t-1})\)</span> 。回忆 <ahref="#2.1.1%20白噪声过程">2.1.1 白噪声过程</a> 中白噪声的统计特征 <spanclass="math inline">\(Var(\varepsilon_t)=Var(\varepsilon_{t-1})=\sigma^2\)</span>，因此得到：<span class="math inline">\(Var(x_t) =(\beta_0^2+\beta_1^2)\sigma^2\)</span> 为常数。</p><p><font color="#c00000">（3）协方差不随时间变化 </font><strong>自协方差函数</strong> <span class="math inline">\(\gamma_l =Cov(x_t, x_{t-l}) = Cov(\mu+\beta_0\varepsilon_t+\beta_1\varepsilon_{t-1}, \mu + \beta_0 \varepsilon_{t-l}+ \beta_1\varepsilon_{t-l-1})\)</span></p><ul><li>当 <span class="math inline">\(l=0\)</span>时，实际上就讨论了方差是否恒定：</li></ul><p><span class="math display">\[\gamma_0 = Var(x_t) = \beta_0^2Var(\varepsilon_t) + \beta_1^2Var(\varepsilon_{t-1}) = (\beta_0^2+\beta_1^2)\sigma^2 \quad(\text{存在且为常数})\]</span></p><ul><li>当 <span class="math inline">\(l=1\)</span> 时，由 <ahref="#2.1.1%20白噪声过程">2.1.1 白噪声过程</a>中白噪声的统计特征，<spanclass="math inline">\(Cov(\varepsilon_t,\varepsilon_{t-l})=0\)</span>，有：</li></ul><p><span class="math display">\[\begin{split}\gamma_1 = Cov(x_t, x_{t-1}) &amp;= Cov(\beta_0\varepsilon_t+\beta_1\varepsilon_{t-1}, \beta_0\varepsilon_{t-1}+\beta_1\varepsilon_{t-2}) \\&amp;=\beta_0^2 Cov(\varepsilon_t,\varepsilon_{t-1})+ \beta_0 \beta_1Var(\varepsilon_{t-1})+\beta_0 \beta_1Cov(\varepsilon_t,\varepsilon_{t-2}) + \beta_1^2Cov(\varepsilon_{t-1},\varepsilon_{t-2})\\&amp;= \beta_0 \beta_1 \sigma^2  \quad (\text{存在且为常数})\end{split}\]</span></p><ul><li>当 <span class="math inline">\(l \geq 2\)</span> 时，这时 <spanclass="math inline">\(l &gt; q\)</span>。基于 MA模型的有限历史影响，过去更久的白噪声对当前值没有直接影响，<spanclass="math inline">\(\gamma_l = Cov(x_t, x_{t-l}) = 0 \quad(\text{存在且为常数})\)</span></li></ul><p><span style="background:#fff88f">【MA (2) 的平稳性】</span>：设 MA(2) 过程为：</p><p><span class="math display">\[x_t = \mu + \beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} + \beta_2\varepsilon_{t-2}\]</span></p><p>其中 <span class="math inline">\(\varepsilon_t\)</span>是白噪声过程，满足 <spanclass="math inline">\(E(\varepsilon_t)=0\)</span>, <spanclass="math inline">\(Var(\varepsilon_t)=\sigma^2\)</span>, <spanclass="math inline">\(Cov(\varepsilon_t,\varepsilon_{t-l})=0\)</span>。</p><p><font color="#c00000">（1）均值恒定 </font> 对 MA (2)两边取期望：<span class="math inline">\(E(x_t) = E(\mu) + \beta_0E(\varepsilon_t) + \beta_1 E(\varepsilon_{t-1}) + \beta_2E(\varepsilon_{t-2}) = \mu  \quad (\text{常数})\)</span></p><p><font color="#c00000">（2）方差恒定 </font> 计算方差： <spanclass="math inline">\(Var(x_t) = \beta_0^2 Var(\varepsilon_t) +\beta_1^2 Var(\varepsilon_{t-1}) + \beta_2^2 Var(\varepsilon_{t-2}) =(\beta_0^2 + \beta_1^2 + \beta_2^2)\sigma^2 \quad(\text{常数})\)</span></p><p><font color="#c00000">（3）协方差不随时间变化 </font>考虑自协方差函数，滞后阶数 <span class="math inline">\(l\)</span> ：</p><ul><li><span class="math inline">\(l=0\)</span>时，实际上就讨论了方差是否恒定： <span class="math inline">\(\gamma_0 =Var(x_t) = (\beta_0^2 + \beta_1^2 + \beta_2^2)\sigma^2 \quad(\text{常数})\)</span></li><li><span class="math inline">\(l=1\)</span> 时，由 <ahref="#2.1.1%20白噪声过程">2.1.1 白噪声过程</a>中白噪声的统计特征，<spanclass="math inline">\(Cov(\varepsilon_t,\varepsilon_{t-l})=0\)</span>，有：</li></ul><p><span class="math display">\[\begin{aligned}\gamma_1 &amp;= Cov(x_t, x_{t-1}) = Cov(\beta_0 \varepsilon_t + \beta_1\varepsilon_{t-1} + \beta_2 \varepsilon_{t-2}, \beta_0 \varepsilon_{t-1}+ \beta_1 \varepsilon_{t-2} + \beta_2 \varepsilon_{t-3}) \\&amp;= \beta_0\beta_1 Var(\varepsilon_{t-1}) + \beta_1\beta_2Var(\varepsilon_{t-2}) \\&amp;= (\beta_0\beta_1 + \beta_1\beta_2)\sigma^2 \quad (\text{常数})\end{aligned}\]</span></p><ul><li><span class="math inline">\(l=2\)</span> 时： <spanclass="math inline">\(\gamma_2\)</span> 为常数：</li></ul><p><span class="math display">\[\gamma_2 = Cov(x_t, x_{t-2}) = Cov(\beta_0 \varepsilon_t + \beta_1\varepsilon_{t-1} + \beta_2 \varepsilon_{t-2}, \beta_0 \varepsilon_{t-2}+ \beta_1 \varepsilon_{t-3} + \beta_2 \varepsilon_{t-4}) =\beta_0\beta_2\sigma^2\]</span></p><ul><li><span class="math inline">\(l≥3\)</span> 时，这时 <spanclass="math inline">\(l &gt; q\)</span>。基于 MA模型的有限历史影响，过去更久的白噪声对当前值没有直接影响，<spanclass="math inline">\(\gamma_l = Cov(x_t, x_{t-l}) = 0\)</span>，存在且为常数。</li></ul><blockquote><p>[!Note] 【外推：MA(q) 的平稳性】：<strong><font color="#c00000">【思考】</font> 请借助前面的 MA(1) 和MA(2) 找规律，给出 MA(q) 的均值、方差、协方差。</strong></p><p><strong>MA (q) 模型的平稳性</strong> （有限阶移动平均过程）</p><p><span class="math display">\[x_t = \mu + \sum_{i=0}^q \beta_i \varepsilon_{t-i}\]</span></p><ol type="1"><li>均值：<span class="math inline">\(E(x_t)=\mu\)</span></li><li>方差：<span class="math inline">\(Var(x_t)=\sigma^2 \sum_{i=0}^q\beta_i^2\)</span></li><li>协方差：<span class="math inline">\(Cov(x_t,x_{t-l})=\sigma^2\sum_{i=l}^q \beta_i \beta_{i-l} \quad (l \leq q)\)</span></li></ol><p><strong>平稳性结论</strong> ：由于求和项为有限项，MA (q)过程始终满足均值恒定、方差有限恒定、协方差仅依赖时间间隔，因此<strong>当 <span class="math inline">\(q\)</span> 为有限值时，MA (q)总是平稳的</strong></p></blockquote><p>那么，<strong>当 <span class="math inline">\(q \to\infty\)</span>（无穷阶 MA）</strong> 呢？</p><blockquote><p>[!Tip] <font color="#245bdb">【外推：MA (∞) 的平稳性】</font><strong>无限 MA 过程</strong> （无穷阶移动平均过程）</p><p><span class="math display">\[x_t = \mu +\sum_{i=0}^\infty \beta_i \varepsilon_{t-i}\]</span></p><ol type="1"><li>均值：<span class="math inline">\(E(x_t)=\mu\)</span></li><li>方差：<span class="math inline">\(Var(x_t)=\sigma^2\sum_{i=0}^\infty \beta_i^2\)</span></li><li>协方差：<span class="math inline">\(Cov(x_t,x_{t-l})=\sigma^2\sum_{i=l}^\infty \beta_i \beta_{i-l}\)</span></li></ol><p><strong>平稳性条件</strong>：当且仅当系数平方和与交叉项均收敛时，无限 MA 过程平稳。</p><p><span class="math display">\[\sum_{i=0}^\infty \beta_i^2 &lt; \infty \qquad \sum_{i=l}^\infty \beta_i\beta_{i-l} &lt; \infty\]</span></p><p>通过<strong>柯西不等式</strong>，若系数平方和收敛，则系数交叉项均收敛：</p><p><span class="math display">\[\left| \sum_{i=0}^\infty \beta_i \beta_{i-l} \right| \leq \sqrt{\sum_{i=0}^\infty \beta_i^2 } \cdot \sqrt{ \sum_{i=0}^\infty\beta_{i-l}^2 } &lt; \infty  \]</span></p><p>因此，<strong>仅需系数平方和收敛（即：平方可加）即可保证平稳性</strong>。</p><p>为方便起见，通常使用比平方可加略强的条件：绝对可加（<spanclass="math inline">\(\sum_{i=0}^\infty |\beta_i| &lt;\infty\)</span>）。关于二者的关系，请参考《Time SeriesAnalysis》(Hamilton, 1994) 英文版第 52页。如果使用中国人民大学出版社出版的中文版，这部分内容在第 59-60页。</p></blockquote><p>你可能会疑惑：这里我们的总体思路与课本一致，但为什么结论似乎有所不同。在课本（中文版第45 页）中，任意 MA 过程平稳的充分必要条件除了平方和收敛外，还有当 <spanclass="math inline">\(q \to \infty\)</span>，若对任意 <spanclass="math inline">\(l\)</span> 有 <span class="math inline">\(\beta_0+ \beta_1 \beta_{l+1} + \beta_2 \beta_{l+2} + \cdots +\beta_i\beta_{i+l} + \cdots\)</span> 收敛。事实上，我们把 <spanclass="math inline">\(i\)</span> 视作 <spanclass="math inline">\(i-l\)</span> 即可。</p><h4 id="2123-maq-与-ar-p-的比较">2.1.2.3 MA(q) 与 AR (p) 的比较</h4><p>虽然在形式上，AR（自回归）模型和MA（移动平均）模型看起来很相似，但是他们的关键区别在于他们对过去信息的处理方式。</p><ul><li>对于自回归（AR）模型：当前值是过去值的函数。也就是说，我们是在使用过去的“实际” 观察值来预测现在的值。AR模型的基本思想是过去的观测值会对未来的观测值产生影响，即未来的观测值是过去观测值的加权和。</li><li>对于移动平均（MA）模型：当前值是过去噪声（或称之为误差或冲击）的函数。这里的“白噪声”实际上是模型无法解释的随机部分，是未能被模型捕获的信息。换句话说，MA模型是在试图用过去的 “错误” 或 “冲击”（即预测值 <spanclass="math inline">\(\hat{Y}\)</span> 和真实值 <spanclass="math inline">\(Y\)</span> 之差，也就是残差Residuals）来预测现在的值。</li><li>关于二者的互推问题，请参考 <a href="#1521-ar1的线性特征">1.5.2.1AR(1)的线性特征</a>(#1.5.2.1%20AR(1) 的线性特征) 和 <ahref="#2.3.5.2%20可逆性">2.3.5.2 可逆性</a> 的推导。</li></ul><h2 id="22-自回归移动平均模型arma">2.2 自回归移动平均模型（ARMA）</h2><h3 id="221-wold-分解定理">2.2.1 Wold 分解定理</h3><p><strong>Wold分解定理</strong>：对于任意平稳序列，可以分解成过去序列值的线性组合和纯随机序列。即对于<span class="math inline">\(X_t\)</span>，存在如下分解：</p><p><span class="math display">\[X_t = \sum_{k = 1}^{\infty} a_k X_{t-k} + E_t\]</span></p><p>其中 <span class="math inline">\(E_t\)</span>相互独立且不可预测。结合相关性假设，如果 <spanclass="math inline">\(a_k\)</span> 全为 <spanclass="math inline">\(0\)</span>，那么 <spanclass="math inline">\(X_t\)</span>就不存在相关性，是纯随机序列，那就不用研究了。</p><p>其中 <strong>AR 模型</strong>是把随机部分简化，保留历史序列部分；那么对偶地，<strong>MA 模型</strong>是将历史序列值简化，保留随机部分。</p><h3 id="222-自回归移动平均模型是什么">2.2.2自回归移动平均模型是什么？</h3><h4 id="2221-arma-模型定义">2.2.2.1 ARMA 模型定义</h4><p>将移动平均过程和线性差分方程合并，便可得到自回归移动平均（ARMA）模型。考察p 阶差分方程</p><p><span class="math display">\[y_t = a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + x_t\]</span></p><p>现令 <span class="math inline">\(\{x_t\}\)</span> 表示 MA(q)过程，则有 ARMA 模型：</p><p><span class="math display">\[y_t = a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + \sum_{i = 0}^{q} \beta_i\varepsilon_{t-i} \tag{*}\]</span></p><p>为了方便，我们采用标准化，使 <spanclass="math inline">\(\beta_0\)</span> 恒等于 1。</p><p>如果方程的特征根均在单位圆以内，称为 <spanclass="math inline">\(y_t\)</span> 的<strong>自回归移动平均(AutoregressiveMoving-average，ARMA)模型</strong>。</p><ul><li>ARMA 模型的 <strong>自回归部分</strong>是齐次部分所给出的差分方程，<strong>移动平均部分</strong> 为序列 <spanclass="math inline">\(\{x_t\}\)</span>。</li><li>如果差分方程的齐次部分滞后期为 p，并且 <spanclass="math inline">\(\{x_t\}\)</span> 的滞后期为q，那么，我们把这个模型称为 <strong>ARMA(p，q)</strong> 模型。</li><li>若 q = 0，则把这个过程称为纯自回归过程，用 AR(p)表示；</li><li>若 p = 0，则这个过程被称为纯移动平均过程，用 MA(q)表示。</li><li>在 ARMA 模型中，完全允许 p 和(或)q 取无穷大。</li></ul><p>本章中，我们只考察 <strong>所有特征根都在单位圆内</strong>的情况。然而，如果有一个或多个特征根大于或等于 1，则称序列 <spanclass="math inline">\(\{y_t\}\)</span>为积分（integrated）过程，这时的方程（<spanclass="math inline">\(*\)</span>）称为<strong>自回归求积移动平均(ARIMA)模型</strong> 。</p><h4 id="2222-求解-armap-q">2.2.2.2 求解 ARMA(p, q)</h4><p>把 ARMA 看作差分方程，意味着我们能够解出 <spanclass="math inline">\(y_{t}\)</span>，它是用序列 <spanclass="math inline">\(\{\varepsilon_{t}\}\)</span> 表示的。我们把ARMA(p, q)模型以序列 <spanclass="math inline">\(\{\varepsilon_{t}\}\)</span> 表示的解 <spanclass="math inline">\(y_{t}\)</span> 称为 <spanclass="math inline">\(y_{t}\)</span> 的<strong>移动平均表达式</strong>(moving-averagerepresentation)，这个求解过程与 <a href="#1.4%20差分方程的求解方法">1.4差分方程的求解方法</a> 所讨论的类似。</p><p>对于 AR(1)模型 <spanclass="math inline">\(y_{t}=a_0+a_1y_{t-1}+\varepsilon_{t}\)</span>，正如我们在<a href="#1.4.2.1%20迭代法">1.4.2.1 迭代法</a>讨论的，它的移动平均表达式为 MA(<spanclass="math inline">\(∞\)</span>)：【请回忆，我们曾在 <ahref="#2.1.2%20移动平均模型（MA）">2.1.2 移动平均模型（MA）</a> 中练习过MA(<span class="math inline">\(∞\)</span>) 】</p><p><span class="math display">\[y_{t}=\frac{a_0}{1-a_1}+\sum_{i = 0}^{\infty} a_i^i\varepsilon_{t-i}\]</span></p><p>对于一般的 ARMA(p, q)模型，用滞后算子重写 <spanclass="math inline">\((*)\)</span>，变为</p><p><span class="math display">\[\left( 1-\sum_{i = 1}^{p} a_iL^i\right)y_t = a_0+\sum_{i = 0}^{q}\beta_i\varepsilon_{t-i}\]</span></p><p>所以，<span class="math inline">\(y_{t}\)</span> 的特解为</p><p><span class="math display">\[y_{t}=\frac{a_0+\sum_{i = 0}^{q} \beta_{i} \varepsilon _{t-i}}{1-\sum_{i= 1}^{p} a_{i} L^{i}}\]</span></p><p>幸运的是，我们不必使用待定系数法展开来求得序列 <spanclass="math inline">\(\{\varepsilon_{t}\}\)</span>中每个元素的具体系数。但是我们必须认识到：这一展开式会生成 MA(<spanclass="math inline">\(\infty\)</span>)过程。</p><p>注：如果对本小节涉及的滞后算子计算不熟悉，还请回顾 <ahref="#1.4.5.3%20滞后算子">1.4.5.3滞后算子</a>；如果对其中涉及的特征多项式、特征方程、特征根有疑问，可以回顾<a href="#1.4.4%20高阶齐次解：特征根">1.4.4 高阶齐次解：特征根</a>。</p><h4 id="2223-armap-q-的平稳性">2.2.2.3 ARMA(p, q) 的平稳性</h4><p>在上一节的讨论中，我们认识到：ARMA 模型只有在保持 AR (p) 和 MA (q)都平稳的情况下才会平稳。关于平稳性的内容，还请回顾 <ahref="#1.2%20平稳性">1.2 平稳性</a>、<a href="#1522-ar1的平稳性">1.5.2.2AR(1)的平稳性</a>(#1.5.2.2%20AR(1) 的平稳性)、<ahref="#153-ar2模型">1.5.3 AR(2)模型</a>(#1.5.3%20AR(2) 模型) 和 <ahref="#154-arp模型">1.5.4 AR(p)模型</a>(#1.5.4%20AR(p) 模型)。</p><ul><li>正如我们在 <a href="#154-arp模型">1.5.4 AR(p)模型</a>(#1.5.4%20AR(p)模型) 中看到的，AR (p) 平稳的条件是特征多项式 <spanclass="math inline">\((1-\sum_{i=1}^{p} a_iL^i)\)</span>的根在单位圆之外。（或者说，逆特征方程的根在单位圆之外，or特征根在单位圆内。）</li><li>我们在 <a href="#2122-maq-的平稳性">2.1.2.2 MA(q)的平稳性</a>(#2.1.2.2%20MA(q)%20 的平稳性) 中也曾讨论过，MA(q) 在 <spanclass="math inline">\(q\)</span> 为有限值时一定是平稳过程，在 <spanclass="math inline">\(q \to \infty\)</span>（无穷阶MA）时，若平方可加，也是平稳过程。</li></ul><p>因此，<strong>ARMA过程的平稳性完全取决于自回归参数，而与移动平均参数无关</strong>。ARMA(p, q) 的平稳性取决于 AR(p) 的平稳性，只要特征根在单位圆内，ARMA过程就是平稳的。</p><h2 id="23-时间序列模型的使用">2.3 时间序列模型的使用</h2><h3 id="231-使用时间序列模型的流程">2.3.1 使用时间序列模型的流程</h3><p>现在，我们已经对 ARMA模型有了一定的了解，那么接下来，我们就以比较直观的 GDP 序列来考虑<strong>如何使用时间序列模型</strong>。比如，我们会问：我现在已经获得了2000-2020 年的 GDP 数据，我怎么使用 ARMA 模型预测？</p><p>表面上看，这个问题好像很具体；但事实上，这个问题包含了很多时间序列分析的细节：在使用模型前我应该如何预处理？我应当选取哪种模型？模型应该使用多少期的滞后？如何估计模型的参数？我怎么知道自己预测的效果好不好呢？</p><p>这张时间序列分析流程图给予了我们一些启发。我们可以大致把问题分成下面几部分：</p><ol type="1"><li>时间序列的 <font color="#c00000"> 预处理 </font>。</li><li>选择适当的模型进行识别。这包含两方面：<ul><li>只有数据的我们不知道模型是否适当，因此需要尝试并比较。<ul><li>一方面，模型能否使用？有没有分析的价值？——这涉及第 <ahref="#Chapter%204%20包含趋势的模型">3</a> 章的平稳性检验。</li><li>另一方面，比较的标准是什么？——这就涉及到后面关于预测效果的问题。</li></ul></li><li>对于每一种尝试的模型，都需要 <font color="#c00000"> 定阶</font>（也就是选取滞后期数）。比如，AR(p) 的 p 取多少合适？</li></ul></li><li>模型的 <font color="#c00000"> 参数估计方法 </font>。</li><li>检验、比较各个模型的 <font color="#c00000"> 预测效果</font>。这涉及了模型筛选和预测评价。</li></ol><p><imgsrc="https://files.mdnice.com/user/77043/ed5f84a7-1e98-445c-aeff-8c2c8eb83c83.png"alt="时间序列分析流程" /></p><p>更多内容请参考：<ahref="https://cloud.tencent.com/developer/article/2490062">时间序列预处理</a></p><h3 id="232-时间序列的预处理">2.3.2 时间序列的预处理</h3><p>流程图表明，在模型识别前，我们应当的输入需要是平稳的非白噪声的序列。这就需要我们进行预处理。本节展示预处理的常见方法。</p><ol type="1"><li><p><strong>应对缺失值。</strong>面对缺失数据，我们应当基于前后数据补全，一种比较常见的方法是线性插值（linearinterpolation）。公式是：假设 <spanclass="math inline">\(i&lt;j\)</span>，<span class="math inline">\(t ∈(t_i,t_j)\)</span> ，则 <span class="math inline">\(y = y_i + \dfrac{t -t_i}{t_j - t_i} \cdot (y_j -y_i)\)</span>。插值过程中也可以使用更复杂的方法进行拟合。</p></li><li><p><strong>处理时序数据噪声</strong>。有时候，我们需要去除短时间内的数据扰动（short-termfluctuations）。一个办法是装箱（Binning），将时间序列按照一定间隔分组（如间隔𝑘），使用均值代替原始的 𝑘 个值。</p></li><li><p><strong>时间序列的归一化、标准化</strong>。</p><ul><li>这涉及时序数据在尺度（scale）上的变化，以及时序数据的平移（translation）变化。</li><li>我们的目标是：对于任意尺度常数 <spanclass="math inline">\(a\)</span> 和平移常数 <spanclass="math inline">\(b\)</span>，时间序列的线性变换 <spanclass="math inline">\(ax+b\)</span> 不影响其相似度的计算。</li><li><font color="#c00000"> 归一化 </font>（Normalization）：将时序数据取值限制在 <span class="math inline">\([0,1]\)</span>区间内。归一化的公式是： <span class="math display">\[y_t^{\prime} =\dfrac{y_t - y_{\text{min}}}{y_{\text{max}} -y_{\text{min}}}\]</span></li><li><font color="#c00000"> 标准化</font>（Standardization）：将时序数据的分布变换为均值为 0、标准差为 1的形式。标准化的公式是： <span class="math display">\[z_t = \dfrac{y_t -\mu}{\sigma}\]</span></li><li><font color="#c00000"> 平均归一化 </font>（MeanNormalization）：<span class="math inline">\(y_t^{\prime} = \dfrac{y_t -\mu}{y_{\text{max}} - y_{\text{min}}}\)</span></li></ul></li><li><p>其他的时间序列预处理方法：</p><ul><li><strong>时间序列的分解</strong>：季节项 <spanclass="math inline">\(S_t\)</span> 刻画时间序列的周期性变换，趋势项<span class="math inline">\(T_t\)</span>刻画序列的整体变化趋势；剩余项记为 <spanclass="math inline">\(R_t\)</span>。<ul><li>相加分解（additive decomposition） <span class="math inline">\(y_t=S_t + T_t + R_t\)</span></li><li>相乘分解（multiplicative decomposition） <spanclass="math inline">\(y_t= S_t × T_t × R_t\)</span></li></ul></li><li><strong>对数变换</strong>：针对变化程度建模，使高偏度的分布变得不那么偏斜。</li><li><strong>Box-Cox变换</strong>：用于分布“正态”程度的矫正（针对取值非负的序列）。</li><li><strong>Tukey Ladder ofPowers</strong>：用于将有偏的分布“矫正”，趋向于正态分布（辅助概率化建模）</li></ul></li></ol><h3 id="233-box-jenkins-模型筛选定阶">2.3.3 Box-Jenkins模型筛选：定阶</h3><p>在完成预处理后，一个重要的步骤是 <b> <font color="#c22b24">平稳性检验 </font> </b>。与我们在 <ahref="#2223-armap-q-的平稳性">2.2.2.3 ARMA(p, q)的平稳性</a>(#2.2.2.3%20ARMA(p,%20q)%20 的平稳性) 中的分析一致，若 <spanclass="math inline">\(a_1\)</span> 的估计值接近 1，则应该怀疑 AR (1)模型的可靠性；而对于 ARMA(2, q)模型，特征多项式的根应在单位圆之外。对于非平稳性序列，也有大量文献提出检验方法，因此，序列平稳性检验的讨论将被放在第<a href="#Chapter%204">3</a>章进行。而目前，我们就先假设都使用平稳数据。</p><p>在检验数据平稳性之后，下一步要做的就是 <strong>建模</strong>了。我们接下来介绍一种普及的、用于估计和预测单个时间序列的宏观步骤——<strong>Box-Jenkins 模型筛选方法</strong>。</p><p>Box-Jenkins 方法是美国学者 Box 和英国学者 Jenkins 于 20 世纪 70年代提出的关于时间序列、预测及控制的一整套方法，也称作传统的时间序列建模方法。它将时间序列建模分为三个阶段：识别阶段(identifcation stage)、估计阶段 (estimation stage) 和诊断检验阶段(diagnostic checking)。</p><ul><li>在 <font color="#c22b24"> 识别阶段</font>，研究者实际上是检査时间序列的 <font color="#245bdb"> 散点图</font>、<font color="#245bdb"> 自相关函数</font>、<font color="#245bdb"> 偏自相关函数</font>，从而初步为模型定阶。</li><li>在 <font color="#c22b24"> 估计阶段</font>，需要对每个试验模型进行拟合，并且对多个 <spanclass="math inline">\(\alpha\)</span> 和 <spanclass="math inline">\(\beta\)</span>系数进行检验。选择一个能较好拟合的并且固定简约的模型是这一阶段的目标。</li><li>在 <font color="#c22b24"> 诊断检验阶段</font>，我们要检验确保估计模型的残差能够模拟白噪声过程。</li></ul><p>我们首先来看第一阶段，也就是为模型初步<strong>定阶</strong>。自然地，我们会问：什么是“定阶”？很容易理解，“定阶” 就是确定阶数。关于模型的阶数，我们在 <ahref="#154-arp模型">1.5.4 AR(p)模型</a>(#1.5.4%20AR(p) 模型) 和 <ahref="#2.1.2.1%20移动平均模型是什么？">2.1.2.1 移动平均模型是什么？</a>中都有所提及。对于 AR(p) 模型，求解阶 p 的问题叫作 AR 模型的定阶；对于MA (q) 模型，求解阶 q 的问题就叫作 MA 模型的定阶。</p><p>定阶的常用方法有两种：<strong>偏自相关函数（PACF）</strong> 和<strong>信息准则</strong> 。我们接下来逐一介绍它们。</p><h4 id="2331-自相关函数acf">2.3.3.1 自相关函数（ACF）</h4><p>在介绍偏自相关函数（PACF）之前，我们先来认识自相关函数（ACF）。</p><p>让我们仔细关注一下 “自相关函数”这个新术语。似乎不用过多解释，看上去好像就有点理解了。但这很可能是我们的错觉：我们自然而然地联想到的是<strong>自相关系数</strong>，而不是 <strong>自相关函数</strong>。</p><blockquote><p>[!NOTE] 回顾：关于自相关系数</p><p>在我们初识数理统计的时候，我们最先接触的是单变量的均值（衡量集中趋势）和方差（衡量离散程度），它们分别是一阶原点矩和二阶中心矩。矩是一种数学计算方式，矩的数学本质是期望，一个变量的K 阶矩就是这个变量的 K次方的均值。在此基础之上，可以扩展出原点矩，中心矩，绝对矩等。三阶中心距（偏度）衡量对称程度，四阶中心距（峰度）衡量尾部厚度。</p><p>当我们在考虑两个变量的关系时，我们常常考虑的是<strong>协方差</strong>。协方差是两个变量的二阶混合中心矩，测量两个变量之间的同步性，公式为：<span class="math inline">\(\operatorname{cov}(X,Y)=E\left[\left(X-\mu_{x}\right)\left(Y-\mu_{y}\right)\right]=E(XY)-\mu_{x}\mu_{y}\)</span>。可以发现，协方差的大小与两个变量的大小有关。为了无量纲化，我们对其进行标准化处理：由于协方差公式中已经隐含了减去均值的操作，只需要除以两个变量各自的标准差，就得到了<strong>相关系数</strong>。相关系数具有尺度不变性，能准确度量两个变量之间线性关系的强度。</p><p>在时间序列分析中，我们关心同一变量在不同时点之间的相关性，我们将不同时点的同一变量视为两个变量，计算出的相关系数就是自相关系数。自相关系数反映了序列内部的依赖关系，假设时间序列为<span class="math inline">\(\{Y_t\}\)</span>，滞后 <spanclass="math inline">\(l\)</span> 期的自相关系数 <spanclass="math inline">\(\rho_l\)</span> 定义为：</p><p><span class="math display">\[\rho_l = \dfrac{\text{Cov}(Y_t, Y_{t-l})}{\sqrt{\text{Var}(Y_t) \cdot\text{Var}(Y_{t-l})}}\]</span></p><p>如果时间序列是平稳的（方差不变），公式可简化为：</p><p><span class="math display">\[\rho_l = \frac{\text{Cov}(Y_t, Y_{t-l})}{\text{Var}(Y_t)}\]</span></p><p>由于平稳性检验的方法丰富，教材专门开辟了一个章节（第 <ahref="#Chapter%204%20包含趋势的模型">3</a>章）来分析。我们简要剧透一下：平稳的时间序列和单位根非平稳时间序列是值得研究的，而其他不平稳时间序列不常见也不值得研究。在这里，我们只讨论平稳的时间序列。</p></blockquote><p>那么，什么是自相关函数呢？自相关函数与自相关系数又是什么关系呢？</p><p><strong>自相关函数（ACF）的定义：</strong> 自相关函数描述了 <b><font color="#245bdb"> 时间序列在不同滞后期数（Lag）下的相关性 </font></b>，即序列与其自身滞后值之间的线性相关程度。它衡量了当前值与过去值之间的关系。</p><p>定义表明，自相关函数体现的是自相关系数 <spanclass="math inline">\(\rho\)</span> 和滞后期数 <spanclass="math inline">\(l\)</span>之间的对应关系。就像微观经济学中需求函数对应需求曲线一样，自相关函数对应的是<strong>自相关图</strong>(correlogram）。若序列平稳，自相关函数（或自相关图）应在几何意义上收敛于0。很容易理解，序列平稳本身就意味着伴随时间推移趋于收敛，距离时间越久，相关性也相应越低，最后会趋于无影响。</p><p><imgsrc="https://files.mdnice.com/user/77043/c14bc3b3-e948-4eba-b352-1abbc2c08b82.png"alt="AR(1)模型 ACF 图" /></p><p>为了进一步加深理解，我们接下来考察 AR (1) 过程的自相关函数。</p><blockquote><p>[!tip] AR (1) 过程的自相关函数 （ACF）</p><p>AR(1) 模型：<span class="math inline">\(y_t = a_0 + a_1 y_{t-1} +\varepsilon_t\)</span></p><p>当其满足平稳的必要条件 <spanclass="math inline">\(|a_1|&lt;1\)</span>时（所以说，自相关系数是在平稳条件下求得的）：</p><ul><li><span class="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-l}\)</span> 的方差是有限常数，</li></ul><p><span class="math display">\[\gamma_0 = Var(y_t) = a_1^2 Var(y_{t-l}) + \sigma^2 =\dfrac{\sigma^2}{1-a_1^2}\]</span></p><ul><li><span class="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-l}\)</span> 的协方差记为 <spanclass="math inline">\(\gamma_l\)</span>。我们在 <ahref="#1522-ar1的平稳性">1.5.2.2 AR(1)的平稳性</a>(#1.5.2.2%20AR(1)的平稳性)中曾推导过。如果认为双重求和转化为单重求和太复杂，下面还提供了另一种递推的方法。</li></ul><p><span class="math display">\[\gamma_1 = Cov(y_t,y_{t-1}) = Cov(a_1 y_{t-1} + \varepsilon_t, y_{t-1})= a_1 Cov(y_{t-1},y_{t-1}) + Cov(\varepsilon_t, y_{t-1})=a_1 \gamma_0\]</span></p><p>推导的过程中一定要注意，<spanclass="math inline">\(Cov(y_{t-1},y_{t-1})=Var(y_{t-1}) = \gamma_0 \neq\sigma^2\)</span> ， <spanclass="math inline">\(Var(\varepsilon)\)</span> 才等于 <spanclass="math inline">\(\sigma^2\)</span></p><p>基于 AR(1) 模型，我们可以递推得到 <span class="math inline">\(y_{t-1}= a_0 + a_1 y_{t-2} + \varepsilon_{t-1}\)</span>，得：</p><p><span class="math display">\[\gamma_2 = Cov(y_t,y_{t-2}) = Cov(a_1 y_{t-1}, y_{t-2}) = a_1Cov(y_{t-1},y_{t-2})= a_1 Cov(a_1 y_{t-2},y_{t-2}) =a_1^2 \gamma_0\]</span></p><p>继续递推，得到：</p><p><span class="math display">\[\begin{split}\gamma_l = Cov(y_t, y_{t-l}) &amp; = a_1 Cov(y_{t-1},y_{t-l})= a_1^2 Cov(y_{t-2}, y_{t-l})= \cdots = a_1^l Cov(y_{t-l},y_{t-l}) \\&amp;= a_1^l \gamma_0 = \dfrac{a_1^l \sigma^2}{1-a_1^2}\end{split}\]</span></p><p>由 <span class="math inline">\(\rho_l = \dfrac{\text{Cov}(Y_t,Y_{t-l})}{\text{Var}(Y_t)}\)</span> ，ACF 有： <spanclass="math inline">\(\rho_0 = 1, \quad \rho_1 = a_1, \quad \rho_2 =a_1^2, \quad \cdots, \quad \rho_l = a_1^l\)</span></p><p>由于 <span class="math inline">\(\{\rho_i\}\)</span> 的平稳条件为<span class="math inline">\(|a_1| &lt;1\)</span> ，所以 <spanclass="math inline">\(0&lt;a_1&lt;1\)</span> 则自相关系数直接收敛到0，<span class="math inline">\(-1&lt;a_1&lt;0\)</span>则自相关系数震荡收敛到 0。</p></blockquote><h4 id="2332-偏自相关函数-pacf">2.3.3.2 偏自相关函数 （PACF）</h4><p>你可能发现了，在刚刚的推导中，尽管 <spanclass="math inline">\(y_{t-2}\)</span> 没有直接出现在 AR (1)模型中，但是 <span class="math inline">\(y_{t-2}\)</span> 也是与 <spanclass="math inline">\(y_t\)</span> 相关的。根据我们的推导， <spanclass="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-2}\)</span> 的自相关系数 <spanclass="math inline">\(\rho_2\)</span> 等于 <spanclass="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-1}\)</span> 的自相关系数 <spanclass="math inline">\(\rho_1\)</span> 乘以 <spanclass="math inline">\(y_{t-1}\)</span> 和 <spanclass="math inline">\(y_{t-2}\)</span> 的自相关系数（仍为 <spanclass="math inline">\(\rho_1\)</span>），所以 <spanclass="math inline">\(\rho_2=(\rho_1)^2\)</span>。这并不是偶然，事实上，这样的间接相关出现在任何自回归过程的ACF 中。</p><p><strong>在定阶问题中，这样的间接相关非常重要</strong>。比如，我们考虑一个简单的定阶问题，我们意图在AR(1) 模型和 AR (2)模型中选一个来分析我们的时间序列。换言之，我们在纠结的是，要不要在我们的模型中加入<span class="math inline">\(y_{t-2}\)</span> 这个滞后项。这时，<strong><span class="math inline">\(y_{t-2}\)</span>的估计系数可以被视为在 AR(1) 模型上添加 <spanclass="math inline">\(y_{t-2}\)</span> 对的 <spanclass="math inline">\(y_t\)</span>的贡献</strong>，因此是我们做出决策的一个重要参考。</p><p>自然地，我们会问： <span class="math inline">\(y_{t-2}\)</span>的估计系数是 <span class="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-2}\)</span> 的自相关系数 <spanclass="math inline">\(\rho_2\)</span> 吗？答案是否定的。因为我们没有剔除<span class="math inline">\(y_{t-1}\)</span>的影响。就类似于我们在多元线性回归模型中加入控制变量的思想一样，我们想要得到的是“<strong>在控制 <span class="math inline">\(y_{t-1}\)</span>保持不变的情况下， <span class="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-2}\)</span> 的自相关系数</strong>”。这就是<b> <font color="#245bdb"> 偏自相关系数 </font></b>。对应的，偏自相关系数 <span class="math inline">\(\phi\)</span>和滞后期 <span class="math inline">\(l\)</span> 的对应关系就是 <b><font color="#245bdb"> 偏自相关函数 （PACF）</font> </b>。</p><p>下面，我们给出偏自相关函数的正式定义：</p><blockquote><p>[!NOTE] 偏自相关函数（PACF）的定义 偏自相关函数（PartialAutocorrelation Function，PACF）用于度量时间序列中当前值 <spanclass="math inline">\(Y_t\)</span> 与滞后 <spanclass="math inline">\(k\)</span> 期的值 <spanclass="math inline">\(Y_{t-k}\)</span>之间的纯粹相关性，排除了介于两者之间的所有中间滞后项（<spanclass="math inline">\(Y_{t-1}, Y_{t-2}, \ldots,Y_{t-k+1}\)</span>）的干扰。</p></blockquote><p><strong>偏自相关函数和自相关函数的关系</strong>：偏自相关函数和自相关函数的关系就类似于偏导数和全导数的关系。<b><font color="#245bdb">偏自相关函数是在排除了其他变量的影响之后，两个变量之间的自相关函数。</font></b></p><blockquote><p>[!Tip] <font color="#245bdb"> 类比：</font> 偏导数在数学中，一个多变量的函数的偏导数，就是<strong>它关于其中一个变量的导数而保持其他变量恒定</strong>（相对于全导数，在其中所有变量都允许变化）。</p></blockquote><p>现在，我们已经认识了偏自相关函数。那么，<strong>请思考：在 AR (1)过程中，<span class="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-2}\)</span> 间的偏自相关系数是多少？</strong>答案是：偏自相关系数为 0。怎么得到的？这就涉及了 <b><font color="#245bdb"> 偏自相关系数的求解 </font> </b>。</p><p>求偏自相关系数最直接的方法如下：</p><ol type="1"><li>首先，对每一观察值减去序列的均值 <spanclass="math inline">\(\mu\)</span>，得到 <spanclass="math inline">\(y_i^* =y_i-\mu\)</span>，形成新的序列 <spanclass="math inline">\({y_i^*}\)</span>，</li><li>接着，构造 1 阶自回归方程</li></ol><p><span class="math display">\[y_{i}^{*}=\phi_{11}y_{i-1}^{*}+e_{i}\]</span></p><p>式中，<span class="math inline">\(e_i\)</span>为误差项。这里之所以采用符号 <span class="math inline">\({ e_i}\)</span>，是因为误差项 <span class="math inline">\(e_i\)</span>不一定是白噪声过程（因为 <span class="math inline">\(e_i\)</span>含有均值 <spanclass="math inline">\(\mu\)</span>）。<strong>因为没有插入值，则 <spanclass="math inline">\(\phi_{11}\)</span> 就同时为 <spanclass="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-1}\)</span>的自相关和偏自相关系数。</strong></p><ol start="3" type="1"><li>现在构造 2 阶自回归方程：</li></ol><p><span class="math display">\[y_t^* = \phi_{21}y_{t-1}^* + \phi_{22}y_{t-2}^* + e_t\]</span></p><p>式中，<span class="math inline">\(\phi_{22}\)</span> 是 <spanclass="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-2}\)</span>的偏自相关系数。换言之，<strong><spanclass="math inline">\(\phi_{22}\)</span> 是 <spanclass="math inline">\(y_t\)</span> 与 <spanclass="math inline">\(y_{t-2}\)</span> 的剔除 <spanclass="math inline">\(y_{t-1}\)</span>干扰影响后的相关系数。</strong></p><ol start="4" type="1"><li>对其他的所有滞后期 <spanclass="math inline">\(s\)</span>，可重复这个过程，进而生成偏自相关函数(PACF)。实践中，如果样本容量为<span class="math inline">\(T\)</span>，那么仅有 <spanclass="math inline">\(\dfrac{T}{4}\)</span> 的滞后项可以用来计算样本PACF。</li></ol><h4 id="2333-常见模型的-acf-与-pacf">2.3.3.3 常见模型的 ACF 与 PACF</h4><p>在前面两节中，我们已经借助 AR (1) 模型认识了自相关函数 ACF与偏自相关函数 PACF。我们也得到，<strong>AR(1) 模型的 ACF 是 <spanclass="math inline">\(\rho_0 = 1, \quad \rho_1 = a_1, \quad \rho_2 =a_1^2, \quad \cdots, \quad \rho_l = a_1^l\)</span>、PACF 是 0。</strong>现在，我们来看看其他常用模型的自相关函数 ACF 与偏自相关函数 PACF。</p><p><b><span style="background:#fff88f">【AR(2) 模型的自相关函数】</span></b> 我们从更复杂的 AR (2) 过程开始。AR (2) 过程的模型是：<spanclass="math display">\[y_t = a_1 y_{t-1} + a_2 y_{t-2} +\varepsilon_t\]</span> 由于截距项 <spanclass="math inline">\(a_0\)</span> 对 ACF 没有影响，所以在此省略。</p><p>要使 AR (2) 过程平稳，必须限制特征多项式 <spanclass="math inline">\(1 - a_1 L - a_2 L^2\)</span>的根在单位圆外。接下来，我们 <b> <font color="#245bdb"> 使用 Yule-Walker方程来推导自协方差、自相关系数 </font> </b>。</p><ol type="1"><li>协方差函数</li></ol><p><span class="math display">\[\gamma_l = Cov(y_t, y_{t-l})= a_1 Cov(y_{t-1}, y_{t-l}) + a_2Cov(y_{t-2}, y_{t-l}) + Cov(\varepsilon_t,y_{t-l})\]</span></p><ol start="2" type="1"><li>由于 <span class="math inline">\(\varepsilon_t\)</span> 与过去的<span class="math inline">\(y_{t-1}, y_{t-2}\)</span> 独立，即当 <spanclass="math inline">\(l&gt;0\)</span>， <spanclass="math inline">\(E(\varepsilon_t y_{t-l}) = 0\)</span>。当 <spanclass="math inline">\(l=0\)</span>，有</li></ol><p><span class="math display">\[Cov(\varepsilon_t,y_t) = a_1 Cov(\varepsilon_t,y_{t-1}) + a_2Cov(\varepsilon_t,y_{t-2})+Var(\varepsilon_t) = 0+0+\sigma^2=\sigma^2\]</span></p><p>因此，<span class="math inline">\(l=0\)</span> 是特殊的，此时 <spanclass="math inline">\(\gamma_0 = Var (y_t)\)</span> ，包含 <spanclass="math inline">\(\sigma^2\)</span> 项；其他情况不包含 <spanclass="math inline">\(\sigma^2\)</span> 项。 3. 我们先考虑 <spanclass="math inline">\(l=0\)</span> 的特殊情况：代入 <spanclass="math inline">\(l=0\)</span>，</p><p><span class="math display">\[\gamma_0 = Var (y_t) =a_1 Cov(y_{t-1},y_t)+ a_2Cov(y_{t-2},y_t)+\sigma^2\]</span></p><p>由平稳性，无论时间点 <span class="math inline">\(t\)</span> ，间隔为<span class="math inline">\(l\)</span> 的自协方差均为 <spanclass="math inline">\(\gamma_l\)</span>。因此，上式可以表示成：</p><p><span class="math display">\[\gamma_0 = a_1 \gamma_1+ a_2 \gamma_2 +\sigma^2\]</span></p><p>对应地，自相关系数 <spanclass="math inline">\(\rho_0=\dfrac{\gamma_0}{\gamma_0}=1\)</span> 4.然后我们考虑 <span class="math inline">\(l=1\)</span>的情况，代入协方差函数：</p><p><span class="math display">\[\gamma_1 = Cov (y_t, y_{t-1})= a_1 Cov (y_{t-1}, y_{t-1}) + a_2 Cov(y_{t-2}, y_{t-1}) + Cov (\varepsilon_t, y_{t-1})\]</span></p><pre><code class="hljs">- 由于 $\varepsilon_t$ 与过去的 $y_&#123;t-1&#125;, y_&#123;t-2&#125;$ 独立，有 $Cov (\varepsilon_t, y_&#123;t-1&#125;) = 0$；- $Cov (y_&#123;t-1&#125;, y_&#123;t-1&#125;)=Var (y_&#123;t-1&#125;)=\gamma_0$；- 由平稳性，无论时间点 $t$ ，间隔为 $l$ 的自协方差均为 $\gamma_l$。因此 $Cov (y_&#123;t-2&#125;, y_&#123;t-1&#125;)=\gamma_1$。- 因此：&lt;font color=&quot;#245bdb&quot;&gt; 自协方差 &lt;/font&gt; $\gamma_1=a_1 \gamma_0 +a_2 \gamma_1$ ，解出 $\gamma_1=\dfrac&#123;a_1&#125;&#123;1-a_2&#125;\gamma_0$ 。- &lt;font color=&quot;#245bdb&quot;&gt; 自相关系数 &lt;/font&gt; $\rho_1=\dfrac&#123;\gamma_1&#125;&#123;\gamma_0&#125;=\dfrac&#123;a_1&#125;&#123;1-a_2&#125;$</code></pre><ol start="5" type="1"><li>请自行完成 <span class="math inline">\(l=2\)</span>情况的推导。我们最终得到，<spanclass="math inline">\(\rho_2=\dfrac{\gamma_2}{\gamma_0}=\dfrac{a_1^2}{1-a_2}+a_2\)</span></li><li><strong>【一般化】</strong>：由平稳性，无论时间点 <spanclass="math inline">\(t\)</span> ，间隔为 <spanclass="math inline">\(l\)</span> 的自协方差均为 <spanclass="math inline">\(\gamma_l\)</span>。我们现在考虑一般化的协方差函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tx">[**一般化的协方差函数：对应**]<br>| $Cov (y_t, y_&#123;t-l&#125;)$ | $=a_1\cdot$ | $Cov (y_&#123;t-1&#125;, y_&#123;t-l&#125;)$ | $+a_2 \cdot$ | $Cov (y_&#123;t-2&#125;, y_&#123;t-l&#125;)$ | $+ Cov(\varepsilon_t,y_&#123;t-l&#125;)$ |<br>| :------------------: | :---------: | :----------------------: | :----------: | :----------------------: | :----------------------------: |<br>|      $\gamma_l$      | $=a_1\cdot$ |      $\gamma_&#123;l-1&#125;$      | $+a_2 \cdot$ |      $\gamma_&#123;l-2&#125;$      |              $+0$              |<br></code></pre></td></tr></table></figure><p>由此，得到自协方差：<span class="math inline">\(\gamma_l=a_1\gamma_{l-1} +a_2 \gamma_{l-2}\)</span>，自相关系数：<spanclass="math inline">\(\rho_l=\dfrac{\gamma_l}{\gamma_0}=a_1\rho_{l-1}+a_2 \rho_{l-2}\)</span>。</p><p><b><span style="background:#fff88f">【AR (2) 模型的偏自相关函数】</span></b></p><ul><li>对 AR (2) 模型，序列依赖仅存在于 <spanclass="math inline">\(y_{t-1}\)</span> 和 <spanclass="math inline">\(y_{t-2}\)</span>，当分析 <spanclass="math inline">\(k &gt; 2\)</span> 的滞后项时，<spanclass="math inline">\(y_t\)</span> 与 <spanclass="math inline">\(y_{t-k}\)</span> 的直接相关性被模型结构截断，因此<span class="math inline">\(\phi_{k, k} = 0\)</span>。</li><li>而 <span class="math inline">\(k=2\)</span> 时，模型中直接包含 <spanclass="math inline">\(y_{t-2}\)</span> 的系数 <spanclass="math inline">\(a_2\)</span>，即 <spanclass="math inline">\(\phi_{2,2} = a_2\)</span>。</li><li>由 <spanclass="math inline">\(\rho_1=\dfrac{\gamma_1}{\gamma_0}=\dfrac{a_1}{1-a_2}\)</span>，得到<span class="math inline">\(a_1=\rho_1 (1-a_2)\)</span>；代入 <spanclass="math inline">\(\rho_2=\dfrac{\gamma_2}{\gamma_0}=\dfrac{a_1^2}{1-a_2}+a_2\)</span>，得到<span class="math inline">\(\rho_2=\rho_1^2-a_2\rho_1^2+a_2\)</span>，从而 <spanclass="math inline">\(\phi_{2,2} = a_2=\dfrac{\rho_2 - \rho_1^2}{1 -\rho_1^2}\)</span>。</li></ul><p>对应地，AR (2) 自相关函数如左图，偏自相关函数如右图。 <imgsrc="https://files.mdnice.com/user/77043/755cfa11-f6e4-4639-9fcf-c624a65063bb.png"alt="AR(2)的 ACF 和 PACF" /></p><p><b><span style="background:#fff88f">【进一步推广：AR (p)模型】</span></b></p><blockquote><p>[!Note] 思考：AR (p)模型的自相关函数 ACF 与偏自相关函数 PACF ？</p><p><span class="math display">\[\begin{split}y_t &amp;= a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \cdots + a_p y_{t-p} +\varepsilon_t \\&amp;= a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + \varepsilon_t \notag\end{split}\]</span></p></blockquote><blockquote><p>[!Tip] 【补充】Yule-Walker 方程的定义 所以，到底什么是 Yule-Walker方程？Yule-Walker 方程是 AR 模型的正则方程。</p><p><strong>定理 （Yule-Walker 方程）</strong> AR(p)序列的自协方差函数满足</p><p><span class="math display">\[\begin{align*}\gamma_k &amp;= a_1 \gamma_{k-1} + a_2 \gamma_{k-2} + \cdots + a_p\gamma_{k-p},\quad \ k \geq 1  \\\gamma_0 &amp;= a_1 \gamma_1 + a_2 \gamma_2 + \cdots + a_p \gamma_p +\sigma^2 \end{align*}\]</span></p><p>Yule-Walker 方程系统地刻画了 AR (p) 模型中 p 阶范围内<strong>自相关系数之间的关系</strong>，以及自相关系数与模型结构的关系。</p></blockquote><p>对于 AR(p) 模型，偏自相关系数满足 <spanclass="math inline">\(\phi_{11} = \rho_1\)</span>，<spanclass="math inline">\(\phi_{22} = \dfrac{\rho_2 - \rho_1^2}{1 -\rho_1^2}\)</span>，向后递推：</p><p><span class="math display">\[\phi_{ss} = \frac{\rho_{s} - \sum_{j = 1}^{s-1} \phi_{s-1,j}\rho_{s-j}}{1 - \sum_{j = 1}^{s-1} \phi_{s-1, j}\rho_{j}} \quad s =3,4,5,\cdots\]</span></p><p>式中，<span class="math inline">\(\phi_{sj} = \phi_{s-1,j} -\phi_{ss}\phi_{s-1,s-j}, j = 1, 2, 3, \cdots, s-1\)</span>。</p><p>对于 AR (p) 过程，当 s &gt; p 时，<spanclass="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(y_{t-s}\)</span>之间不存在直接相关。因此，<strong>当 s &gt; p 时，所有 <spanclass="math inline">\(\phi_{ss}\)</span> 都等于 0</strong>。这表明：<b><font color="#245bdb"> 对于 AR (p) 过程，它的 PACF 在滞后期大于 p时，均应该截尾为 0 </font> </b> 。这是 PACF一个重要的特征，它可用于辅助识别 AR (p) 模型。 **<center> <b>AR(p)模型偏自相关函数是 p 步截尾的。我们可以以此来确定 AR(p)模型的阶数p。</b> </center></p><p><b><span style="background:#fff88f">【MA 模型】 </span></b></p><ol type="1"><li><strong>MA(1)模型的 ACF：</strong><ul><li>依旧省略常数项，MA (1)模型为：<span class="math inline">\(y_{t} =\varepsilon_{t} + \beta \varepsilon_{t-1}\)</span></li><li>由于 <span class="math inline">\(y_{t}\)</span>是由白噪声序列中的项组成，所以不需平稳条件就可求得 <spanclass="math inline">\(\rho\)</span> 的形式如下：<ul><li><span class="math inline">\(\rho_{0} = 1\)</span></li><li><span class="math inline">\(\rho_{1} = \beta / (1 +\beta^{2})\)</span></li><li><span class="math inline">\(\rho_{s} = 0, (s &gt; 1)\)</span></li></ul></li><li>因此，MA(1) 的 ACF 是 1 步截尾。</li></ul></li></ol><blockquote><p>[!Note] 思考：如何推导？ <spanclass="math inline">\(\gamma_0=Cov(y_t,y_t)=Var(\varepsilon_{t} + \beta\varepsilon_{t-1})=(1+\beta^2)\cdot \sigma^2\)</span> <spanclass="math inline">\(\quad \Rightarrow \quad\rho_0=\dfrac{\gamma_0}{\gamma_0}=1\)</span></p><p><spanclass="math inline">\(\gamma_1=Cov(y_t,y_{t-1})=Cov(\varepsilon_{t} +\beta \varepsilon_{t-1},\varepsilon_{t-1} + \beta \varepsilon_{t-2})=0+\beta \sigma^2+0+0=\beta \sigma^2\)</span></p><p><span class="math inline">\(\quad \Rightarrow \quad\rho_1=\dfrac{\gamma_1}{\gamma_0}=\dfrac{\beta\sigma^2}{(1+\beta^2)\cdot \sigma^2}=\dfrac{\beta }{1 +\beta^{2}}\)</span></p><p>当 s &gt; 1， <spanclass="math inline">\(\gamma_s=Cov(y_t,y_{t-s})=Cov(\varepsilon_{t} +\beta \varepsilon_{t-1},\varepsilon_{t-s} + \beta \varepsilon_{t-1-s})=0+0+0+0=0\)</span></p></blockquote><ol start="2" type="1"><li><p><strong>MA(2)模型的 ACF：</strong> 请回顾 <ahref="#2122-maq-的平稳性">2.1.2.2 MA(q) 的平稳性</a>(#2.1.2.2%20MA(q)%20的平稳性) 对 MA(2) 自协方差的推导，讨论在不同滞后期下的 <spanclass="math inline">\(\rho\)</span> 分布。我们可以发现，MA (2) 的 ACF 是2 步截尾。</p></li><li><p><strong>MA(q)模型的 ACF：</strong> MA (q) 模型为： <spanclass="math display">\[x_t = \beta_0 \varepsilon_t + \beta_1\varepsilon_{t-1} + \cdots +\beta_q \varepsilon_{t-q} = \sum_{i = 0}^{q}\beta_i \varepsilon_{t-i} \notag\]</span>同样地，我们也可以讨论在不同滞后期下的 <spanclass="math inline">\(\rho\)</span> 分布。我们可以从 MA(1) 和 MA(2)过程外推得到：对于 MA (q) 模型， <spanclass="math inline">\(\rho_{q+1}\)</span> 开始之后都为 0。即：<b><font color="#245bdb"> q 阶之后突然截断变为 0 </font> </b>。</p></li><li><p><strong>MA (q) 模型的 PACF：</strong>使用滞后算子，结合级数展开，只要 <span class="math inline">\(\beta \neq-1\)</span>，MA(1)模型可以写为：</p></li></ol><p><span class="math display">\[y_t= (1 + \beta L) \varepsilon_t\]</span></p><pre><code class="hljs">- 可以把 $\varepsilon_t$ 表述为无限阶自回归表达式 $y_t - \beta y_&#123;t-1&#125; + \beta^2 y_&#123;t-2&#125; - \beta^3 y_&#123;t-3&#125; + \cdots = \varepsilon_t$。- 由于 $y_t$ 同自身的所有滞后项相关，所以， **MA (q) 模型的 PACF 不会截尾到 0**。- 相反，**PACF 系数表现出衰减形式（即具有拖尾特征）**。若 $\beta &lt; 0$，PACF 的系数直接衰减；若 $\beta &gt; 0$，PACF 的系数振荡衰减。</code></pre><p><b><span style="background:#fff88f">【ARMA 模型的 ACF 推导】</span></b> 在得到 AR(p) 、MA(q) 模型的 ACF、PACF 后，我们现在来讨论ARMA(p, q) 的 ACF 和 PACF。我们还是从特例 ARMA(1,1) 过程开始。ARMA(1,1)模型为：</p><p><span class="math display">\[y_t = a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}, \quad\varepsilon_t \sim WN(0, \sigma^2)\]</span></p><ol type="1"><li>无需计算 <spanclass="math inline">\(\gamma_0\)</span>，就有自相关系数 <spanclass="math inline">\(\rho_0=\dfrac{\gamma_0}{\gamma_0}=1\)</span>。我们还可以推导<span class="math inline">\(\gamma_0\)</span> 和 <spanclass="math inline">\(\gamma_1\)</span> 关系：</li></ol><p><span class="math display">\[\begin{split}\gamma_0 &amp;= Var(y_t) = Cov(y_t, a_1 y_{t-1} + \varepsilon_t +\beta_1 \varepsilon_{t-1}) \\&amp;= a_1 Cov(y_t, y_{t-1})+Cov(y_t,\varepsilon_t)+\beta_1Cov(y_t,\varepsilon_{t-1}) \\&amp;= a_1 \gamma_1 +Cov(a_1 y_{t-1} + \varepsilon_t + \beta_1\varepsilon_{t-1},\varepsilon_t)+\beta_1 Cov(a_1 y_{t-1} + \varepsilon_t+ \beta_1 \varepsilon_{t-1},\varepsilon_{t-1}) \\&amp;= a_1 \gamma_1 +(0+ \sigma^2 +0)+\beta_1 [a_1 Cov(a_1 y_{t-2} +\varepsilon_{t-1} + \beta_1\varepsilon_{t-2},\varepsilon_{t-1})+0+\beta_1\sigma^2] \\&amp;= a_1 \gamma_1 +\sigma^2+a_1\beta_1\cdot(0+\sigma^2+0)+\beta_1^2\sigma^2 \\&amp;= a_1 \gamma_1 +(1+a_1\beta_1+\beta_1^2)\sigma^2\end{split}\]</span></p><p>如果想求得 <span class="math inline">\(\gamma_0\)</span>，可以把下面<span class="math inline">\(\gamma_1\)</span> 代入，解出 <spanclass="math inline">\(\gamma_0=\dfrac{1+2a_1\beta_1+\beta_1^2}{1-a_1^2}\sigma^2\)</span>。 2. 计算<span class="math inline">\(\gamma_1\)</span>：</p><p><span class="math display">\[\begin{align*}\gamma_1 &amp;= Cov(y_t, y_{t-1}) = Cov(a_1 y_{t-1} + \varepsilon_t +\beta_1 \varepsilon_{t-1}, y_{t-1})\\&amp;= a_1 Var(y_{t-1}) + Cov(\varepsilon_t, y_{t-1})+ \beta_1Cov(\varepsilon_{t-1}, y_{t-1}) \\&amp;= a_1 \gamma_0 + 0+ \beta_1 Cov(a_1 y_{t-2} + \varepsilon_{t-1} +\beta_1 \varepsilon_{t-2},\varepsilon_{t-1}) \\&amp;= a_1 \gamma_0 + \beta_1 \sigma^2\end{align*}\]</span></p><p>这时，<span class="math inline">\(\rho_1 =\dfrac{\gamma_1}{\gamma_0}=a_1+\dfrac{\beta_1 \sigma^2}{\gamma_0}\)</span>。 3. 计算 <spanclass="math inline">\(\gamma_2\)</span>：</p><p><span class="math display">\[\begin{align*}\gamma_2 &amp;= Cov(y_t, y_{t-2}) = Cov(a_1 y_{t-1} + \varepsilon_t +\beta_1 \varepsilon_{t-1}, y_{t-2})\\&amp;= a_1 Cov(y_{t-1}, y_{t-2}) + Cov(\varepsilon_t, y_{t-2})+ \beta_1Cov(\varepsilon_{t-1}, y_{t-2}) \\&amp;= a_1 \gamma_1 \end{align*}\]</span></p><p>这时，<span class="math inline">\(\rho_2 =\dfrac{\gamma_2}{\gamma_0}=a_1 \rho_1\)</span>。 4. 考虑 <spanclass="math inline">\(\gamma_k\)</span> （<spanclass="math inline">\(k&gt;1\)</span>）的情况：</p><p><span class="math display">\[\begin{align*}gamma_k &amp;= Cov(y_t, y_{t-k}) = Cov(a_1 y_{t-1} + \varepsilon_t +\beta_1 \varepsilon_{t-1}, y_{t-k})\\&amp;= a_1 Cov(y_{t-1}, y_{t-k}) + Cov(\varepsilon_t, y_{t-k})+ \beta_1Cov(\varepsilon_{t-1}, y_{t-k}) \\&amp;= a_1 \gamma_{k-1} \end{align*}\]</span></p><p>这时，<span class="math inline">\(\rho_k =\dfrac{\gamma_k}{\gamma_0}=a_1 \rho_{k-1}\)</span>，呈现指数衰减（拖尾）。 这个式子也表明 <spanclass="math inline">\(k=0\)</span> 和 <spanclass="math inline">\(k=1\)</span> 的特殊性：</p><ul><li>当 <span class="math inline">\(k=0\)</span>，<spanclass="math inline">\(Cov (\varepsilon_t, y_{t-k})\)</span> 和 <spanclass="math inline">\(Cov (\varepsilon_{t-1}, y_{t-k})\)</span> 均不为0；</li><li>当 <span class="math inline">\(k=1\)</span>，<spanclass="math inline">\(Cov (\varepsilon_t, y_{t-k})\)</span> 为 0，但<span class="math inline">\(Cov (\varepsilon_{t-1}, y_{t-k})\)</span>不为 0；</li><li>只有在 <span class="math inline">\(k&gt;1\)</span> 时，二者均为0。</li></ul><blockquote><p>[!Excercise] 练习：请推导 ARMA(2,1) 、ARMA (1,2)的 ACF，并推广至ARMA(p, q) 的情形。 ARMA(2,1) 的 ACF 满足：</p><ul><li><strong>计算 <spanclass="math inline">\(\gamma_0\)</span></strong>：<spanclass="math inline">\(\gamma_0 = a_1 \gamma_1 + a_2 \gamma_2 + \sigma^2(1+a_1\beta_1 + \beta_1^2)\)</span>，<spanclass="math inline">\(\rho_0=1\)</span></li><li><strong>计算 <spanclass="math inline">\(\gamma_1\)</span></strong>：<spanclass="math inline">\(\gamma_1 = a_1 \gamma_0 + a_2 \gamma_1 + \beta_1\sigma^2\)</span>，<span class="math inline">\(\rho_1 =\dfrac{\gamma_1}{\gamma_0}=\dfrac{a_1}{1 - a_2}\rho_0+\dfrac{\beta_1\sigma^2}{(1 - a_2)\gamma_0}\)</span></li><li><strong>计算 <spanclass="math inline">\(\gamma_2\)</span></strong>：<spanclass="math inline">\(\gamma_2 = a_1 \gamma_1 + a_2\gamma_0\)</span>，<span class="math inline">\(\rho_2=\dfrac{\gamma_2}{\gamma_0}= a_1 \rho_1 + a_2\)</span></li><li><span style="background:#fff88f"><strong>高阶递推</strong>：当 <spanclass="math inline">\(k&gt;1\)</span> 时，<spanclass="math inline">\(\rho_k = a_1 \rho_{k-1} + a_2\rho_{k-2}\)</span></span></li></ul><p>ARMA (1,2) 的 ACF 满足：</p><ul><li><strong>计算 <spanclass="math inline">\(\gamma_0\)</span></strong>： <spanclass="math inline">\(\gamma_0 = a_1 \gamma_1 + \sigma^2(1 + \beta_1^2 +\beta_2^2 + 2a_1\beta_1 + 2a_1\beta_2)\)</span>，<spanclass="math inline">\(\rho_0 = 1\)</span>。</li><li><strong>计算 <spanclass="math inline">\(\gamma_1\)</span></strong>： <spanclass="math inline">\(\gamma_1 = a_1 \gamma_0 + \sigma^2(\beta_1 +\beta_2a_1)\)</span>， <span class="math inline">\(\rho_1 =\dfrac{\gamma_1}{\gamma_0} = a_1 + \dfrac{\sigma^2(\beta_1 + \beta_2a_1)}{\gamma_0}\)</span>。</li><li><strong>计算 <spanclass="math inline">\(\gamma_2\)</span></strong>： <spanclass="math inline">\(\gamma_2 = a_1 \gamma_1 +\sigma^2\beta_2\)</span>， <span class="math inline">\(\rho_2 =\dfrac{\gamma_2}{\gamma_0} = a_1 \rho_1 +\dfrac{\sigma^2\beta_2}{\gamma_0}\)</span>。</li><li><strong>计算 <spanclass="math inline">\(\gamma_3\)</span></strong>： <spanclass="math inline">\(\gamma_3 = a_1 \gamma_2\)</span>， <spanclass="math inline">\(\rho_3 = \dfrac{\gamma_3}{\gamma_0} = a_1\rho_2\)</span>。</li><li><span style="background:#fff88f"><strong>高阶递推</strong>： 当<span class="math inline">\(k&gt;2\)</span> 时，<spanclass="math inline">\(\rho_k = a_1 \rho_{k-1}\)</span>。</span></li></ul><p><b> <font color="#245bdb"> 对比于 ARMA (1,1)，有什么发现？推广到 ARMA(p, q) 的 ACF 呢？</font> </b></p><ol type="1"><li>ARMA(p, q) 中，p 增加，递推公式的项数增加；q增加则不符合递推的项数增加。</li><li>递推从 q+1 项开始，递推的公式是 <spanclass="math inline">\(\rho_k=a_1 \rho_{k-1}+a_2 \rho_{k-2}+\cdots+a_p\rho_{k-p}\)</span>（递推公式的项数为当期向前推 p 项）。</li><li>因此，<span style="background:#fff88f">ARMA(p, q)的高阶递推可以表示为：当 <span class="math inline">\(k&gt;q\)</span>时，<span class="math inline">\(\rho_k =\sum_{i=1}^p a_i\rho_{k-i}\)</span>。</span></li><li>由于我们考虑的是平稳的时间序列，特征根在单位圆内。因此自相关系数在递推中不断衰减，<b><font color="#c00000"> 呈现拖尾特征 </font> </b>。</li></ol></blockquote><p><span style="background:#fff88f"><b>【ARMA (p, q) 模型的 PACF推导】</b></span>偏自相关系数（PACF）的本质是条件协方差，无截尾性，呈拖尾特征。我们还是从ARMA (1, 1)情况开始分析。ARMA (1,1) 模型为：</p><p><span class="math display">\[y_t = a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}, \quad\varepsilon_t \sim WN(0, \sigma^2)\]</span></p><p>当 <span class="math inline">\(k = 1\)</span> 时，在前面 ACF的推导中，我们已经得到：<span class="math inline">\(\gamma_1=a_1\gamma_0 + \beta_1 \sigma^2\)</span>。</p><p><span class="math display">\[\phi_{11}=\dfrac{\gamma_1}{\gamma_0}=\dfrac{a_1 \gamma_0+\beta_1\sigma^2}{\gamma_0}=a_1+\dfrac{\beta_1\sigma^2}{\gamma_0}\]</span></p><p>事实上，我们发现，ARMA (1,1) 模型的 <strong>PACF 等于ACF</strong>，即 <span class="math inline">\(\phi_{11} = \rho_1\)</span>。</p><p>接着，我们考虑 <span class="math inline">\(k = 2\)</span>的情况。在前面 ACF 的推导中，我们已经得到：<spanclass="math inline">\(\gamma_2=a_1 \gamma_1\)</span>。我们可以进一步结合<span class="math inline">\(\gamma_1=a_1 \gamma_0 + \beta_1\sigma^2\)</span>，得到：<span class="math inline">\(\gamma_2=a_1^2\gamma_0 + a_1 \beta_1 \sigma^2\)</span>。此外，还有 <spanclass="math inline">\(\gamma_0=\frac{1+2a_1\beta_1+\beta_1^2}{1-a_1^2}\sigma^2\)</span>。根据偏自相关函数与自协方差函数的关系，有：</p><p><span class="math display">\[\gamma_2=Cov(y_t,y_{t-2})=Cov(\phi_{21}y_{t-1}+\phi_{22}y_{t-2}+\varepsilon_t,y_{t-2})=\phi_{21}\gamma_1+\phi_{22}\gamma_0\]</span></p><p>结合 <span class="math inline">\(k=1\)</span> 的情况：</p><p><span class="math display">\[\begin{cases}\gamma_1 =\phi_{11}\gamma_0\\\gamma_2=\phi_{21}\gamma_1+\phi_{22}\gamma_0\end{cases} \quad \Rightarrow \quad\gamma_2 =(\phi_{21}\phi_{11}+\phi_{22}) \gamma_0\]</span></p><p>我们希望得到的目标是 <spanclass="math inline">\(\phi_{22}\)</span>，上面已经求解过了 <spanclass="math inline">\(\phi_{11}\)</span>，我们现在就考虑消去 <spanclass="math inline">\(\phi_{21}\)</span>。但是我们看到 <spanclass="math inline">\(\phi_{21}\)</span> 和 <spanclass="math inline">\(\phi_{22}\)</span>两个参数只有一个方程，因此需要再找到一个方程以求解。我们考虑：</p><p><span class="math display">\[\gamma_1 = Cov(y_t, y_{t-1})=Cov(\phi_{21}y_{t-1}+\phi_{22}y_{t-2}+\varepsilon_t,y_{t-1})=\phi_{21}\gamma_0+\phi_{22}\gamma_1\]</span></p><p>因此，我们得到：<span class="math inline">\(\phi_{21} =\dfrac{\gamma_1 (1 -\phi_{22})}{\gamma_0}=\dfrac{\gamma_1}{\gamma_0}-\dfrac{\gamma_1}{\gamma_0}\phi_{22}=\rho_{1}-\rho_{1}\phi_{22}\)</span>，从而：</p><p><span class="math display">\[\dfrac{\gamma_2}{\gamma_0}=\rho_2 =\phi_{21}\phi_{11}+\phi_{22}=(\rho_1- \rho_1\phi_{22})\phi_{11}+\phi_{22}=\phi_{11}\rho_1+(1-\phi_{11}\rho_1)\phi_{22}\]</span></p><p>因此得到 <spanclass="math inline">\(\phi_{22}=\dfrac{\rho_2-\phi_{11}\rho_1}{1-\phi_{11}\rho_1}\)</span>。又有<span class="math inline">\(\phi_{11}=\rho_1\)</span>，得到 <spanclass="math inline">\(\phi_{22}=\dfrac{\rho_2-\rho_1^2}{1-\rho_1^2}\)</span>。</p><p>ARMA (1,1) 模型 PACF 的推导可以借助 <strong>Levinson递推公式</strong>：</p><p><span class="math display">\[\begin{cases} \phi_{11} = \rho_1, \\ \\ \phi_{ss} = \dfrac{\rho_s -\sum_{j = 1}^{s-1} \phi_{s-1, j} \ \rho_{s-j}}{1 - \sum_{j = 1}^{s-1}\phi_{s-1, j} \ \rho_j}, \quad s \geq 2, \\ \\ \phi_{sj} = \phi_{s-1, j}- \phi_{ss} \phi_{s-1, s-j}, \quad j = 1,2,\dots, s-1.\end{cases}\]</span></p><p>对 <span class="math inline">\(s \geq 2\)</span>，可以将已求得的ACF(<span class="math inline">\(\rho_k\)</span>) 代入递推公式计算。 因ARMA (p, q) 包含 MA 部分，PACF不满足截尾，而是随阶数增加逐渐衰减（拖尾），具体数值需逐阶递推。</p><p><imgsrc="https://files.mdnice.com/user/77043/34c14748-2964-4e07-a770-c1d376a28aab.png"alt="ACF 和 PACF 对比" /></p><p>可以看出，使用 PACF 为 ARMA(p, q)模型定阶是非常困难的。有什么好办法吗？ 【补充】ARMA(p, q)模型阶数方法1：<b> <font color="#c22b24"> EACF 函数 </font> </b>。</p><ul><li><strong>使用方法</strong>：将 ACF汇总于表格中。用“o”表示零，“x”表示非零。“o”形成的三角形的左上角的点对应的p 和 q 就是模型应对的 p 和 q。</li><li><strong>例子</strong>：左上角的“o”点坐标为（1，1），故为ARMA(1,1)。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tx">[表: ARMA(1,1)模型EACF理论表]<br>| AR \ MA | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | <br>|---------|---|---|---|---|---|---|---|---| <br>| 0 | x | x | x | x | x | x | x | x | <br>| 1 | x | o | o | o | o | o | o | o | <br>| 2 | x | x | o | o | o | o | o | o | <br>| 3 | x | x | x | o | o | o | o | o | <br>| 4 | x | x | x | x | o | o | o | o | <br>| 5 | x | x | x | x | x | o | o | o |<br></code></pre></td></tr></table></figure><p>EACF 函数方法是 ARMA 模型基于 ACF 、PACF的定阶方法。另一种方法是使用信息准则，设定 <spanclass="math inline">\(P_{max}\)</span> 和 <spanclass="math inline">\(Q_{max}\)</span>后逐个回归，通过信息准则筛选最小信息准则的阶数。下面我们就来介绍两种主流的信息准则。</p><h4 id="2334-信息准则">2.3.3.4 信息准则</h4><p>对估计出的模型，人们自然会问：模型对数据的拟合程度如何?增加额外的滞后期必然会使估计残差的平方和减小。然而，<strong>增加这些滞后项必然要求估计额外的系数，相应地减少了自由度。</strong>甚至，<strong>包含了无关紧要的系数还会降低拟合模型的预测效果。</strong></p><p>当今的多种模型筛选准则都倾向于以放弃减少残差平方和为代价，而选择一个更加简练的模型。最常使用的模型筛选准则是<strong>赤池信息准则</strong> (Akaike InformationCriterion，<font color="#c00000"> AIC </font>) 和施瓦茨准则 (SchwartzBayesian Criterion，<font color="#c00000"> SBC </font>，也常被称为BIC)。在课本中计算式为：</p><p><span class="math display">\[\begin{split} AIC &amp;= T \ln S+2 n \\\\SBC &amp;= T \ln S+n \ln (T) \end{split}\]</span></p><ul><li>其中 <span class="math inline">\(n\)</span>为待估参数个数（p+q+或有的常数项）；<spanclass="math inline">\(T\)</span> 为可用观测值个数；S 为残差平方和。</li><li>或者，更经常地，我们把它们表示为标准化的：</li></ul><p><span class="math display">\[\begin{split}AIC^* &amp;=\frac{AIC}{T}= –2 \frac{\ln (L)}{T} + 2 \frac{n}{T}  \\\\SBC^* &amp;=\frac{SBC}{T}= –2 \frac{\ln (L)}{T} + \frac{n \ln (T)}{T}\end{split}\]</span></p><p>其中， n 和 T 如上所述定义，L 是似然函数。</p><ul><li>在教材中给出的 <span class="math inline">\(T\ln S\)</span> 和常用的<span class="math inline">\(-2\ln(L)\)</span>是近似的，对于模型比选没有差异。这涉及了对数似然函数的最大值，我们将在<a href="#2.3.4%20Box-Jenkins%20模型筛选：估计">2.3.4 参数的估计策略</a>更详细地讨论极大似然估计，并证明两种表示方法为什么对于模型比选没有差异。</li></ul><blockquote><p>[!tip] 惩罚 在统计学和机器学习中，<strong>惩罚</strong>是一种通过引入额外项来约束模型复杂度的策略。</p><ul><li>信息准则是通过对拟合优度的要求加上对参数个数的惩罚指定一个准则来定阶的。</li><li>惩罚项的作用是：当模型参数过多时，虽然似然函数 L可能增大（拟合更好），但惩罚项 2n 会显著增加，导致 AIC整体上升。<font color="#c22b24"> 这迫使模型在 “过度拟合数据” 和“保持简洁性” 之间寻找最优解 </font>。</li></ul></blockquote><p><strong>注意：</strong></p><ol type="1"><li><strong>当用滞后变量估计模型时，会损失部分观测值。为了充分比较备选模型，T应保持不变，否则，我们将依据不同的样本期来比较模型的效果。</strong> T的减少会直接降低 AIC 和 SBC的效果，而我们的目的显然不是选择一个可用观测值最少的模型。例如，有 100个数据点时，只用后 98 个观测值分别估计 AR (1) 和 AR (2) 模型，再用 T =98 比较两个模型的效果。</li><li><strong>理论上，AIC 和 SBC 要尽可能地小(注意，二者皆可为负)。当模型的拟合优度上升时，AIC 和 SBC的值会趋于负无穷。</strong>我们可以用这些准则来辅助选出最合适的模型。若模型 A 的 AIC (或 SBC)小于模型 B，则称模型 A 优于模型B。在运用准则比较各种备选模型时，我们必须基于相同的样本期来估计，这样二者才可以比较。</li><li>对于每个模型，解释变量的增加会导致 n 的增加，但残差平方和 (SSR)会减少。因此，<strong>若某个解释变量对模型没有解释力，则在模型中引入它只会导致AIC、SBC 同时变大</strong>。</li></ol><blockquote><p>[!Note] SBC 与 AIC 的比较：</p><ol type="1"><li><p><strong><font color="#c00000"> SBC 总是比 AIC 选择出的模型更简练</font></strong> 。这时因为， <spanclass="math inline">\(\ln(T)\)</span> 大于 2，所以，SBC增加解释变量的边际成本总是比 AIC 大。</p></li><li><p><font color="#245bdb"> <strong><font color="#c00000"> </font> SBC具有更优的大样本特性。</font> </font></strong>假定数据生成过程的真实阶数为 <spanclass="math inline">\((p^*，q^*)\)</span>，并且假设用 AIC 和 SBC估计所有阶数为 <span class="math inline">\((p, q)\)</span> 的 ARMA模型，其中 <span class="math inline">\(p≥p^*\)</span>，<spanclass="math inline">\(q&gt;q^*\)</span>。当样本容量趋于无限时，AIC 和SBC 选出的模型的阶数都会大于等于 <spanclass="math inline">\((p^*，q^*)\)</span>。但是，SBC 趋向于一致，而<strong><font color="#245bdb"> AIC 则倾向于选择参数过多的模型</font></strong> 。<strong><font color="#245bdb"> 在小样本下，AIC选择模型的效果要优于 SBC </font></strong>。</p></li></ol></blockquote><ul><li>如果 AIC 和 SBC都选择了相同的模型，那么，我们有理由相信这个模型是个恰当的模型。</li><li>但是，若 AIC 和 SBC筛选出的模型不同，那么，为了谨慎起见，我们仍然要继续研究。<ul><li>因为 SBC 选出的模型更加简练，所以，应该检验<strong>残差是否表现为白噪声过程</strong>（以证明模型确实对数据有解释力度）。</li><li>因为 AIC 选择的模型含有过多的参数，那么，所有系数的 <spanclass="math inline">\(t\)</span>统计量应该显著（以证明这些参数的加入是必要的）。</li></ul></li></ul><h3 id="234-box-jenkins-模型筛选估计">2.3.4 Box-Jenkins模型筛选：估计</h3><p>在大多数情况下，我们通过回归方法分析时间序列。回归对样本有独立性假设，时间序列分析利用数据相关性（惯性）分析预测，二者在某些方面有一定的相似。因此，我们有时候<strong>使用最小二乘方法来估计时间序列的参数</strong>。比如我们之前 <ahref="#1.5%20自回归（AR）模型">1.5 自回归（AR）模型</a> 学到的自回归 AR模型，以及 <a href="#2.1.2%20移动平均模型（MA）">2.1.2移动平均模型（MA）</a> 学习的移动平均 MA 模型。在 <ahref="#2.3.3.2%20偏自相关函数%20（PACF）">2.3.3.2 偏自相关函数（PACF）</a> 讨论定阶时，我们对于 “是否加入 <spanclass="math inline">\(y_{t-2}\)</span> 滞后项”的讨论就是基于多元线性回归框架的，因此使用的是最小二乘估计。</p><p>当然，在最小二乘估计之外，还有很多其他估计方法。比如矩估计(MME)，极大似然估计 (MLE)，条件最小二乘 (CLS)等。在 <ahref="#2.3.3.1%20自相关函数（ACF）">2.3.3.1 自相关函数（ACF）</a>中我们用到的 Yule-Walker 估计一种对参数的矩估计。最小二乘估计与Yule-Walker 估计渐近相同，在样本量较小时，Yule-Walker方法在估计系数方面表现较好，最小二乘估计方法在预测方差方面表现较好。样本量大时二者没有明显差别。相较于其他估计方法，矩估计更容易计算，但这也使得矩估计存在精度不高的可能性。而最大似然估计一般精度较高。相较于OLS 估计，我们对似然估计相对陌生。因此，本节以 AR (p)模型为例，重点介绍似然函数（MLE）的计算。</p><ol type="1"><li>我们假设似然函数是联合正态分布密度函数，给定 AR(p)模型：</li></ol><p><span class="math display">\[r_t = \phi_0 + \phi_1r_{t - 1} + \cdots + \phi_pr_{t - p} + a_t, \quad t= p + 1,\cdots, T\]</span></p><p>将联合似然函数表示为条件似然的乘积，似然函数为</p><p><span class="math display">\[\begin{align *} L &amp;= f(r_1, r_2,\cdots, r_T)\\ &amp;=f(r_1)f(r_2|r_1)f(r_3|r_1, r_2)\cdots f(r_T|r_1,\cdots, r_{T - 1})\end{align*}\]</span></p><ol start="2" type="1"><li>当 <span class="math inline">\(t \geq 2\)</span> 时，则可以计算<span class="math inline">\(r_t\)</span> 的条件分布。由于</li></ol><p><span class="math display">\[r_2|r_1 = \phi_0 + \phi_1r_1 + a_2 \sim N(\mu_2,\sigma_a^2)\]</span></p><p>其中：<span class="math inline">\(\mu_2 = \phi_0 +\phi_1r_1\)</span>。因此正态分布的概率密度函数为：</p><p><span class="math display">\[f(r_2|r_1) = \frac{1}{\sqrt{2\pi}\sigma_a}\exp\left\{ - \frac{(r_2 -\mu_2)^2}{2\sigma_a^2} \right\}\]</span></p><p>同理</p><p><span class="math display">\[r_3|r_1, r_2 = \phi_0 + \phi_1r_2 + \phi_2r_1 + a_3 \simN(\mu_3,\sigma_a^2)\]</span></p><p>其中：<span class="math inline">\(\mu_3 = \phi_0 + \phi_1r_2 +\phi_2r_1\)</span>。因此</p><p><span class="math display">\[f(r_3|r_1, r_2) = \frac{1}{\sqrt{2\pi}\sigma_a}\exp\left\{ - \frac{(r_3- \mu_3)^2}{2\sigma_a^2} \right\}\]</span></p><p>依此类推。因此，</p><p><span class="math display">\[L = f(r_1) \frac{1}{(2\pi)^{\frac{T - 1}{2}}\sigma_a^{T - 1}}\exp\left\{- \frac{1}{2\sigma_a^2} \sum_{t = 2}^T(r_t - \mu_t)^2 \right\}\]</span></p><p>注：同底数幂相乘，底数不变指数相加因而出现求和；以及不要遗漏 <spanclass="math inline">\(f(r_1)\)</span>。 3.取对数，得到对数似然函数：</p><p><span class="math display">\[\ln{L} = \ln f(r_1) - \frac{T - 1}{2} \left[\ln(2\pi)+2\ln\sigma_a\right] - \frac{1}{2\sigma_a^2} \sum_{t =2}^T(r_t - \mu_t)^2\]</span></p><p>得到似然函数后就可以通过最大化对数似然函数估计模型参数。</p><blockquote><p>[!NOTE] （填坑）不同 AIC、SBC 表示的比较 现在，我们可以返回来考虑 <ahref="#2.3.3.4%20信息准则">2.3.3.4 信息准则</a>中那个比较了。这也可以作为极大似然估计的一个练习。</p><p>对于时间序列 <spanclass="math inline">\(\{r_t\}\)</span>，有极大似然估计 <spanclass="math display">\[\ln{L} = \ln f(r_1) - \dfrac{T - 1}{2}\left[\ln(2\pi)+2\ln\sigma\right] - \dfrac{1}{2\sigma^2} \sum_{t =2}^T(r_t - \mu_t)^2\]</span> 我们需要最大化似然函数 <spanclass="math inline">\(\ln L\)</span>。但为了计算方便，我们不立刻这样处理，而是先根据正态分布的性质化简一下。</p><p>对于正态分布，概率密度函数（PDF）为</p><p><span class="math display">\[f (x)=\dfrac{1}{\sqrt{2\pi\sigma^{2}}}\exp\left (-\dfrac{(x -\mu)^{2}}{2\sigma^{2}}\right)\]</span></p><p>那么，</p><p><span class="math display">\[\ln(f(x))=\ln(\dfrac{1}{\sqrt{2\pi\sigma^{2}}})+(-\dfrac{(x -\mu)^{2}}{2\sigma^{2}})=-\frac{1}{2}\ln(2\pi\sigma^2)-\dfrac{(x -\mu)^{2}}{2\sigma^{2}}\]</span></p><p>代入得：</p><p><span class="math display">\[\begin{split} –2 \ln (L) &amp;= -2\ln(f(r_1)) +(T -1)\left[\ln(2\pi)+2\ln\sigma\right] + \dfrac{1}{\sigma^2} \sum_{t =2}^T(r_t - \mu_t)^2 \\ &amp;=\ln(2\pi\sigma^2)+\dfrac{(r_1 -\mu)^{2}}{\sigma^2} +(T-1)\ln(2\pi\sigma^2)+\dfrac{1}{\sigma^2} \sum_{t= 2}^T(r_t - \mu_t)^2 \\ &amp;= T\ln (2πσ^2) + \dfrac{(r_1 -\mu)^{2}}{\sigma^2}+\dfrac{1}{\sigma^2} \sum_{t = 2}^T(r_t - \mu_t)^2\\&amp;= T\ln (2π) +T\ln(σ^2)+\dfrac{1}{\sigma^2} \sum_{t = 1}^T(r_t -\mu_t)^2 \end{split}\]</span></p><p>其中 <span class="math inline">\(\sum_{t = 1}^T(r_t -\mu_t)^2\)</span> 是残差平方和，为简便我们可以把它记为 S。</p><p>现在，我们可以最大化似然函数 <span class="math inline">\(\lnL\)</span> 了。这与我们在最小二乘估计时的方法类似，我们可以对 <spanclass="math inline">\(σ^2\)</span> 求导并令导数为零。我们可以得到：</p><p><span class="math display">\[\frac{\partial}{\partial \sigma^2} \left[ T \ln(2\pi) +T\ln(\sigma^2)+\dfrac{S}{\sigma^2} \right] = \frac{T}{\sigma^2} - \dfrac{S}{\sigma^4} =0\]</span></p><p>进而得到一个美妙的关系式： <span class="math inline">\(\sigma^2 =\dfrac{S}{T}\)</span> 。因此，我们就可以把原式 <spanclass="math inline">\(\sigma^2\)</span> 替换，得到</p><p><span class="math display">\[\begin{split} –2 \ln (L) &amp;=  T\ln (2π) +T\ln(σ^2)+\dfrac{1}{\sigma^2} \sum_{t = 1}^T(r_t - \mu_t)^2\\&amp;=T\ln(2\pi)+T\ln(\dfrac{S}{T})+\dfrac{T}{S}\cdotS\\&amp;=T\ln(2\pi)+T\ln(S)-T\ln(T)+T \end{split}\]</span></p><p>由于 <span class="math inline">\(T\)</span> 为可用观测值个数，<spanclass="math inline">\(T\ln(2\pi)-T\ln(T)+T\)</span>本质上是常数项。这表明二者在本质上是一致的。由于模型筛选的本质是<strong>相对比较</strong>，比较时常数项会相互抵消，最终决策仅依赖核心项（残差平方和S 、参数数量 n）。因此，是否保留常数项不影响使用。</p></blockquote><p>在极大似然估计之外，我们再介绍一下<strong>条件最小二乘估计</strong>（CLS）。条件最小二乘在估计时考虑了模型的条件结构，即在给定过去值的情况下，当前值的预测误差最小化。下面我们介绍其做法：</p><ul><li>从第 <span class="math inline">\(p + 1\)</span>个观测值开始估计。给定前 <span class="math inline">\(p\)</span>个观测值，对于 <span class="math inline">\(t = p +1,\cdots,T\)</span>，我们有：</li></ul><p><span class="math display">\[r_t = \phi_0 + \phi_1r_{t - 1} + \cdots + \phi_pr_{t - p} + a_t\]</span></p><p>设估计结果为：<span class="math inline">\(\hat{r}_t = \hat{\phi}_0 +\hat{\phi}_1r_{t - 1} + \cdots + \hat{\phi}_pr_{t - p}\)</span></p><ul><li>残差序列 <span class="math inline">\(\{\hat{a}_t\}\)</span>为：<span class="math inline">\(\hat{a}_t = r_t -\hat{r}_t\)</span></li><li><span class="math inline">\(\sigma_a\)</span> 的估计值： <spanclass="math display">\[\hat{\sigma}_a^2 = \frac{\sum_{t = p +1}^T\hat{a}_t^2}{T - 2p - 1}\]</span></li><li>自然地，我们会疑惑：“条件”在哪里了？事实上，我们只是考察了 p+1 时刻之后的噪声项，这就是“条件”。</li></ul><h3 id="235-box-jenkins-模型筛选评价">2.3.5 Box-Jenkins模型筛选：评价</h3><p>完成 Box-Jenkins 模型筛选方法的识别、估计阶段之后，我们进入<font color="#c22b24"> 诊断检验阶段</font>。也就是说，我们要对初步确定的模型进行评价和比较。估计恰当的模型应满足以下条件：</p><ol type="1"><li>简练；</li><li>其系数表现为平稳且可逆；</li><li>拟合数据较好；</li><li>残差接近白噪声过程；</li><li>系数不随样本期改变而改变；</li><li>有较好的样本区间外预测。 这些内容分布在课本 2.7-2.13节，出于知识衔接的考虑，我们先介绍白噪声检验（对应于第 4条原则），然后介绍可逆性（第 2 条）和简练原则（第 1条），最后讨论样本区间外预测（第 6 条）、系数不随样本期改变而改变（第 5条）以及更优拟合效果（第 3 条）的内容。</li></ol><h4 id="2351-白噪声检验">2.3.5.1 白噪声检验</h4><p>在诊断检验阶段，确定模型恰当的一个非常重要的条件是：<strong>确保估计模型的残差能够模拟白噪声过程</strong>。此外，我们也曾在<a href="#2.3.3.4%20信息准则">2.3.3.4</a>节最后指出：使用施瓦茨信息准则（SBC）应该检验残差是否表现为无分析价值的白噪声过程。那么，如何进行这一检验呢？</p><p>Box-Jenkins (1976) 用样本自相关系数构造了 <strong>Q统计量</strong>，计算公式为 Box-Pierce 形式：</p><p><span class="math display">\[Q_{BP} = T \sum_{k=1}^s r_k^2\]</span></p><p>在所有的 r 值等于 0 的原假设下，Q 近似地服从自由度为 s的卡方分布。</p><ul><li><strong>用途</strong>：检测时间序列是否存在显著的自相关（即当前值与历史值是否相关）。</li><li>使用这个统计量，明显可以发现较高的样本自相关系数将导致较大的 Q值。</li><li>白噪声过程 (在这个过程中，所有自相关系数应该为 0) 的 Q 值为 0。</li><li><strong>假设检验</strong>：</li><li><strong>原假设</strong>（H₀）：序列无自相关（即纯随机性/白噪声）。</li><li><strong>判断标准</strong>：若计算出的 Q统计量超过卡方分布的临界值（或 p 值 &lt;0.05），则拒绝原假设，认为存在自相关。</li><li><strong>不足</strong>：Box-Pierce 形式的 Q统计量适用于大样本，但在相对较小的样本中效果不佳。即使是适度大的样本，其效果也较差。</li></ul><p>基于此，Ljung-Box（1978）提出了更优、对小样本同样适用的修正 Q统计量，公式为：</p><p><span class="math display">\[Q_{LB} =  \frac{T(T+2) \sum_{k=1}^s r_k^2}{T-k}\]</span></p><p>它与 <span class="math inline">\(Q_{BP}\)</span> 的差别与关联是：</p><p><span class="math display">\[Q_{LB} =  \frac{T(T+2) \sum_{k=1}^s r_k^2}{n-k}=\frac{T+2}{T-k}Q_{BP}\]</span></p><p>其中，<span class="math inline">\(T\)</span> 为样本量，<spanclass="math inline">\(m\)</span> 为最大滞后阶数，<spanclass="math inline">\(r_k\)</span> 为 k 阶自相关系数。</p><p>Box-Pierce 和 Ljung-Box 的 Q 统计量同样可以用于检验被估的 ARMA (p, q)模型的残差是否为白噪声过程，然而，若从被估的 ARMA (p, q) 模型中得到了 s个自相关系数，则自由度会随待估系数的增加而减少。因此，若使用 ARMA (p, q)模型的残差，Q 统计量服从自由度为 s-p-q 的卡方分布(若模型包含了一个常数，则自由度为 s-p-q-1)。</p><h4 id="2352-可逆性">2.3.5.2 可逆性</h4><p>在诊断检验阶段，确定模型恰当的另一个非常重要的条件是平稳可逆。正如我们在<a href="#2.3.3%20Box-Jenkins%20模型筛选：定阶">2.3.3 Box-Jenkins模型筛选：定阶</a>一开始就提到的，我们在本章仅讨论平稳的时间序列，因此，这一节我们讨论的重点是可逆性（invertible）。我们将围绕三个问题展开本小节：</p><ol type="1"><li>什么是可逆性？</li><li>可逆性的作用？</li><li>怎么满足可逆性？</li></ol><p>我们先从第一个问题开始。课本给出的定义如下：</p><blockquote><p>[!NOTE] 什么是可逆性？ <strong><font color="#c22b24"> 可逆性的定义</font></strong>：若 <span class="math inline">\(\{y_t\}\)</span>能被一个有限阶或收敛的自回归过程表示，则序列可逆。</p></blockquote><p>看上去有些晦涩。我们以 MA (1) 为例来说明可逆性及其作用。考虑简单的 MA(1) 模型：</p><p><span class="math display">\[x_t = \varepsilon_t - \beta_1 \varepsilon_{t-1} = (1 - \beta_1 L)\varepsilon_t \quad \Rightarrow \quad \varepsilon_t=\dfrac{x_t}{1 -\beta_1 L}\]</span></p><p>其中 L 是 <a href="#1.4.5.3%20滞后算子">1.4.5.3 </a>节中我们学过的滞后算子。我们可以使用 Taylor 展开，有：</p><p><span class="math display">\[\frac{1}{1 - \beta_1 L} = 1 + \beta_1 L + \beta_1^2 L^2 + \beta_1^3 L^3+ \cdots\]</span></p><p>从而，</p><p><span class="math display">\[\begin{split}\varepsilon_t = \frac{x_t}{1 - \beta_1 L} &amp;= x_t + \beta_1 L x_t +\beta_1^2 L^2 x_t + \beta_1^3 L^3 x_t + \cdots \\&amp;= x_t+\beta_1x_{t-1} + \beta_1^2 x_{t-2} + \beta_1^3 x_{t-3} + \cdots\end{split}\]</span></p><p>得到：</p><p><span class="math display">\[x_t =-\beta_1 x_{t-1} -\beta_1^2 x_{t-2} - \beta_1^3 x_{t-3} + \cdots+\varepsilon_t\]</span></p><p>形式上，我们将 MA(1) 转化成 AR(∞)的形式。<strong>该级数收敛的充要条件是 <spanclass="math inline">\(|\beta_1|&lt; 1\)</span> 。</strong></p><p>类似地，我们可以推导得到 q 阶 MA 模型，用滞后算子得到：</p><p><span class="math display">\[\varepsilon_t= \frac{x_t}{1 - (\beta_1 L + \beta_2 L^2+\cdots+\beta_qL^q)}=[1 - (\beta_1 L + \beta_2 L^2+\cdots+\beta_q L^q)]^{-1}x_t\]</span></p><p>其可以转换为 AR(∞) 模型。因此，我们可以说：<b> <font color="#c22b24">MA (q) 可以转换为有约束的 AR (∞) 模型 </font> </b>。</p><p>尽管模型 MA(q)对任意 <spanclass="math inline">\(|\beta_1|&lt;∞\)</span>都是平稳的，但模型却不一定能转换为合理的有约束AR(∞)模型，而是需要满足一定条件，这被称为<strong>可逆性条件</strong>。对于具有收敛 AR 表达式的 ARMA模型，特征多项式的根应在单位圆之外。</p><p><strong>对于 MA (2) 模型，可逆要求： <spanclass="math inline">\(|\beta_2| &lt; 1\)</span>，<spanclass="math inline">\(\beta_2+\beta_1 &lt; 1\)</span>，<spanclass="math inline">\(\beta_2 - \beta_1 &lt; 1\)</span>均成立。</strong></p><p>最后，作为一个补充拓展，请思考：为什么这被叫做“可逆性”？</p><blockquote><p>[!TIP] 【回顾】AR (1) 转化为 MA (<spanclass="math inline">\(\infty\)</span>) 对于平稳的 AR (1) 模型：</p><p><span class="math display">\[y_t = a_0 + a_1 y_{t-1} + \varepsilon_t, \quad \varepsilon_t \sim\text{i.i.d. } N(0, \sigma^2),\]</span></p><p><strong>向前递推</strong>：AR (1) 模型可表示为：</p><p><span class="math display">\[\begin{split}y_t &amp;= a_0 + a_1 y_{t-1} + \varepsilon_t  \\&amp;= a_0+ a_1(a_0 + a_1 y_{t-2} + \varepsilon_t) + \varepsilon_t  \\&amp;=\cdots  \\&amp;= a_0(1 + a_1 + a_1^2 + \cdots) + \varepsilon_t + a_1\varepsilon_{t-1} + a_1^2 \varepsilon_{t-2} + \cdots \\  &amp;=\dfrac{a_0}{1 - a_1} + \varepsilon_t + a_1 \varepsilon_{t-1} + a_1^2\varepsilon_{t-2} + \cdots \\&amp;= \dfrac{a_0}{1 - a_1} +\sum_{i=0}^\infty a_1^i \varepsilon_{t-i}\end{split}\]</span></p><p>这表明当前观测值 <span class="math inline">\(y_t\)</span>是历史扰动项 <span class="math inline">\(\varepsilon_{t-i}\)</span>的加权和，权重为 <span class="math inline">\(a_1^i\)</span>。因此，AR(1) 可以转化为 MA (<span class="math inline">\(\infty\)</span>)。这个知识点在 <a href="#1521-ar1的线性特征">1.5.2.1AR(1)的线性特征</a>(#1.5.2.1%20AR(1) 的线性特征)已介绍过（但没有证明）。 因此，我们知道：AR 可以推得 MA，现在我们证明了MA 在一定条件下也可以证得 AR。这就是被称为“可逆性”的原因。</p></blockquote><h4 id="2353-简练原则">2.3.5.3 简练原则</h4><p>在探讨完可逆性之后，我们进一步对 Box - Jenkins 方法进行探讨。Box -Jenkins 方法的基本思想是 <strong>简练原则</strong>。</p><p>正如在 <a href="#2.3.3.4%20信息准则">2.3.3.4 信息准则</a>节中我们提到的，增加新的参数固然会提高拟合优度（即判定系数 <spanclass="math inline">\(R^{2}\)</span> 会增加），但同时也减少了自由度。Box和 Jenkins证明：简练模型要比参数过多模型的预测效果更好，一个简练模型能较好地拟合数据且不需要增加无关的参数。尽管我们也希望充分地得到未来的估计参数，但是我们的目的是接近真实的数据生成过程，而不是绝对准确地刻画出这个过程（过拟合）。</p><blockquote><p>[!TIP] 过拟合</p><ul><li><strong>过拟合是机器学习中的一个概念，指的是模型对训练数据的过度学习</strong>。</li><li>当模型过拟合时，它在训练数据上表现得非常好，但在新数据上表现不佳。这是因为模型学习了训练数据中的噪音和离群值，这些信息在新数据上无法很好地泛化。</li><li>过拟合就像是背诵了一组问题的答案，而不是理解其背后的原理。虽然模型可能会正确回答已知问题，但在面对新问题或已知问题的变体时却会陷入困境。</li></ul></blockquote><p>在选择最恰当模型的过程中，计量经济学家会意识到：<strong>不同的模型可能有相似的特征</strong>。</p><ul><li><ul><li>作为一个极端的例子，AR (1) 模型 <spanclass="math inline">\(y_{t}=0.5 y_{t - 1}+\varepsilon_{t}\)</span>有等价的无限阶移动平均表达式 <spanclass="math inline">\(y_{t}=\varepsilon_{t}+0.5\varepsilon_{t -1}+0.25\varepsilon_{t - 2}+0.125\varepsilon_{t - 3}+0.0625\varepsilon_{t- 4}+\cdots\)</span>。在大样本的情况下，将 MA (<spanclass="math inline">\(\infty\)</span>) 过程近似地确定为 MA (2) 或 MA (3)过程，可以得到一个较好的拟合优度。然而，<strong>AR (1)模型更简练，所以更优。</strong></li></ul></li><li><p>同时，也要注意公因式（common factor）问题。假设我们想拟合 ARMA(2,3) 模型：</p></li></ul><p><span class="math display">\[(1 - a_1L - a_{2}L^{2})y_{t}=(1+\beta_1L+\beta_{2}L^{2}+\beta_{3}L^{3})\varepsilon_{t}\]</span></p><p>假设 <span class="math inline">\((1 - a_1L - a_{2}L^{2})\)</span> 和<spanclass="math inline">\((1+\beta_1L+\beta_{2}L^{2}+\beta_{3}L^{3})\)</span>分别可被因式分解为 <span class="math inline">\((1 + cL)(1 + aL)\)</span>和 <span class="math inline">\((1 + cL)(1 + b_{1}L +b_{2}L^{2})\)</span>。因为 <span class="math inline">\((1 + cL)\)</span>为公因式，所以有等价但更为简练的形式：</p><p><span class="math display">\[(1 + aL) y_{t}=(1 + b_{1}L + b_{2}L^{2})\varepsilon_{t}\]</span></p><p>当我们揭开了前面的谜题后，就应该明白 <span class="math inline">\((1 -0.25 L^{2}) y_{t}=(1 + 0.5 L)\varepsilon_{t}\)</span> 等价于 <spanclass="math inline">\((1 + 0.5 L)(1 - 0.5 L) y_{t}=(1 + 0.5L)\varepsilon_{t}\)</span>。因此，<span class="math inline">\(y_{t}=0.5y_{t - 1}+\varepsilon_{t}\)</span>。</p><p>实践中，多项式也许不能完全进行因式分解，然而，若因式近似，应尝试使用更为简练的形式。为了确保模型简练，每个参数<span class="math inline">\(a_{i}\)</span> 和 <spanclass="math inline">\(\beta_{i}\)</span> 的 <spanclass="math inline">\(t\)</span> 统计量都应该大于等于2.0（这样才能够保证在 5%显著水平下的每个系数显著地异于零）。</p><p>此外，因为具有高度多重共线性的系数是不稳定的，所以，要求系数不能彼此相关，因此，通常可从模型中删去1 个到多个系数，同时又不会影响模型的预测效果。</p><h4 id="2354-样本区间外预测">2.3.5.4 样本区间外预测</h4><p>ARMA模型最重要的用途是用于预测序列的未来值，较好的样本区间外预测也能够为模型的选择提供参考。</p><ul><li><ul><li>首先，我们先明确基本概念：站在 <spanclass="math inline">\(t\)</span> 时点预测 <spanclass="math inline">\(r_{t + k}\)</span>，其中 <spanclass="math inline">\(k∈Z^+\)</span>，称时间点 <spanclass="math inline">\(t\)</span> 为 <strong>预测原点</strong>，正整数<span class="math inline">\(k\)</span> 为<strong>预测步长</strong>。定义 <spanclass="math inline">\(\hat{r}_t(k)\)</span> 为 <spanclass="math inline">\(r_t\)</span> 从预测原点 <spanclass="math inline">\(t\)</span> <strong>向前 <spanclass="math inline">\(k\)</span> 步预测值</strong>。</li></ul></li><li><p>其次，我们认为：恰当的模型具有较好的样本区间外预测。自然地，我们要问：我怎么知道这个模型预测的效果好不好？这就涉及到了<strong>损失函数</strong>（Loss Function） 的概念。</p></li></ul><blockquote><p>[!Note] 损失函数</p><ul><li><p>我们使用 <strong>损失函数</strong> 评估预测的优劣。</p></li><li><p>损失函数通过数学表达式刻画模型预测值 <spanclass="math inline">\(\hat{y}\)</span> 与真实值 <spanclass="math inline">\(y\)</span> 的偏差。</p></li><li><p>单个样本的损失 <span class="math inline">\(L(y, \hat{y})\)</span>反映 <strong>预测误差</strong>，多个样本则计算平均损失。</p></li><li><p>常用的损失函数：</p><ol type="1"><li>均方误差（Mean Square Error，简称 MSE），定义为：</li></ol><p><span class="math display">\[MSE(\hat{r}_t(k)) = \mathbb{E}\left(r_{t + k} - \hat{r}_t(k)\right)^2\]</span></p><ol start="2" type="1"><li>根均方误差（Root Mean Square Error，简称 RMSE），定义为：</li></ol><p><span class="math display">\[RMSE(\hat{r}_t(k)) = \sqrt{\mathbb{E}\left(r_{t + k} -\hat{r}_t(k)\right)^2}\]</span></p><ol start="3" type="1"><li>平均绝对误差（Mean Absolute Error，简称 MAE），定义为：</li></ol><p><span class="math display">\[MAE(\hat{r}_t(k)) = \mathbb{E}|r_{t + k} - \hat{r}_t(k)|\]</span></p></li></ul></blockquote><ul><li>在本小节中，我们使用均方误差（MSE）作为预测优劣的评判标准。</li><li>均方误差越小，我们就可以认为模型拟合效果越好。由此，我们希望得到的模型应该是最小均方误差的，即：<strong>选择合适的模型，使得其预测<span class="math inline">\(\hat{r}_t(k)\)</span> 满足 <spanclass="math inline">\(\mathbb{E}\left([r_{t+k} - \hat{r}_t(k)]^2|\Omega_t \right)\)</span> 最小。</strong> 其中：<spanclass="math inline">\(\Omega_t\)</span> 表示 <spanclass="math inline">\(t\)</span> 时刻所得到的所有信息。</li><li>使得均方误差最小的预测就是给定 <spanclass="math inline">\(\Omega_t\)</span> 条件下的 <spanclass="math inline">\(r_{t+k}\)</span> 的期望值，即：</li></ul><p><span class="math display">\[\hat{r}_t(k) = E\left( r_{t+k} \big| \Omega_t \right)\]</span></p><p>现在，我们考虑几个常用模型的预测。</p><h5 id="23541-ar-模型的向前-k-步预测">2.3.5.4.1 AR 模型的向前 k步预测</h5><ol type="1"><li><strong>AR(p)模型的向前一步预测：</strong></li></ol><p><span class="math display">\[r_{t+1} = a_0 + a_1 r_t + \cdots + a_p r_{t+1-p} + \varepsilon_{t+1}\qquad \Omega_t=\{r_t, r_{t-1},...\}\]</span></p><p><strong>向前一期 <span class="math inline">\(r_{t+1}\)</span>的点预测</strong>：</p><p><span class="math display">\[\hat{r}_t (1) = E(r_{t+1}|\Omega_t) =a_0 +a_1r_t+\cdots+a_pr_{t+1-p}=a_0 + \sum_{i=1}^p a_i r_{t+1-i}\]</span></p><p><strong>预测误差及其方差</strong>：</p><p><span class="math display">\[e_t (1) = r_{t+1} - \hat{r}_t (1) = \varepsilon_{t+1} \quad \Rightarrow\quad {Var}(e_t (1)) ={Var}(\varepsilon_{t+1})= \sigma^2\]</span></p><p><strong>如果 <span class="math inline">\(\varepsilon_t\)</span>服从正态分布，则 <span class="math inline">\(r_{t+1}\)</span> 的95%置信区间</strong>：</p><p><span class="math display">\[\left[ \hat{r}_t (1) - 1.96\sigma,\ \hat{r}_t (1) + 1.96\sigma \right]\]</span></p><ol start="2" type="1"><li><strong>AR(p)模型的向前两步预测：</strong></li></ol><p><span class="math display">\[r_{t+2} = a_0 + a_1r_{t+1} +a_2 r_t+ \cdots + a_pr_{t+2-p}+\varepsilon_{t+2} \qquad \Omega_t=\{r_t, r_{t-1},...\}\]</span></p><p><strong>向前两期 <span class="math inline">\(r_{t+2}\)</span>的点预测</strong>：</p><p><span class="math display">\[\hat{r}_t(2) = {E}(r_{t+2}|\Omega_t) = a_0 + a_1 \hat{r}_t (1) +a_2 r_t+ \cdots + a_p r_{t+2-p}\]</span></p><p><strong>预测误差及其方差</strong>：（注：大多数项都被差分消去，保留的是<span class="math inline">\(e_t(1)\)</span> 和最后的误差项。 ）</p><p><span class="math display">\[\begin{split} e_t(2) &amp; = r_{t+2} - \hat{r}_t(2)=a_1e_t(1)+\varepsilon_{t+2}= a_1 \varepsilon_{t+1}+\varepsilon_{t+2} \\{Var}(e_t(2)) &amp;= {Var}(a_1 \varepsilon_{t+1}+\varepsilon_{t+2}) = (1+ a_1^2) \sigma^2\end{split}\]</span></p><p><strong>如果 <span class="math inline">\(\varepsilon_t\)</span>服从正态分布，则 <span class="math inline">\(r_{t+2}\)</span> 的 95%置信区间</strong>：</p><p><span class="math display">\[\left[ \hat{r}_t(2) - 1.96 \sqrt{(1 + a_1^2) \sigma^2},\ \hat{r}_t(2) +1.96 \sqrt{(1 + a_1^2) \sigma^2} \right]\]</span></p><ol start="3" type="1"><li>请思考：对于 <strong>AR(p)模型的向前三步预测</strong>，点预测和预测误差分别是什么。对于预测误差的推导非常重要，与后面k 步预测、脉冲反应函数相关。</li></ol><p><span class="math display">\[\begin{split}e_t(3)=r_{t+3}-\hat{r}_t(3)&amp;=a_1r_{t+2}+a_2r_{t+1}-a_1\hat{r}_t(2)-a_2\hat{r}_t(1)+\varepsilon_{t+3}\\&amp;=a_1e_t(2)+a_2e_t(1)+\varepsilon_{t+3}\\&amp;=a_1\cdot[a_1e_t(1)+\varepsilon_{t+2}]+a_2e_t(1)+\varepsilon_{t+3}\\&amp;=(a_1^2+a_2)e_t(1)+a_1\varepsilon_{t+2}+\varepsilon_{t+3}\\&amp;=(a_1^2+a_2)\varepsilon_{t+1}+a_1\varepsilon_{t+2}+\varepsilon_{t+3}\end{split}\]</span></p><ol start="4" type="1"><li><strong>AR (p) 模型的向前 k 步预测：</strong></li></ol><p><span class="math display">\[r_{t+k} = a_0 + a_1r_{t+k-1} + \cdots + a_p r_{t+k-p}+\varepsilon_{t+k}\qquad \Omega_t=\{r_t, r_{t-1},...\}\]</span></p><p><strong>向前 k 期 <span class="math inline">\(r_{t+k}\)</span>的点预测</strong>：</p><ul><li>当 <span class="math inline">\(k&lt;p\)</span> 时，模型包含 k个预测项和（p-k）个已有信息。</li></ul><p><span class="math display">\[\begin{split} \hat{r}_t(k) = {E}(r_{t+k}|\Omega_t) &amp;= a_0 + a_1\hat{r}_t(k-1) +a_2 \hat{r}_t(k-2)+ \cdots +a_{k-1} \hat{r}_t(1) \\&amp;+ a_k r_t +a_{k+1} r_{t-1} \cdots + a_p r_{t+k-p} \end{split}\]</span></p><ul><li>当 <span class="math inline">\(k≥p\)</span> 时，模型只包含 p个预测项。</li></ul><p><span class="math display">\[\hat{r}_t(k) = {E}(r_{t+k}|\Omega_t) = a_0 + a_1 \hat{r}_t(k-1) +a_2\hat{r}_t(k-2)+ \cdots +a_{p} \hat{r}_t(k-p)\]</span></p><blockquote><p>[!NOTE] 【思考】当 <span class="math inline">\(k\rightarrow\infty\)</span> 时的点预测 当 <span class="math inline">\(k\rightarrow\infty\)</span> 时，</p><p><span class="math display">\[\begin{split}&amp;\hat{r}_t(\infty)= a_0 + a_1 \hat{r}_t(\infty) +\cdots +a_{p} \hat{r}_t(\infty) \\ \\ \Rightarrow &amp; \quad\hat{r}_t(\infty)=\dfrac{a_0}{1-(a_1+\cdots+a_p)}=\dfrac{a_0}{\sum_{i=1}^p a_i}\end{split}\]</span></p><p>这是什么？<span class="math inline">\(E(r_t)=a_0+\sum_{i=1}^pa_iE(r_{t-i})\quad \Rightarrow \quad E(r_t)=\dfrac{a_0}{\sum_{i=1}^pa_i}\)</span>，即：</p><p><span class="math display">\[\hat{r}_t(\infty)=E(r_t)\]</span></p><p>这就是<font color="#c22b24">“均值回转”</font>：长期的点预测趋于无条件均值。</p></blockquote><p><strong>向前 k 期的预测误差及其方差</strong>：</p><p><span class="math display">\[e_t(k) = r_{t+k} - \hat{r}_t(k) = \sum_{j=0}^{k-1} \psi_j\varepsilon_{t+k-j} \quad \Rightarrow \quad \text{Var}(e_t(k)) =\sigma^2 \sum_{j=0}^{k-1} \psi_j^2\]</span></p><p><strong>如果 <span class="math inline">\(\varepsilon_t\)</span>服从正态分布，则 95%置信区间</strong>：</p><p><span class="math display">\[\left[ \hat{r}_t(k) - 1.96 \sqrt{\text{Var}(e_t(k))},\ \hat{r}_t(k) +1.96 \sqrt{\text{Var}(e_t(k))} \right].\]</span></p><p>其中 <span class="math inline">\(\psi_j\)</span> 为 AR 模型的 <b><font color="#c22b24"> 脉冲响应函数 </font> </b>。</p><blockquote><p>[!TIP] 什么是脉冲响应函数？<strong>含义</strong>：脉冲是指某一时刻的随机扰动项发生一个单位的瞬时变化。脉冲反应函数就是描述这一冲击对后续观测值<span class="math inline">\(y_{t+k}\)</span> 的影响程度。<strong>公式</strong>：</p><p><span class="math display">\[IRF(k)=\dfrac{\partial y_{t+k}}{\partial \varepsilon_t} \quad(k=0,1,2,\cdots)\]</span></p><p>对于 AR(1) 模型，将 AR 模型转换为无限阶移动平均形式，对 t+k期的预测就是</p><p><span class="math display">\[y_{t+k} = \frac{a_0}{1 - a_1} + \sum_{i=0}^\infty a_1^i\varepsilon_{t+k-i}\]</span></p><p>那么，<span class="math inline">\(t\)</span> 期冲击 <spanclass="math inline">\(\varepsilon_t\)</span> 对 <spanclass="math inline">\(y_{t+k}\)</span> 的贡献（即，脉冲反应函数）就是<span class="math inline">\(y_{t+k}\)</span> 对 <spanclass="math inline">\(\varepsilon_t\)</span>的偏导数。因此，我们需要先找到 <spanclass="math inline">\(\varepsilon_{t}\)</span>的项：<font color="#c22b24"> 当 <span class="math inline">\(i =k\)</span> 时，<span class="math inline">\(\varepsilon_{t+k-i} =\varepsilon_{t}\)</span>，因此 <spanclass="math inline">\(\varepsilon_t\)</span> 对应的项为 <spanclass="math inline">\(a_1^k \varepsilon_t\)</span> </font> 。 <spanclass="math inline">\(y_{t+k}\)</span> 对 <spanclass="math inline">\(\varepsilon_t\)</span> 的偏导数仅保留含 <spanclass="math inline">\(\varepsilon_t\)</span> 的项：</p><p><span class="math display">\[IRF(k)= \dfrac{\partial y_{t+k}}{\partial \varepsilon_t} =\frac{\partial}{\partial \varepsilon_t} \left( \cdots + a_1^k\varepsilon_t + \cdots \right) = a_1^k\]</span></p><p>AR(p) 与之类似，但较 AR(1)复杂地多。每个滞后项的系数共同决定了冲击的传播路径，脉冲反应函数需通过递推公式计算。</p><p><span class="math display">\[\text{IRF}(k) = \psi_k = \begin{cases} 1 &amp; k=0,\\\sum_{i=1}^{\min(k,p)} a_i \psi_{k-i} &amp; k \geq 1\end{cases}\]</span></p><p>比如，AR(2) 模型的脉冲响应：</p><p><span class="math display">\[\psi_0 = 1, \quad \psi_1 = a_1, \quad \psi_2 = a_1^2 + a_2, \quad \ldots\]</span></p><p>你是否有联想到 AR(p) 向前三步预测的误差 ？<spanclass="math inline">\(e_t(3)=(a_1^2+a_2)\varepsilon_{t+1}+a_1\varepsilon_{t+2}+\varepsilon_{t+3}\)</span>这些 <span class="math inline">\(\psi\)</span> 对应了各个 <spanclass="math inline">\(\varepsilon\)</span> 的系数！<spanclass="math inline">\(e_t(3)=\psi_0\varepsilon_{t+3}+\psi_1\varepsilon_{t+2}+\psi_2\varepsilon_{t+1}\)</span>那么，可以推断得：</p><p><span class="math display">\[e_t(k)=\psi_0\varepsilon_{t+k}+\psi_1\varepsilon_{t+k-1}+\psi_2\varepsilon_{t+k-2}+\cdots+\psi_i\varepsilon_{t+k-i}+\cdots+\psi_{k-1}\varepsilon_{t+1}=\sum_{j=0}^{k-1} \psi_j \varepsilon_{t+k-j}\]</span></p><p>请注意，到第 k-1 项为止。因为从第 k项开始就不再是预测值，不存在预测误差了。这也解释了为什么向前预测的时候所有非 <spanclass="math inline">\(\hat{r}\)</span> 项都会被差分消去。</p></blockquote><h5 id="23542-ma-模型的向前-k-步预测">2.3.5.4.2 MA 模型的向前 k步预测</h5><ol type="1"><li>MA(q) 模型形式：</li></ol><p><span class="math display">\[r_{t} = c_0 + \varepsilon_{t} + \beta_1 \varepsilon_{t-1} + \cdots +\beta_q \varepsilon_{t-q}\]</span></p><ol start="2" type="1"><li><strong>MA 模型向前一步预测：</strong> 对于 MA (q)模型，向前一步为：</li></ol><p><span class="math display">\[r_{t+1} = c_0 + \varepsilon_{t+1} + \beta_1 \varepsilon_t + \cdots +\beta_q \varepsilon_{t+1-q}\]</span></p><p>给定 <span class="math inline">\(\Omega_t = \{r_t, r_{t-1},\ldots\}\)</span> 的条件下，<span class="math inline">\(r_{t+1}\)</span>的点预测为：</p><p><span class="math display">\[\hat{r}_t (1) = E (r_{t+1}|\Omega_t) = c_0 +  \beta_1 \varepsilon_t +\cdots + \beta_q \varepsilon_{t+1-q}\]</span></p><p>预测误差为：</p><p><span class="math display">\[e_t (1) = r_{t+1} - \hat{r}_t (1) = \varepsilon_{t+1}\]</span></p><p>向前 1 步预测误差的方差为：</p><p><span class="math display">\[\text{Var}(e_t (1)) = \text{Var}(\varepsilon_{t+1}) = \sigma^2\]</span></p><p>如果 <span class="math inline">\(\varepsilon_t\)</span>服从正态分布，则 95%置信水平下向前 1 步区间预测为：</p><p><span class="math display">\[[\hat{r}_t (1) - 1.96\sigma, \hat{r}_t (1) + 1.96\sigma]\]</span></p><ol start="3" type="1"><li><strong>MA 模型向前 2 步预测：</strong> 对于 MA (q)模型，向前两步为：</li></ol><p><span class="math display">\[r_{t+2} = c_0 +  \varepsilon_{t+2} + \beta_1 \varepsilon_{t+1} + \beta_2\varepsilon_{t} + \cdots + \beta_q \varepsilon_{t+2-q}\]</span></p><p>给定 <span class="math inline">\(\Omega_t = \{r_t, r_{t-1},\cdots\}\)</span> 的条件下，<span class="math inline">\(r_{t+2}\)</span>的点预测为：</p><p><span class="math display">\[\hat{r}_t(2) = {E}(r_{t+2}|\Omega_t) = c_0 + \beta_2 \varepsilon_t +\cdots + \beta_q \varepsilon_{t+2-q}\]</span></p><p>预测误差为：</p><p><span class="math display">\[e_t(2) = r_{t+2} - \hat{r}_t(2) = \varepsilon_{t+2} + \beta_1\varepsilon_{t+1}\]</span></p><p>向前 2 步预测误差的方差为：</p><p><span class="math display">\[\text{Var}(e_t(2)) = \text{Var}(\beta_1 \varepsilon_{t+1} +\varepsilon_{t+2}) = (1+\beta_1^2)\sigma^2\]</span></p><p>如果 <span class="math inline">\(\varepsilon_t\)</span>服从正态分布，则 95%置信水平下向前 2 步区间预测为</p><p><span class="math display">\[[\hat{r}_t(2)-1.96\sqrt{1+\beta_1^2}\sigma,\hat{r}_t(2)+1.96\sqrt{1+\beta_1^2}\sigma]\]</span></p><ol start="4" type="1"><li><strong>MA 模型向前 k 步预测：</strong></li></ol><p><span class="math display">\[r_{t+k} = c_0 + \varepsilon_{t+k} + \beta_1 \varepsilon_{t+k-1} + \cdots+ \beta_q \varepsilon_{t+k-q}\]</span></p><p>给定信息集 <span class="math inline">\(\Omega_t = \{r_t, r_{t-1},\ldots\}\)</span> 时：</p><p><span class="math display">\[\hat{r}_t(k) = {E}(r_{t+k}|\Omega_t)\]</span></p><ul><li><strong>短期预测（<span class="math inline">\(k \leqq\)</span>）</strong>：</li></ul><p><span class="math display">\[\hat{r}_t(k) = c_0 + \beta_k \varepsilon_t + \beta_{k+1}\varepsilon_{t-1} + \cdots + \beta_q \varepsilon_{t+1-q}\]</span></p><ul><li><strong>长期预测（<span class="math inline">\(k &gt;q\)</span>）</strong>：</li></ul><p><span class="math display">\[\hat{r}_t(k) = c_0 \quad (\text{等于模型均值})\]</span></p><h5 id="23543-arma-模型的向前-k-步预测">2.3.5.4.3 ARMA 模型的向前 k步预测</h5><ol type="1"><li><strong>ARMA 向前一步预测</strong></li></ol><p><span class="math display">\[r_{t+1} = a_0 + a_1 r_t + \cdots + a_p r_{t+1-p} + \varepsilon_{t+1} +\beta_1 \varepsilon_t + \cdots + \beta_q \varepsilon_{t+1-q}\]</span></p><p>给定 <span class="math inline">\(\Omega_t = \{r_t, r_{t-1},\cdots\}\)</span> 的条件下，<span class="math inline">\(r_{t+1}\)</span>的点预测为：</p><p><span class="math display">\[\hat{r}_t(1) = a_0 + a_1 r_t + \cdots + a_p r_{t+1-p} + \beta_1\varepsilon_t + \cdots + \beta_q \varepsilon_{t+1-q}\]</span></p><p>预测误差的方差为：</p><p><span class="math display">\[\text{var}(e_t(1)) = \text{var}(\varepsilon_{t+1}) = \sigma^2\]</span></p><p>如果 <span class="math inline">\(\varepsilon_t\)</span>服从正态分布，则 95%置信水平下 <spanclass="math inline">\(r_{t+1}\)</span> 向前 1 步区间预测为：</p><p><span class="math display">\[[\hat{r}_t(1) - 1.96\sigma, \hat{r}_t(1) + 1.96\sigma]\]</span></p><ol start="2" type="1"><li><strong>ARMA 向前 k 步预测</strong></li></ol><p><span class="math display">\[r_{t+k} = a_0 + a_1 r_{t+k-1} + \cdots + a_p r_{t+k-p} +\varepsilon_{t+k} + \beta_1 \varepsilon_{t+k-1} + \cdots + \beta_q\varepsilon_{t+k-q}\]</span></p><p>给定信息集 <span class="math inline">\(\Omega_t = \{r_t, r_{t-1},\cdots\}\)</span> 时，点预测：</p><p><span class="math display">\[\hat{r}_t(k) = {E}(r_{t+k}|\Omega_t)\]</span></p><p>当 <span class="math inline">\(k &gt; \max(p,q)\)</span>时，简化为：</p><p><span class="math display">\[\hat{r}_t(k) = a_0 + a_1 \hat{r}_t(k-1) + \cdots + a_p \hat{r}_t(k-p)\]</span></p><p>当 <span class="math inline">\(k \to \infty\)</span> 时，</p><p><span class="math display">\[\hat{r}_t (\infty) = a_0 + a_1 \hat{r}_t (\infty) + a_2 \hat{r}_t(\infty) + \cdots + a_p \hat{r}_t (\infty)= \frac{a_0}{1 - a_1 - a_2 -\cdots - a_p} = \mathbb{E}(r_t)\]</span></p><p>预测误差为：</p><p><span class="math display">\[e_t (k) = a_1 e_t (k-1) + a_2 e_t (k-2) + \cdots + a_p e_t (k-p) +\varepsilon_{t+k} + \beta_1 \varepsilon_{t+k-1} + \cdots + \beta_q\varepsilon_{t+k-q}\]</span></p><p><strong>小结：任何 ARMA(p, q) 过程的预测最终都将满足 p阶差分方程。这个差分方程由模型的齐次部分构成。多步提前预测将会收敛于序列长期均值。</strong></p><blockquote><p>[!note] 【拓展】ARMA(1,1)模型的脉冲反应 此前我们在 <ahref="#2.3.5.4.1%20AR模型的向前%20k%20步预测">2.3.5.4.1 AR 模型的向前 k步预测</a> 中介绍了脉冲响应函数。 对于 AR(1) 模型，通过将 AR模型转换为无限阶移动平均形式，得到对 t+k 期的预测</p><p><span class="math display">\[r_{t+k} = \frac{a_0}{1 - a_1} + \sum_{i=0}^\infty a_1^i\varepsilon_{t+k-i}\]</span></p><p>那么，如果是 ARMA(1,1)模型呢？</p><p><span class="math display">\[r_t = a_0 + a_1 r_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1},\quad \varepsilon_t \sim i.i.d. N(0, \sigma^2)\]</span></p><ul><li><strong>1 阶递推：</strong> <span class="math inline">\(r_{t-1} =a_0 + a_1 r_{t-2} + \varepsilon_{t-1} + \beta_1\varepsilon_{t-2}\)</span></li></ul><p><span class="math display">\[\begin{split} r_t &amp;= a_0 + a_1(a_0 + a_1 r_{t-2} + \varepsilon_{t-1}+ \beta_1 \varepsilon_{t-2}) + \varepsilon_{t} + \beta_1\varepsilon_{t-1} \\ &amp;= a_0 (1 + a_1) + a_1^2 r_{t-2} +\varepsilon_t + (\beta_1 + a_1) \varepsilon_{t-1} + a_1 \beta_1\varepsilon_{t-2}\end{split}\]</span></p><ul><li><strong>2 阶递推：</strong></li></ul><p><span class="math display">\[r_t = a_0 (1 + a_1 + a_1^2) + a_1^3 r_{t-3} + \varepsilon_t + (\beta_1 +a_1) \varepsilon_{t-1} + (\beta_1 + a_1) a_1 \varepsilon_{t-2} + \beta_1\varepsilon_{t-3}\]</span></p><ul><li><strong>无限阶 MA 表示：</strong></li></ul><p><span class="math display">\[r_t = \frac{a_0}{1 - a_1} + \varepsilon_t + \sum_{j=1}^{\infty} (\beta_1+ a_1) a_1^{j-1} \varepsilon_{t-j}\]</span></p><p><span class="math display">\[r_{t+k} = \frac{a_0}{1 - a_1} + \varepsilon_{t+k} + \sum_{j=1}^{\infty}(\beta_1 + a_1) a_1^{j-1} \varepsilon_{t+k-j}\]</span></p><p>因此，<span class="math inline">\(t\)</span> 期冲击 <spanclass="math inline">\(\varepsilon_t\)</span> 对 <spanclass="math inline">\(t + k\)</span> 期收益率 <spanclass="math inline">\(r_{t+k}\)</span> 的贡献为</p><p><span class="math display">\[\frac{\partial r_{t+k}}{\partial a_t} =  \begin{cases} 1, &amp; k=0 \\(a_1 + \beta_1) a_1^{k-1}, &amp; k \geq 1 \end{cases}\]</span></p><p>对于 ARMA(p, q)模型，也可类似计算脉冲反应，但更为复杂。</p></blockquote><h5 id="23544-样本区间外预测评价">2.3.5.4.4 样本区间外预测评价</h5><p>一般来讲，我们有多个看似合理的模型可供选择用于预测。千万不要认为拟合优度最高的模型预测效果就最好。我们关注的问题是：<strong>如何确定多个合理的模型中的哪个模型的预测效果最好？</strong></p><p><strong>方法一：对备选模型进行直接检验。</strong> 做法：</p><ol type="1"><li>从估计过程中保留部分观测值，在缩短的数据跨度上估计替代模型。</li><li>使用这些估计值预测保留期的观测值。</li><li>比较两个模型预测误差的特性。 示例：若 <spanclass="math inline">\(y_t\)</span> 共含 150 个观测值，需要确定 AR (1) 和MA (1) 中哪个模型能最好地描述序列的趋势。</li></ol><ul><li>使用前 100 个观测值估计 AR (1) 和 MA (1) 模型，并分别预测 <spanclass="math inline">\(y_{101}\)</span> 的值。构建 AR (1) 和 MA (1)模型获得的预测误差。</li><li>使用前 101 个观测值重新估计 AR (1) 和 MA (1)模型，再构建两个预测误差。</li><li>持续该过程，最终获得两个各含 50个观测值的一步向前预测误差序列。</li></ul><p><strong>方法二：基于回归的预测评估方法。</strong></p><ul><li>利用 AR (1) 模型产生的 50 个预测值，估计形如 <spanclass="math inline">\(y_{100+t} = a_0 + a_1 f_{1t} + v_{1t}\)</span>的方程。若预测结果无偏，F 检验应能支持约束条件 <spanclass="math inline">\(a_0 = 0\)</span> 且 <spanclass="math inline">\(a_1 = 1\)</span>。</li><li>对 MA (1) 模型的预测结果重复此过程：使用 MA (1) 产生的 50个预测值估计 <span class="math inline">\(y_{100+t} = b_0 + b_1 f_{2t} +v_{2t}\)</span>，同样进行 F 检验。</li><li>若两个 F 检验的显著性水平相近，则可选择残差方差较小的模型。</li></ul><p><strong>方法三：最小化均方预测误差 (MSPE)方法（损失函数极大似然估计）。</strong></p><ul><li>若包含 H 个观测值，AR (1) 模型的 MSPE 可通过以下公式计算：</li></ul><p><span class="math display">\[MSPE = \frac{1}{H} \sum_{i=1}^{H} e_{1i}^2\]</span></p><ul><li>选择标准是：比较两个模型的 MSPE数值，优先选用预测误差较小的模型。通常建议使用 F 统计量确定 MSPE在统计上是否异于零，其公式就是两个 MSPE 的比值。</li><li>显然，若两模型的预测误差相同，则 F 值等于 1。较大的 F值意味着分子代表模型的预测误差明显大于分母代表的模型。</li><li><strong>然而</strong>，在相同预测效果的原假设下，MSPE 服从标准 F分布还需要满足三个前提：<ol type="1"><li>预测误差服从均值为零的正态分布；</li><li>预测误差序列不相关；</li><li>预测误差彼此不相关。</li></ol></li><li>实现这些假设并不容易：<strong>Granger-Newbold 检验</strong> 和<strong>Diebold-Mariano 检验</strong><ul><li>Granger 和 Newbold(1976) 在假设 1 和假设 2成立的条件下放宽了预测误差同时相关要求（假设 3）：若从每个模型中得到 H个提前 1步预测，则可用两个预测误差的序列生成【和序列】和【差序列】。若【和序列】和【差序列】的相关系数r 在统计上异于零，那么，当 r 为正时，分子代表模型的 MSPE 更大; 当 r为负时，分母代表模型的 MSPE 更大。</li><li><strong>【掌握：DM 检验】</strong>Diebold-Mariano(1995)扩展了放宽假设 1-3的检验，请注意：<strong>这种检验要求目标函数不是平方项。</strong></li></ul></li></ul><blockquote><p>[!tip] <strong>DM 检验的做法</strong>：</p><ul><li>在典型的误差平方均值的例子中，常把损失定义为 <spanclass="math inline">\(e_i^2\)</span>。为一般化，DM 检验用 <spanclass="math inline">\(g(e_i)\)</span> 表示第 <spanclass="math inline">\(i\)</span>期的因预测误差造成的损失。于是，损失均值为：</li></ul><p><span class="math display">\[\begin{aligned}\overline{d}&amp;=\frac{1}{H}\sum_{i=1}^{H}[g(e_{1i})-g(e_{2i})]\end{aligned}\]</span></p><ul><li>当序列 <span class="math inline">\({d_i}\)</span> 满足：（1）方差为<spanclass="math inline">\(\gamma_0\)</span>；（2）序列不相关（白噪声特性）。则：<ul><li>方差估计值：<spanclass="math inline">\(\widehat{\text{var}}(\bar{d}) =\frac{\gamma_0}{H-1}\)</span></li><li>统计量分布：<spanclass="math inline">\(\frac{\bar{d}}{\sqrt{\dfrac{\gamma_0}{H-1}}} \simt(H-1)\)</span></li></ul></li><li>在存在序列相关时，Diebold 和 Mariano 用 <spanclass="math inline">\(\gamma_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 阶 <spanclass="math inline">\(d_i\)</span> 序列的自协方差。这时，假设前 q个值不为 0，建议构造 Diebold-Mariano(DM)统计量：</li></ul><p><span class="math display">\[DM = \frac{\overline{d}}{\sqrt{\dfrac{\gamma_0 + 2\gamma_1 + \cdots +2\gamma_q}{H - 1}}}\]</span></p></blockquote><h4 id="2355-系数不随样本期改变结构性变化">2.3.5.5系数不随样本期改变（结构性变化）</h4><p>Box-Jenkins方法论的一个重要的假设是：数据生成过程的结构是不变化的（或者，就是系数不随样本期改变）。但是，我们有时怀疑数据生成过程中存在结构突变。例如，2008年金融危机对于系数可能有显著影响。<strong>怎么排除这样的担忧？</strong>—— <b> <font color="#245bdb">邹检验（Chow 检验）</font> </b></p><ul><li>Chow检验的本质：用突变前数据和突变后数据来拟合同一个模型。如果这两个模型的差异不是很大，则说明在数据生成过程中没有出现任何的结构性突变。</li><li>Chow 检验并不局限于时间序列。它是主流的<strong>组间系数差异检验方法</strong> 之一。<ahref="https://zhuanlan.zhihu.com/p/629123531">ref</a></li><li>T 个观测值分成两个子样本，Shock 之前的观测值作为第一个子样本; Shock之后的观测值为第二个子样本。分别使用两个子样本估计 ARMA模型。两个模型的残差平方和分别记为 <spanclass="math inline">\(SSR_1\)</span> 和 <spanclass="math inline">\(SSR_2\)</span>。</li><li>Chow 检验的原假设：所有的系数都对应相等。使用 F 检验，并构建 F统计量：</li></ul><p><span class="math display">\[F = \dfrac{\dfrac{\text{SSR} - \text{SSR}_1 -\text{SSR}_2}{n}}{\dfrac{\text{SSR}_1 + \text{SSR}_2}{T-2n}}\]</span></p><ul><li>式中，n 为待估参数的个数（如果包含截距项，则 n = p+q+1，否则 n =p+q）；</li><li>分子和分母的自由度分别为 n 和 (T−2n)。</li><li>如果原假设成立，系数均相等，则 <spanclass="math inline">\(SSR_1+SSR_2\)</span>等于整个样本估计的残差平方和，这时 F 统计量的值等于 0。</li><li>Chow 检验的拓展：<ul><li>Chow 检验研究的是 <strong>已知的某个固定突变时间</strong>。</li><li>如果研究者事先不知道这个突变日期，那么称为 <font color="#245bdb">内生性突变 </font>(endogenous break)。</li><li>为了确定样本中是否存在突变，那么，就应该对每个潜在的突变时间进行邹氏检验。为了确保子样本中都具有恰当数量的观测值。实际研究中，通常采用整理值10%，使得每个子样本至少存在 10%的观测值。</li></ul></li></ul><p>进一步拓展：使用 <strong>递归估计</strong> 识别时间段的突变</p><ul><li><strong>Chow检验可以识别某个时间点发生的突变，但是有些突变的出现不是瞬时的，而是时间段的。</strong>例如：计算机的应用。</li><li>我们难以识别突变出现的精确时间，即使选用某个时间点，但是突变带来的整体影响却不会马上表现出来。</li><li>最简单的方法是 <strong>递归估计</strong> 这个模型。例如，如果有 150个观测值，那么，我们可以只使用最初的 10个观测值来估计模型。估算单独系数的值，并且运用最初的 11个观测值重新估计模型。重复进行这样的过程，直到使用完全部 150个观测值。</li><li>如果系数值在某个时期突然出现了变化，那么可以怀疑在那一个时期出现了结构性突变。</li><li>但是，系数的突变或许是模型设定误差导致的偏误（而不是真实的突变）。对这个问题的改良就是在给每一个系数取值时都使用估计系数的置信区间。</li><li>构造置信区间需要用到提前 1步预测误差。如果模型非常好地拟合了数据，那么这个预测将是无偏的，这样，<strong>预测误差的和应该不会偏离0“特别远”</strong>。</li><li>Brown、Durbin 和 Evans (1975) 构造了 CUSUM统计量，来检验预测误差的和是否在统计上显著不为 0。</li></ul><p><span class="math display">\[CUSUM_N=\dfrac{\Sigma^N_{i=n} e_i(1)}{\sigma_e}\]</span></p><ul><li>n——构建第一个预测误差的时期；</li><li>T——数据集中最后一个观测值的时期；</li><li><spanclass="math inline">\(\sigma_e\)</span>——估计的预测误差的标准差。</li><li>在 5%显著水平下，CUSUM 取值约在 <spanclass="math inline">\(±0.948[(T-n)^{0.5}+2(N-n)(T-n)^{-0.5}]\)</span>区域内。</li></ul><h4 id="2356-充分拟合数据">2.3.5.6 充分拟合数据</h4><p>不同的模型可能会捕获到不同的信息，尤其是，当这些模型都能够合理地解释、但各自互不包含的时候。这时，我们难道只能武断地丢弃其他模型、仅运用“最佳的”模型进行预测吗？毫无疑问，这样做没能做到“充分拟合数据”。那怎么办呢？</p><p>我们可以构建 <b> <font color="#245bdb">【复合预测值】</font></b>——<font color="#c22b24">运用所有合理模型进行预测并取所有预测值的均值。</font></p><ol type="1"><li>复合预测值的构造：给定 <span class="math inline">\(n\)</span>个模型的提前一步预测值序列 <span class="math inline">\(\{f_{i1}, f_{i2},\ldots, f_{in}\}\)</span>，构造复合预测值为：</li></ol><p><span class="math display">\[f_{ci} = w_1 f_{i1} + w_2 f_{i2} + \cdots + w_n f_{ni}, \quad\text{其中} \sum_{i=1}^n w_i = 1\]</span></p><ol start="2" type="1"><li>复合预测值是否合理？</li></ol><ul><li>（1）复合预测中，点估计的 <strong>无偏性</strong>：若每个模型预测值无偏（<span class="math inline">\(E_{t-1}(f_{it}) =y_t\)</span>），则复合预测值也是无偏的：$ E_{t-1}(f_{ci}) = y_t$</li><li>（2）<strong>复合预测误差及其方差</strong>以两个模型的复合为例，定义模型 1 和模型 2 的预测误差分别为 <spanclass="math inline">\(e_{t1} = y_t - f_{t1}\)</span> 和 <spanclass="math inline">\(e_{t2} = y_t -f_{t2}\)</span>，则复合预测误差为：</li></ul><p><span class="math display">\[e_{ct} = w_1 e_{t1} + (1 - w_1) e_{t2} \]</span>复合预测误差的方差：<span class="math display">\[ \text{Var}(e_{ct}) =w_1^2 \text{Var}(e_{t1}) + (1 - w_1)^2 \text{Var}(e_{t2}) + 2w_1(1 -w_1) \text{Cov}(e_{t1}, e_{t2}).\]</span></p><p>假设两模型的预测误差满足：<spanclass="math inline">\(\text{Var}(e_{t1}) = \text{Var}(e_{t2}) =\sigma^2\)</span>， <span class="math inline">\(\text{Cov}(e_{t1},e_{t2}) = 0\)</span>，权重 <span class="math inline">\(w_1 =0.5\)</span>（简单平均）。则复合预测误差的方差为：</p><p><span class="math display">\[\text{Var}(e_{ct}) = 0.25\sigma^2 + 0.25\sigma^2 = 0.5\sigma^2\]</span></p><p><strong>发现</strong>：<font color="#245bdb">组合预测的方差为单一模型方差的一半，显著降低了预测不确定性。</font></p><ol start="3" type="1"><li><strong>最优权重</strong></li></ol><ul><li>尽管简单平均能减少预测误差方差，但寻找最优权重使预测误差方差最小化仍十分必要。</li><li>最优权重为：</li></ul><p><span class="math display">\[w_1^* = \dfrac{\text{var}(e_{2i}) - \text{cov}(e_{1i}e_{2i})}{\text{var}(e_{1i}) + \text{var}(e_{2i}) - 2 \text{cov}(e_{1i}e_{2i})}\]</span></p><ul><li>不包含协方差项的最优权重：</li></ul><p><span class="math display">\[w_n^* =\frac{\operatorname{var}(e_{1i})^{-1}}{\operatorname{var}(e_{1i})^{-1} +\operatorname{var}(e_{2i})^{-1} + \cdots +\operatorname{var}(e_{ni})^{-1}}\]</span></p><ul><li>Granger 和Ramanathan(1989)使用回归模型提出了一个构造权重的等效方法：</li></ul><p><span class="math display">\[Y_t = \alpha_0 + \alpha_1 f_{1 t} + \alpha_2 f_{2 t} + \cdots + \alpha_nf_{nt} + v_t\]</span></p><p>可令 <span class="math inline">\(\alpha_0=0\)</span>, <spanclass="math inline">\(\alpha_1+\alpha_2+\cdots+\alpha_n=1\)</span>。在这些条件下,<span class="math inline">\(\alpha_i\)</span> 直接解释最优权重, <spanclass="math inline">\(w_i^*\)</span> 应设置等于 <spanclass="math inline">\(\alpha_i\)</span>。</p><ul><li>运用 SBC 作为权重因素：令 <span class="math inline">\(SBC_i\)</span>表示模型 i 中的 SBC，令 <span class="math inline">\(SBC^*\)</span>表示最适模型中的 SBC。可得 <span class="math inline">\(\alpha_i =\exp\left[\dfrac{(SBC^* - SBC_i)}{2}\right]\)</span> 并构造权重：</li></ul><p><span class="math display">\[w_i^* = \frac{\alpha_i}{\sum_{i=1}^{n} \alpha_i}\]</span></p><p>最适模型权重为 <span class="math inline">\(\dfrac{1}{\sum\alpha_i}\)</span>。由于 <span class="math inline">\(\alpha_i\)</span>随 <span class="math inline">\(SBC_i\)</span> 的值减少，不太适合的模型在SBC 值较大时具有更小的权重。</p><h3 id="236-季节性模型">2.3.6 季节性模型</h3><ul><li>时间序列中的季节性是在 S个时间段内重复的常规变化模式。例如，月度数据存在季节性，高值往往总是出现在某些特定月份，而低值往往总是出现在其他特定月份。</li><li>季节性通常会导致序列不稳定，因为季节性跨度内某些特定时间（例如，月份）的平均值可能与其他时间的平均值不同。例如，我们的冷却风扇在夏季的销量将始终较高。</li><li><font color="#245bdb">季节性模型通常是乘法模型，而不是加法模型。</font>乘法模型包括一个或多个非季节性参数与一个或多个季节性参数的乘积。</li><li>具有季节性时间序列的 ARMA 模型（季节性自回归移动平均，又叫 SARMA模型）：</li></ul><p><span class="math display">\[Y_t = \theta_0 + \phi_1 Y_{t-1} + \phi_{12} Y_{t-12} - \theta_1\varepsilon_{t-1} - \theta_{12} \varepsilon_{t-12} + \varepsilon_t\]</span></p><p>其中季节性成分捕捉长期模式，非季节性成分调整了对短期变化的预测。</p><ul><li><span class="math inline">\(\theta_0\)</span> 是截距参数。</li><li><span class="math inline">\(\phi_1\)</span>是非季节性一阶自回归参数。</li><li><span class="math inline">\(\phi_{12}\)</span>是季节性自回归参数。</li><li><span class="math inline">\(\theta_1\)</span>是非季节性一阶移动平均参数。</li><li><span class="math inline">\(\theta_{12}\)</span>是季节性移动平均参数。</li><li><span class="math inline">\(\varepsilon_t\)</span> 是白噪声误差项。在实践中，使用更多的是 SARIMA 模型。这就涉及了 ARIMA模型，我们不妨将这部分内容留待 <a href="#Chapter%204">Chapter 7</a>讨论。</li></ul><h2 id="第二章练习">第二章练习</h2><h5 id="例-1信息准则">例 1：【信息准则】</h5><p><strong>判断：</strong> 根据下表，利用 AIC 和 BIC准则评判两个模型的相对优劣， AR (1) 模型优于 MA (2) 模型吗？（ ）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tx">| 模型   | AIC      | SBC      |<br>| ----- | -------- | -------- |<br>| MA(2) | 536.4556 | 543.2011 |<br>| AR(1) | 535.7896 | 540.2866 |<br></code></pre></td></tr></table></figure><p>Ans： True.</p><h5 id="例-2白噪声检验">例 2：【白噪声检验】</h5><p>时间序列模型建立后，将要对模型进行显著性检验，检验的对象为（），检验的假设为？ Ans： 残差序列，原假设: 残差序列为白噪声序列Note：模型的显著性检验主要是模型的有效性。一个模型是否显著有效主要看提取的信息是否充分。一个好的拟合模型应该能够提取观察值序列中几乎所有的样本相关信息，即残差序列应该为白噪声序列。这样的模型称为显著有效模型。反之，<strong>如果残差序列为非白噪声序列，那就意味着序列中还残留着相关信息未被提取，这就说明拟合模型不够有效</strong>，通常需要选择其他模型，重新拟合。因此，模型的显著性检验就是残差序列的白噪声检验。</p><h5 id="例-3ar-模型与-yule---walker-方程">例 3：【AR 模型与 Yule -Walker 方程】</h5><ol type="1"><li><strong>求解 AR(2) 模型的未知参数：</strong> 已知 <spanclass="math inline">\(\rho_1 = 0.5\)</span>，<spanclass="math inline">\(\rho_2 = 0.3\)</span></li></ol><p><span class="math display">\[x_t=\phi_1x_{t - 1}+\phi_2x_{t - 2}+\varepsilon_t \qquad\varepsilon_t\sim WN(0,\sigma_{\varepsilon}^2)\]</span></p><p>Ans：<span class="math inline">\(\phi_1\)</span> = 7/15，<spanclass="math inline">\(\phi_2\)</span> = 1/15</p><ol start="2" type="1"><li>AR(2)模型 <spanclass="math inline">\(y_t=0.4y_{t-1}-0.5y_{t-2}+e_t\)</span>,，其中<span class="math inline">\(Var(e_{t})=0.64\)</span>，则 <spanclass="math inline">\(E(Y_te_t)=\)</span>？</li></ol><p>A.0 B.0.64 C.0.16 D.0.2</p><p>Ans：B</p><ol start="3" type="1"><li><strong>AR 模型与 Yule - Walker 方程：</strong></li></ol><ul><li><span class="math inline">\(X_t=\phi_1X_{t - 1}+\phi_2X_{t -2}+\varepsilon_t\)</span>，模型所满足的 Yule - Walker 方程是？</li><li>当 <span class="math inline">\(\phi_1 = 0.5\)</span>，<spanclass="math inline">\(\phi_2 = 0.2\)</span> ，模型所满足的 Yule - Walker方程是？</li></ul><p>Ans：<span class="math inline">\(\begin{cases}\rho_1=\phi_1\rho_0+\phi_2\rho_1\\ \rho_2=\phi_1\rho_1+\phi_2\rho_0\end{cases}\)</span>， <span class="math inline">\(\begin{cases}\rho_1=\phi_1\rho_0+\phi_2\rho_1 = 0.5 + 0.2\rho_1\\\rho_2=\phi_1\rho_1+\phi_2\rho_0 = 0.5\rho_1 + 0.2 \end{cases}\)</span>，</p><h5 id="例-4ma-模型">例 4：【MA 模型】</h5><p>确定常数 <span class="math inline">\(C\)</span>的值，保证如下表达式为 MA (2) 模型:</p><p><span class="math display">\[x_t = 10 + 0.5 x_{t - 1}+\varepsilon_t - 0.8\varepsilon_{t -2}+C\varepsilon_{t - 3}\]</span></p><p>Ans：由 MA (2) 模型可知: <spanclass="math inline">\(x_t=\mu+\varepsilon_t-\theta_1\varepsilon_{t -1}-\theta_2\varepsilon_{t - 2}\)</span>，<spanclass="math inline">\(x_{t - 1}=\mu+\varepsilon_{t -1}-\theta_1\varepsilon_{t - 2}-\theta_2\varepsilon_{t - 3}\)</span>联立得: <span class="math inline">\(x_t - 0.5 x_{t -1}=0.5\mu+\varepsilon_t-(\theta_1 + 0.5)\varepsilon_{t - 1}-(\theta_2 -0.5\theta_1)\varepsilon_{t - 2}+0.5\theta_2\varepsilon_{t - 3}\)</span>即: <span class="math inline">\(0.5\mu = 10\)</span>，<spanclass="math inline">\(\theta_1 + 0.5 = 0\)</span>，<spanclass="math inline">\(\theta_2 - 0.5\theta_1 = 0.8\)</span>，<spanclass="math inline">\(0.5\theta_2 = C\)</span> 解得: <spanclass="math inline">\(\mu = 20\)</span>，<spanclass="math inline">\(\theta_1 = - 0.5\)</span>，<spanclass="math inline">\(\theta_2 = 0.55\)</span>，所以 <spanclass="math inline">\(C = 0.275\)</span></p><h5 id="例-5平稳性可逆性">例 5：【平稳性、可逆性】</h5><p>判断 ARMA 模型平稳性和可逆性：</p><ul><li><span class="math inline">\(Y_t = 0.8Y_{t - 1}+e_t - 0.4e_{t -1}\)</span></li><li><span class="math inline">\(Y_t = 0.8Y_{t - 1}+1.4Y_{t - 2}+e_t +1.6e_{t - 1}+0.5e_{t - 2}\)</span></li></ul><p>Ans：</p><ul><li>AR 模型： <span class="math inline">\(\phi_1 = 0.8 &lt; 1\)</span>，MA 模型： <span class="math inline">\(\theta_1 = 0.4 &lt; 1\)</span>所以该模型平稳可逆</li><li>AR 模型： <span class="math inline">\(\phi_1 = 0.8\)</span>，<spanclass="math inline">\(\phi_2 = - 1.4\)</span>，<spanclass="math inline">\(|\phi_2|&gt;1\)</span> 。不平稳。MA 模型： <spanclass="math inline">\(\theta_1 = 1.6\)</span>，<spanclass="math inline">\(\theta_2 = 0.5\)</span>，<spanclass="math inline">\(|\theta_2|&lt;1\)</span>， <spanclass="math inline">\(\theta_2+\theta_1 = 2.1&gt;1\)</span>。不可逆。</li></ul><h5 id="例-6acf-与-pacf">例 6：【ACF 与 PACF】</h5><ol type="1"><li>若零均值平稳序列的样本 ACF 和样本 PACF都呈现拖尾性。则可能建立的模型是： A.MA (2) B.ARMA (1, 1) C.AR (2) D.MA(1)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tx">| 模型  | 自相关系数 | 偏自相关系数 |<br>| --- | ----- | ------ |<br>|AR (p)|拖尾|p 阶截尾|<br>| MA (q)|q 阶截尾|拖尾 |<br>|ARMA (p, q)|拖尾|拖尾|<br></code></pre></td></tr></table></figure><p>Ans：B</p><ol start="2" type="1"><li>对于一阶滑动平均模型 MA (1)：<spanclass="math inline">\(Y=e_t-0.5e_{t-1}\)</span>，其一阶自相关函数为（）</li></ol><p>A. -0.5 B. 0.25 C. -0.4 D. 0.8</p><p>Ans：C ，对于 MA(1) 模型，ACF 为： <spanclass="math inline">\(\rho_{0} = 1\)</span>， <spanclass="math inline">\(\rho_{1} = \beta / (1 + \beta^{2})\)</span> ，<span class="math inline">\(\rho_{s} = 0, (s &gt; 1)\)</span></p><ul><li>补充设问：其 PACF 是多少？（Hint：MA(1) 的 PACF = ACF）</li></ul><h5 id="例-7区间外预测">例 7：【区间外预测】</h5><ol type="1"><li>己知某序列 <span class="math inline">\(Y_t\)</span> 服从 MA (2)模型： <span class="math inline">\(Y_t=40+e_t-0.6 e_{t-1}+0.8e_{t-2}\)</span> 若 <span class="math inline">\(\sigma^2=20\)</span>，<span class="math inline">\(e_t=2\)</span>，<spanclass="math inline">\(e_{t-1}=-4\)</span>，<spanclass="math inline">\(e_{t-2}=-6\)</span> (a) 预测未来 2 期的值: (b)求出未来两期预测值的 95%的预测区间。</li></ol><p>（a）</p><p><span class="math display">\[\begin{split}\hat{Y}_t(1) =&amp; E(Y_{t+1} | Y_1, Y_2, \dots, Y_t)\\=&amp; E(40 + e_{t+1} - 0.6e_t + 0.8e_{t-1} | Y_1, Y_2, \dots, Y_t)\\=&amp; 40 - 0.6e_t + 0.8e_{t-1} = 40 - 0.6×2 + 0.8×(-4) =35.6\end{split}\]</span></p><p><span class="math display">\[\begin{split}\hat{Y}_t(2) =&amp; E(Y_{t+2} | Y_1, Y_2, \dots, Y_t)\\=&amp; E(40 + e_{t+2} - 0.6e_{t+1} + 0.8e_t | Y_1, Y_2, \dots, Y_t)\\=&amp; 40 + 0.8e_t = 40 + 0.8×2 = 41.6\end{split}\]</span></p><p>（b） 首先，根据公式 <span class="math inline">\(Var[e_t(l)] =\sigma_e^2 \sum_{j=0}^{l - 1} \psi_j^2\)</span> 计算预测误差方差：</p><ul><li>当 <span class="math inline">\(l = 1\)</span> 时，<spanclass="math inline">\(\sum_{j=0}^{0} \psi_j^2 = \psi_0^2 =1\)</span>，则 <span class="math inline">\(Var[e_t(1)] = 20×1 =20\)</span>。</li><li>当 <span class="math inline">\(l = 2\)</span> 时，<spanclass="math inline">\(\sum_{j=0}^{1} \psi_j^2 = \psi_0^2 + \psi_1^2 = 1+ (-0.6)^2 = 1.36\)</span>，则 <span class="math inline">\(Var[e_t(2)] =20×1.36 = 27.2\)</span>。</li><li>然后，利用 95% 预测区间公式 <spanclass="math inline">\((\hat{Y}_t(l) - z_{0.025} \sqrt{Var[e_t(l)]},\hat{Y}_t(l) + z_{0.025} \sqrt{Var[e_t(l)]})\)</span>，其中 <spanclass="math inline">\(z_{0.025} = 1.96\)</span>。</li><li>对于第一期，<span class="math inline">\(\hat{Y}_t(1) =35.6\)</span>，<span class="math inline">\(\sqrt{20} ≈4.4721\)</span>，<span class="math inline">\(1.96×4.4721 ≈8.7653\)</span>，预测区间为 <span class="math inline">\((35.6 - 8.7653,35.6 + 8.7653) ≈ (26.8346, 44.3654)\)</span>。</li><li>对于第二期，<span class="math inline">\(\hat{Y}_t(2) =41.6\)</span>，<span class="math inline">\(\sqrt{27.2} ≈5.2154\)</span>，<span class="math inline">\(1.96×5.2154 ≈10.2222\)</span>，预测区间为 <span class="math inline">\((41.6 -10.2222, 41.6 + 10.2222) ≈ (31.3779, 51.8221)\)</span>。</li><li>综上，未来第一期预测区间 <span class="math inline">\((26.8346,44.3654)\)</span>，未来第二期预测区间 <spanclass="math inline">\((31.3779, 51.8221)\)</span>。</li></ul><ol start="2" type="1"><li>AR (1) 模型: <span class="math inline">\(x_t-\mu=\phi_1 (x_{t -1}-\mu)+\varepsilon_t\)</span>，已求出 <spanclass="math inline">\(\hat{\mu}=10\)</span>，<spanclass="math inline">\(\hat{\phi}_1 = 0.3\)</span>，<spanclass="math inline">\(\hat{\sigma}_{\varepsilon}^2 = 9\)</span>，求<span class="math inline">\(x_{t + 3}\)</span> 的 95%的置信区间。</li></ol><ul><li>Ans：(3.84, 16.16)</li></ul><h1 id="chapter-3-包含趋势的模型">Chapter 3: 包含趋势的模型</h1><blockquote><p>[!important] 本章学习目标</p><ol type="1"><li>形式化均值依赖于时间的变量的简单模型。</li><li>比较确定性趋势和随机趋势。</li><li>阐述标准回归和时间序列模型中的单位根问题，</li><li>阐述蒙特卡洛试验和模拟法如何得出假设检验的临界值。</li><li>提出并阐述用于检验是否存在单位根的 DF 检验和 ADF 检验。</li><li>将 DF 检验应用到美国 GDP 和汇率的实例中。</li><li>阐述 DF 检验在序列相关性、MA模型、多元单位根、季节性单位根中的应用。</li><li>考察存在结构性变化的单位根检验。</li><li>阐述标准 DF 检验的缺陷。</li><li>阐述广义最小二乘法对 DF 检验的提升。</li><li>阐述如何用面板单位根检验来促进 DF 检验</li><li>把包含趋势的序列分解为平稳和趋势两个部分。</li></ol></blockquote><h2 id="31-趋势建模">3.1 趋势建模</h2><p>在第 <a href="#Chapter%202%20平稳时间序列模型">2</a>章，我们只讨论了平稳的时间序列。在本章，我们介绍<strong>非平稳时间序列的处理方法</strong>。实际上，在自然界中绝大部分序列都是非平稳的，因而对非平稳序列的分析更普遍、更重要。</p><p>对于一个一般化的时间序列，最常用的确定性分析方法是确定性因素分解方法。</p><ul><li>该方法把所有序列的变化都归结为 4 个因素的综合影响：<ul><li>长期趋势 T。该因素的影响会导致序列呈现出明显的长期趋势(递增、递减等)。</li><li>循环波动C。该因素会导致序列呈现出从低到高再由高至低的反复循环波动。</li><li>季节性变化S。该因素会导致序列呈现出和季节变化相关的稳定的周期波动。</li><li>随机波动I。除了长期趋势、循环波动和季节性变化之外，序列还会受到各种其他因素的综合影响，而这些影响导致序列呈现出一定的随机波动。</li></ul></li></ul><p>人们在实际分析中进行了改进和简化，可以把序列分解为三大因素的综合影响：</p><ol type="1"><li>长期趋势波动，它包括长期趋势和无固定周期的循环波动。</li><li>季节性变化，它包括所有具有稳定周期的循环波动。</li><li>随机波动，除了长期趋势波动和季节性变化之外，其他因素的综合影响归为随机波动。</li></ol><p>通过乘法分解，我们可以将任何一个序列表示为各个因素的乘积；通过加法分解，我们可以将任何一个序列表示为各个因素的加总。</p><p>能否再进一步简化呢？当然是可以的。我们可以暂不具体划分确定性趋势，这样就得到：<b><span style="background:#fff88f">任何一个序列的波动都可以视为同时受到了确定性影响和随机性影响的综合作用</span></b>。</p><ul><li>要证明这一结论，就要涉及 <strong>Cramer 分解定理</strong>。对于Cramer分解定理的详细证明，可以参考中国人民大学统计学院王燕老师编著的《应用时间序列分析》，就不在此赘述了。</li><li>Cramer 分解定理扩展自我们在 <a href="#2.2.1%20Wold%20分解定理">第2.2.1 节</a> 介绍的 Wold 分解定理，它将 Wold分解定理的分解思路扩展到了非平稳序列。</li><li>从 Cramer分解定理的结论引申，我们可以得到：平稳序列要求确定性影响和随机性影响都是稳定的，序列非平稳的原因就是这两方面的影响至少有一方面不稳定。</li></ul><p>在下面的分析中，我们先使用最简化的组成方式进行讨论。在进一步讨论之前，我们应当先认识下确定性趋势和随机趋势的表现形式：</p><ol type="1"><li>确定性趋势：从某个时期开始到下一个时期，一个序列总是变化固定相同的量：</li></ol><p><span class="math display">\[\Delta y_t= a_0  \quad \Rightarrow \quad y_t=y_0+a_0t\]</span></p><p>其中 <span class="math inline">\(y_0\)</span> 是第 0 期的初始值。 2.随机趋势：从某个时期开始到下一个时期，序列的变化量是白噪声：</p><p><span class="math display">\[\Delta y_t= \varepsilon_t  \quad \Rightarrow \quady_t=y_0+\sum_{i=1}^t\varepsilon_i\]</span></p><p>这被称为 <b> <font color="#245bdb"> 随机游走模型 </font> </b>（randomwalk），它在经济学和金融学中有着特殊的地位。一个非常典型的例子就是有效市场假设对股价随机游走的假定。</p><h2 id="32-随机趋势">3.2 随机趋势</h2><p>本节我们对随机游走进行进一步分析。对于随机游走的时间序列，<spanclass="math inline">\(y_t\)</span> 表示为白噪声项的累积和</p><p><span class="math display">\[\Delta y_t= \varepsilon_t  \quad \Rightarrow \quady_t=y_0+\sum_{i=1}^t\varepsilon_i\]</span></p><ol type="1"><li><p>随机游走的均值 由于每个 <spanclass="math inline">\(\varepsilon\)</span> 的均值都为 0，<spanclass="math inline">\(E(y_t)=y_0\)</span></p></li><li><p>随机游走的方差 由于白噪声项 <spanclass="math inline">\(\varepsilon_i\)</span> 不相关且方差相同（设为<spanclass="math inline">\(\sigma^2\)</span>），根据方差叠加性质：</p></li></ol><p><span class="math display">\[\text{var}(y_t) = \text{var}(\varepsilon_1) + \text{var}(\varepsilon_2)+ \cdots + \text{var}(\varepsilon_t) = t \cdot \sigma^2\]</span></p><p>方差 <span class="math inline">\(\text{var}(y_t)\)</span>随时间线性增长，表明随机游走序列是 <strong>非平稳时间序列</strong>。</p><ol start="3" type="1"><li>随机游走的自相关系数（滞后 k 期）</li></ol><p><span class="math display">\[\rho_k(t) = \frac{\text{Cov}(y_t, y_{t-k})}{\sqrt{\text{Var}(y_t) \cdot\text{Var}(y_{t-k})}}\]</span></p><p>由于方差 <span class="math inline">\(\text{Var}(y_t) =t\sigma^2\)</span>，协方差 <span class="math inline">\(\text{Cov}(y_t,y_{t-k}) = (t - k)\sigma^2\)</span>，代入得：</p><p><span class="math display">\[\rho_k(t) = \frac{(t - k)\sigma^2}{\sqrt{t\sigma^2 \cdot (t -k)\sigma^2}} = \sqrt{1 - \frac{k}{t}}\]</span></p><p>现在，我们将确定性趋势和随机趋势结合，得到<strong>带漂移的随机游走模型</strong></p><p><span class="math display">\[\Delta y_t= a_0+\varepsilon_t  \quad \Rightarrow \quady_t=y_0+a_0t+\sum_{i=1}^t\varepsilon_i\]</span></p><ul><li>这里 <span class="math inline">\(y_t\)</span>的表现受线性确定性趋势和随机趋势这两个非平稳成分的影响。</li><li>带漂移的随机游走模型是一个纯趋势模型。</li></ul><p>更一般化地，我们可以再加入一个噪声项，得到：<strong>带噪声的趋势模型</strong></p><p><span class="math display">\[y_t=y_0+a_0t+\sum_{i=1}^t\varepsilon_i+\eta_t\]</span></p><ul><li>它是确定性趋势、随机趋势和白噪声之和。</li><li>噪声序列并不要求一定是白噪声过程。</li></ul><h2 id="33-确定性趋势">3.3 确定性趋势</h2><p>包含趋势的序列和平稳序列之间是有很大区别的。<strong>对平稳时间序列的冲击必然是短暂的，随时间推移，冲击的影响将消失，序列将回复到其长期均值水平。而对于包含趋势的序列，冲击后并不会回复到长期水平。</strong>因此，对于包含趋势的时间序列，我们需要去除趋势来转化为平稳的时间序列，进而使用第<a href="#Chapter%202%20平稳时间序列模型">2</a> 章的方法进行分析。</p><p>去除趋势影响的常规方法是 <strong>差分</strong> (diferencing) 和<strong>去除趋势</strong> (detrending)。</p><ul><li><strong>去除趋势</strong>（detrending）操作必须作时间 <spanclass="math inline">\(t\)</span> 对变量 <spanclass="math inline">\(y_t\)</span> 的回归，并保留残差值。</li><li>一个包含单位根的序列可以通过<strong>差分</strong>（diferencing）变得平稳。</li></ul><h3 id="331-差分">3.3.1 差分</h3><p>首先，考查带漂移的随机游走模型</p><p><span class="math display">\[y_t=y_0+a_0t+\sum_{i=1}^t\varepsilon_i\]</span></p><p>取 1 阶差分，得到</p><p><span class="math display">\[\Delta y_t= a_0+\varepsilon_t\]</span></p><p>可以看出，<span class="math inline">\(\Delta y_t\)</span>是平稳的时间序列，满足弱平稳的三大要求：</p><ol type="1"><li>均值 <span class="math inline">\(a_0\)</span> 恒定：<spanclass="math inline">\(E(\Delta y_t) = E(a_0 + \varepsilon_t) =a_0\)</span></li><li>方差 <span class="math inline">\(\sigma^2\)</span> 恒定，<spanclass="math inline">\(\text{Var}(\Delta y_t) = \text{Var}(\varepsilon_t)= \sigma^2\)</span></li><li>协方差仅由时间间隔决定。如果成立，对于滞后 <spanclass="math inline">\(s \neq 0\)</span> 协方差，仅与滞后阶数 s有关，与具体时间 t 无关：</li></ol><p><span class="math display">\[\text{cov}(\Delta y_t, \Delta y_{t-s}) = E[(\Delta y_t - a_0)(\Deltay_{t-s} - a_0)] = E(\varepsilon_t \varepsilon_{t-s}) = 0\]</span></p><p>协方差为 0，与 <span class="math inline">\(t\)</span>无关，表明序列无自相关（白噪声特性）。</p><p>我们可以将结论推广到带噪声的随机游走模型，如感兴趣可在教材 4.2.1节查看具体证明。</p><h3 id="332-去除趋势">3.3.2 去除趋势</h3><p>所有非平稳模型都能够通过差分转化为平稳的吗？答案是否定的。考虑下面这个模型：</p><p><span class="math display">\[y_t = y_0 + a_1 t + \varepsilon_t \quad \to \quad \Delta y_t = y_t -y_{t-1} = a_1 + \varepsilon_t - \varepsilon_{t-1}\]</span></p><ul><li>差分后序列 <span class="math inline">\(\Delta y_t\)</span> 的表达式<span class="math inline">\(a_1 + \varepsilon_t -\varepsilon_{t-1}\)</span> 是 MA (1) 过程。</li><li><strong>但其移动平均系数为 1，无法转换为 AR形式，违背了可逆性条件</strong>。</li><li>关于可逆性，请回顾 <a href="#2.3.5.2%20可逆性"> 第 2.3.5.2 节</a>关于可逆性的讨论。也就是，MA(1) 中 <spanclass="math inline">\(\varepsilon_{t-1}\)</span> 的系数应小于 1。</li></ul><p>怎么办？—— <strong>替代方法：回归去趋势</strong>。步骤：</p><ol type="1"><li><strong>估计趋势项</strong>：用回归模型拟合趋势，例如： <spanclass="math inline">\(Y_t = a_0 + a_1 t + a_2 t^2 + \cdots + a_n t^n +e_t\)</span></li><li><strong>提取残差</strong>：计算残差序列 <spanclass="math inline">\(e_t = y_t - \hat{y}_t\)</span>，其中 <spanclass="math inline">\(\hat{y}_t\)</span> 为趋势估计值。</li><li><strong>分析平稳性</strong>：若残差序列 <spanclass="math inline">\(\{e_t\}\)</span> 平稳，可对其建立 ARMA 模型。多项式恰当的阶数可以由标准 t 检验、F 检验和 AIC 或 SBC统计量来确定。这一方法的优势是：避免差分导致的模型不可逆问题，直接分离趋势与平稳噪声。</li></ol><p>上面案例中的时间序列正是一个带有 <strong>单位根</strong> 的序列。在第<a href="#2.3.3.1%20自相关函数（ACF）">2.3.3.1</a>节中，我们曾剧透过：</p><ul><li><font color="#245bdb"> <b> 平稳时间序列 </b> 和 <b>单位根非平稳时间序列 </b>是值得研究的，而其他不平稳时间序列不常见也不值得研究。</font></li><li>我们在第 <a href="#Chapter%202%20平稳时间序列模型">2</a>章已经介绍了平稳时间序列。什么是 <strong>单位根非平稳时间序列</strong>呢？</li></ul><blockquote><blockquote><p>[!Note] <strong>什么是单位根？</strong> 带有 <strong>单位根</strong>的序列，称为差分平稳 (difference stationary)序列，可以通过差分转化为平稳序列。给定模型：</p></blockquote><p><span class="math display">\[r_t = \phi_0 + \phi_1 r_{t-1} + a_t \qquad a_t \sim i.i.d\]</span></p><p>根据 <span class="math inline">\(\phi_1\)</span>的取值，序列的平稳性可分为以下三类：</p><ol type="1"><li><strong><span class="math inline">\(|\phi_1| &lt;1\)</span>：平稳时间序列</strong></li></ol><ul><li><strong>平稳性条件</strong>：<ul><li>特征方程 <span class="math inline">\(1 - \phi_1 B = 0\)</span> 的根<span class="math inline">\(B =\dfrac{1}{\phi_1}\)</span> 在单位圆外（<span class="math inline">\(|\phi_1| &lt; 1\)</span>，故 <spanclass="math inline">\(|B| &gt; 1\)</span>）。</li></ul></li><li><strong>统计特性</strong>：</li><li>均值收敛至 <span class="math inline">\(\mu = \dfrac{\phi_0}{1 -\phi_1}\)</span>，</li><li>方差恒定：<span class="math inline">\(\text{var}(r_t) =\dfrac{\sigma_a^2}{1 - \phi_1^2}\)</span>，</li><li>自相关系数（ACF）按几何速率衰减（如 <spanclass="math inline">\(\rho_k = \phi_1^k\)</span>）。</li><li><strong>示例</strong>：AR (1) 模型（如 <spanclass="math inline">\(\phi_1 = 0.8\)</span>）。</li></ul><ol start="2" type="1"><li><strong><span class="math inline">\(|\phi_1| =1\)</span>：单位根非平稳时间序列</strong></li></ol><ul><li><strong>特性</strong>：</li><li>特征方程的根 <span class="math inline">\(B=\dfrac{1}{\phi_1}\)</span> 在单位圆上（因 <spanclass="math inline">\(|\phi_1| = 1\)</span>），</li><li>方差随时间线性增长：<span class="math inline">\(\text{var}(r_t) = t\sigma_a^2\)</span>，</li><li>自相关系数缓慢衰减（如 <span class="math inline">\(\rho_k \approx\sqrt{1 - k/t}\)</span>）。</li><li><strong>典型模型</strong>：随机游走 <span class="math inline">\(r_t= r_{t-1} + a_t\)</span>（<span class="math inline">\(\phi_1 =1\)</span>）。</li><li><strong>处理方法</strong>：通过一阶差分 <spanclass="math inline">\(\Delta r_t = a_t\)</span> 转为平稳序列。</li></ul><ol start="3" type="1"><li><strong><span class="math inline">\(|\phi_1| &gt;1\)</span>：爆炸性非平稳时间序列</strong></li></ol><ul><li><strong>特性</strong>：<ul><li>特征方程的根 <span class="math inline">\(B=\dfrac{1}{\phi_1}\)</span> 在单位圆内（因 <spanclass="math inline">\(|\phi_1| &gt; 1\)</span>），</li><li>方差随时间指数增长，序列值迅速发散，无实际应用意义。</li></ul></li><li><strong>示例</strong>：<span class="math inline">\(\phi_1 =1.2\)</span> 时，序列呈爆炸性增长。</li></ul></blockquote><h2 id="34-样本平稳性检验">3.4 样本平稳性检验</h2><p>当拿到一个时间序列后，应该如何对其进行平稳性的检验呢？目前，对时间序列的平稳性检验主要有两种方法：</p><ul><li><ul><li>一种是图像法，即根据时序图和自相关图进行直观判断，</li></ul></li><li>另一种是构造检验统计量进行单位根检验，有 ADF 检验、PP 检验和 KPSS检验等方法。</li></ul><p>检验观测数据平稳性时，通常假设观测数据是单位根非平稳的，而备择假设是观测数据是平稳的，因此<strong>平稳性检验是单侧检验</strong>。</p><h3 id="341-图像法">3.4.1 图像法</h3><p>在具体的假设检验之前，我们可以先将数据可视化，绘制时间序列的折线图，看曲线是否围绕某一数值上下波动（判断均值是否稳定）、曲线上下波动幅度变化大不大（判断方差是否稳定）、曲线不同时间段波动的频率变化大不大（判断协方差是否稳定），以此来判断时间序列是否平稳。</p><h4 id="3411-迹图">3.4.1.1 迹图</h4><p>迹图是待检验样本的时间图。 <img src="迹图.png" /></p><ul><li>第一幅图，我们可以清楚地看到，均值随时间而变化，呈现上升的趋势。因此，这是一个非平稳序列。平稳序列不应该呈现出随时间变化的趋势。</li><li>第二幅图，我们看不到序列的趋势，但序列的变化幅度是一个时间的函数。平稳序列的方差必须是一个常数。</li><li>第三幅图，随着时间的增加，序列传播后变得更近，这意味着协方差是时间的函数。</li><li>所以上述三个例子均是非平稳时间序列。</li><li>第四幅图，均值、方差和协方差都是常数，这就是平稳时间序列。</li></ul><h4 id="3412-acf-和-pacf-图">3.4.1.2 ACF 和 PACF 图</h4><p>我们也可以绘制时间序列的自相关图和偏自相关图来了解序列平稳性。</p><ul><li>平稳序列通常具有短期相关性，对于平稳的时间序列，自相关系数往往会迅速退化到零（滞后期越短相关性越高，滞后期为0 时，相关性为 1）；</li><li>而对于非平稳的数据，退化会发生得更慢，或存在先减后增或者周期性的波动等变动。<img src="ACF和PACF确定平稳性.png" /></li><li>白噪声的自相关系数很快就衰减到 0 附近，是明显的平稳序列。滞后期为 0时自相关系数和偏自相关系数其实就是序列自己和自己的相关性，故为1；滞后期为 1 时，自相关系数为 0，表示白噪声无自相关性。</li><li>随机游走，自相关系数下降非常缓慢，故为非平稳序列；另从偏自相关系数中可以看到随机游走只和前一项有关。</li><li>GDP 数据的自相关图中也可以看到存在一定的周期性，滞后 4、8、12等自相关系数较大下降较慢，差分后下降多一些起到一定效果，认为差分后序列是平稳的。</li></ul><h4 id="3413-伪相关">3.4.1.3 伪相关</h4><p>直观判断能让我们对数据有更直观的认识，但带有较强主观性。</p><ul><li>在实践中，我们通常从探索数据开始，例如绘制并计算两个变量的相关性。</li><li>我们常常注意到变量之间的某些非常强的相关性。但是这些相关性可能是没有意义的。并没有因果关系来解释这些结果。这些都是虚假相关性。</li><li>具有潜在趋势的数据很可能产生虚假的相关性，例如碳排放量的上升和变暖的全球气温之间的相关性。</li><li>除了趋势之外，时间序列的其他一些共同特征也会引入虚假相关性。如：季节性：夏天热狗消费量和溺水死亡人数的相关性。</li><li>更多关于虚假相关性的例子，请见：<ahref="http://tylervigen.com/spurious-correlations">虚假相关性的例子</a>因此，我们需要经济直觉，也需要一些更严谨的假设检验。</li></ul><h3 id="342-假设检验法">3.4.2 假设检验法</h3><p>本节介绍平稳性的假设检验方法。一般认为现实中经济变量大多是趋势平稳过程或单位根过程，不太可能出现这种情形，因此，经济学家通常只考虑单位根检验，即检验序列中是否存在单位根，若存在，则为非平稳序列，不存在则为平稳序列。</p><h4 id="3421-df-检验和-adf-检验">3.4.2.1 DF 检验和 ADF 检验</h4><p>ADF 检验（Augmented Dickey-FullerTesting）是最常用的单位根检验方法之一，通过检验序列是否存在单位根来判断序列是否是平稳的。ADF检验是 DF 检验的增强版，在介绍 ADF 之前，我们先来看一下 DF 检验。</p><ol type="1"><li><strong>DF 检验</strong><ul><li>Dickey &amp; Fuller(1979)提出的单位根检验方法</li><li>检验样本平稳性时，需要根据数据的本身的特征选择合适的形式。通常而言，单位根非平稳过程的表现形式有三种：<ul><li><ol type="1"><li>当序列基本走势呈现无规则上升或下降并反复时，将其归为无漂移项自回归过程<span class="math inline">\(y_t =\rho y_{t−1} +\varepsilon_t\)</span>；</li></ol></li><li><ol start="2" type="1"><li>当序列基本走势呈现明显的随时间递增或递减且趋势并不太陡峭时，将其归为带漂移项自回归过程<span class="math inline">\(y_t =\mu+ \rho y_{t−1}+  \varepsilon_t\)</span>；</li></ol></li><li><ol start="3" type="1"><li>当序列基本走势随时间快速递增时，则将其归为带漂移项和趋势项的自回归过程<span class="math inline">\(y_t =\mu+\beta t+\rho y_{t−1}+  \varepsilon_t\)</span>。</li></ol></li></ul></li><li>原假设 <span class="math inline">\(H_0\)</span> : <spanclass="math inline">\(\rho = 1\)</span>（存在单位根，时间序列是非平稳的）；备择假设 <spanclass="math inline">\(H_0\)</span> : <span class="math inline">\(\rho&lt;1\)</span> （不存在单位根，时间序列是平稳的）</li><li>对于带漂移项和趋势项的自回归过程，OLS 估计结果与 DF 统计量：<ul><li>初始条件 <span class="math inline">\(y_0 = 0\)</span>，OLS 估计量<span class="math inline">\(\hat{\rho}\)</span> 的表达式：$ \hat{\rho} =\frac{\sum<span data-wrapper="1" data-t="1">_</span><sup>T y_ty_{t-1}}{\sum<span data-wrapper="1" data-t="1">_</span></sup>Ty_{t-1}^2} $ 标准误 <span class="math inline">\(se (\hat{\rho})\)</span>的表达式：（其中 <span class="math inline">\(\hat{\sigma}\)</span>为残差标准差估计值。）<span class="math inline">\(se (\hat{\rho}) =\frac{\hat{\sigma}}{\sqrt{\sum_{t=1}^T y_{t-1}^2}}\)</span></li><li>基于 OLS 结果构造的统计量： <span class="math inline">\(T =\frac{\hat{\rho} - 1}{se (\hat{\rho})} = \frac{\sum_{t=1}^T\varepsilon_t y_{t-1}}{\hat{\sigma} \sqrt{\sum_{t=1}^Ty_{t-1}^2}}\)</span> 该统计量称为 <strong>Dickey-Fuller (DF)统计量</strong>。</li></ul></li><li>DF 统计量 <strong>不服从渐近正态分布</strong>，其临界值需通过<strong>蒙特卡罗模拟</strong> 获得，而非传统 t 分布或正态分布表。</li><li>在存在截距项的情况下，Dickey 和 Fuller 发现：<ul><li>90%置信的估计值，偏离 <span class="math inline">\(\rho = 1\)</span>的标准误为 2.58。</li><li>95%置信的估计值，偏离 <span class="math inline">\(\rho = 1\)</span>的标准误为 2.89。</li><li>99%置信的估计值，偏离 <span class="math inline">\(\rho = 1\)</span>的标准误为 3.51。</li></ul></li></ul></li></ol><blockquote><p>[!note] 蒙特卡洛模拟蒙特卡洛模拟是一种基于大数定理的数值计算方法，其核心思想是通过大量随机抽样逼近理论解。这样，我们无需解析解即可逼近真实分布。</p><p><strong>1. 基本原理与步骤</strong></p><ul><li><strong>大数定理</strong>：若生成独立同分布（i.i.d）的随机序列 <spanclass="math inline">\(\{v_i\}\)</span>（均值为 <spanclass="math inline">\(\mu\)</span>，方差为 <spanclass="math inline">\(\sigma^2\)</span>），其样本均值 <spanclass="math inline">\(\overline{v} = \frac{1}{T}\sum_{i=1}^Tv_i\)</span> 会随样本量 <span class="math inline">\(T\)</span>增大而收敛于真实均值 <spanclass="math inline">\(\mu\)</span>（如图可能显示 <spanclass="math inline">\(\overline{v}\)</span> 随 <spanclass="math inline">\(T\)</span> 增加逐渐稳定在 <spanclass="math inline">\(\mu\)</span> 附近）。</li><li><strong>中心极限定理</strong>：当 <spanclass="math inline">\(T\)</span> 足够大时，<spanclass="math inline">\(\overline{v}\)</span> 的分布趋近于正态分布 <spanclass="math inline">\(N (\mu, \sigma^2/T)\)</span>（钟形曲线）。</li></ul><p><strong>2. 应用场景</strong></p><ul><li><strong>假设检验</strong>：DF检验通过蒙特卡洛模拟生成临界值，判断时间序列是否存在单位根。</li><li><strong>小样本分析</strong>：在有限数据下，蒙特卡洛模拟数据生成过程，研究统计量的分布特性。</li></ul><p>更具体的操作过程，详见课本 4.4.3 部分。</p></blockquote><ol start="2" type="1"><li><strong>ADF 检验</strong><ul><li>DF 的检验公式为一阶自回归过程，要求扰动项 <spanclass="math inline">\(\varepsilon_t\)</span>无自相关。但扰动项经常呈现出自相关特征。</li><li>为了能适用于高阶自回归过程的平稳性检验，Dickey &amp;Fuller（1981）对 DF检验进行了改进，<strong>引入了更高阶的滞后项来控制自相关特征</strong>。这就是Augmented Dickey-Fuller 单位根检验，简称 ADF 检验。</li><li>给定适当的滞后期 p，使得 AR(p)的扰动项 <spanclass="math inline">\(\varepsilon_t\)</span> 为白噪声过程：<ul><li><ol type="i"><li>无漂移项自回归过程：<span class="math inline">\(y_{t}=\rhoy_{t-1}+\sum_{i=1}^{k} \gamma_i \Deltay_{t-i}+\varepsilon_{t}\)</span></li></ol></li><li><ol start="2" type="i"><li>带漂移项自回归过程：<span class="math inline">\(y_{t}=\mu+\rhoy_{t-1}+\sum_{i=1}^{k} \gamma_i \Deltay_{t-i}+\varepsilon_{t}\)</span></li></ol></li><li><ol start="3" type="i"><li>带漂移项和趋势项自回归过程：<spanclass="math inline">\(y_{t}=\mu+\beta t+\rho y_{t-1}+\sum_{i=1}^{k}\gamma_i \Delta y_{t-i}+\varepsilon_{t}\)</span> 其中 <spanclass="math inline">\(\mu\)</span> 是常数项，<spanclass="math inline">\(\beta t\)</span> 是时间趋势项，<spanclass="math inline">\(\Delta y_{t-i}\)</span> 是滞后差分项（laggeddifference term）。<span class="math inline">\(\varepsilon_{t}\)</span>为随机扰动项。</li></ol></li></ul></li><li><strong>Problem 1：</strong> 无论是三种过程中的哪一个，我们要检验 AR(p) 模型是否存在单位根，只需检验 <spanclass="math inline">\(y_{t-1}\)</span> 的系数是否为 1。假设条件同 DF检验一致：<ul><li>原假设 <span class="math inline">\(H_0 : \rho = 1\)</span>（存在单位根，时间序列是非平稳的）</li><li>备择假设 <span class="math inline">\(H_1 : \rho &lt; 1\)</span>（不存在单位根，时间序列是平稳的）。</li><li>使用 OLS 估计估计自回归过程，得到：<spanclass="math inline">\(\hat{\rho}\)</span> 和相应的 <spanclass="math inline">\(t\)</span> 统计量。 <span class="math inline">\(t= \frac{\hat{\rho} - 1}{se(\hat{\rho})}\)</span> 该 <spanclass="math inline">\(t\)</span> 值被称为 ADF统计量。类似的，临界值通过蒙特卡罗模拟得到。</li></ul></li><li><strong>Problem 2：</strong>针对上述三种过程，不仅要确定数据序列是否存在单位根，即 <spanclass="math inline">\(\hat{\rho}\)</span> 是否显著异于1，还要确定这三种过程哪种才是拟合数据生成过程的“最佳”形式。（即，考虑所用检验式是否应当包含时间趋势项、是否应当包含漂移项。）<ul><li>可以构造联合检验 F 统计量检验以选择模型 [\phi_i =\frac{(SSR(\text{约束}) - SSR(\text{无约束})) / r}{SSR(\text{无约束}) /(T - k)}] <spanclass="math inline">\(SSR(\text{约束})\)</span>：约束模型的残差平方和；<spanclass="math inline">\(SSR(\text{无约束})\)</span>：无约束模型的残差平方和；<span class="math inline">\(r\)</span>：约束条件的数量；<spanclass="math inline">\(T\)</span>：样本量；<spanclass="math inline">\(k\)</span>：无约束模型中的参数个数。</li></ul></li></ul></li></ol><blockquote><p>[!note] <strong>ADF 单位根检验案例</strong> 检验目标：中国 1978-2003年基本建设投资（lnI）<ahref="https://cstj.cqvip.com/Qikan/Article/Detail?id=23878297">参考来源：聂巧平和张晓峒，2007</a><strong>1. 检验是否含时间趋势项</strong>（式 3）</p><ul><li><p><strong>回归方程</strong>：<br /><span class="math display">\[\Delta \ln I_t = 2.0759 - 0.3643 \lnI_{t-1} + 0.0665 t + 0.3662 \Delta \ln I_{t-1}\]</span></p><ul><li><strong>ADF 统计量</strong>：<spanclass="math inline">\(\gamma\)</span> 的 <spanclass="math inline">\(t\)</span> 值为 <spanclass="math inline">\(-3.00\)</span>，5%临界值为 <spanclass="math inline">\(-3.61\)</span>。</li><li><strong>单位根检验结论</strong>：<span class="math inline">\(-3.00&gt; -3.61\)</span>，无法拒绝原假设（存在单位根）。</li></ul></li><li><p><strong>时间趋势项检验（<span class="math inline">\(\delta =\gamma = 0\)</span>）</strong>：</p><ul><li><strong>统计量</strong>：<span class="math inline">\(\phi_3 =4.8305\)</span>，临界值 <span class="math inline">\(CV =7.1707\)</span>。临界值计算需通过响应面函数 <spanclass="math inline">\(CV = a + b/T + c/T^2\)</span>调整样本容量影响（本例 <span class="math inline">\(T =26\)</span>）。</li><li><strong>结论</strong>：<span class="math inline">\(4.8305 &lt;7.1707\)</span>，不拒绝原假设，<strong>剔除时间趋势项</strong>。</li></ul></li></ul><p><strong>2. 检验漂移项（式 2）</strong></p><ul><li><strong>回归方程</strong>：</li></ul><p><span class="math display">\[\begin{split}\Delta \ln I_t =&amp; 0.0709 - 0.0131 \ln I_{t-1} + 0.3401\Delta \ln I_{t-1} + 0.0828 \Delta \ln I_{t-2} \\&amp;- 0.0562 \Delta\ln I_{t-3} - 0.4161 \Delta \ln I_{t-4}\end{split}\]</span></p><ul><li><p><strong>ADF 统计量</strong>：<spanclass="math inline">\(\gamma\)</span> 的 <spanclass="math inline">\(t\)</span> 值为 <spanclass="math inline">\(-0.61\)</span>，5%临界值为 <spanclass="math inline">\(-3.01\)</span>。</p></li><li><p><strong>单位根检验结论</strong>：<spanclass="math inline">\(-0.61 &gt;-3.01\)</span>，仍无法拒绝单位根原假设。</p></li><li><p><strong>漂移项检验（<span class="math inline">\(\alpha = \gamma =0\)</span>）</strong>：</p><ul><li><strong>统计量</strong>：<span class="math inline">\(\phi_1 =5.6193\)</span>，临界值 <span class="math inline">\(CV =5.1537\)</span>。</li><li><strong>结论</strong>：<span class="math inline">\(5.6193 &gt;5.1537\)</span>，拒绝原假设，<strong>需保留漂移项</strong>。</li></ul></li></ul><p><strong>最终结论</strong>：</p><ul><li><strong>检验式选择</strong>：采用检验式2（含漂移项，无时间趋势项）。</li><li><strong>单位根判断</strong>：<spanclass="math inline">\(\gamma\)</span> 的 <spanclass="math inline">\(t\)</span> 值为 <spanclass="math inline">\(-0.61\)</span>，与标准正态分布临界值 <spanclass="math inline">\(-1.96\)</span>（5%水平）比较。</li><li><strong>结论</strong>：<span class="math inline">\(-0.61 &gt;-1.96\)</span>，无法拒绝 <span class="math inline">\(\gamma =0\)</span>，<strong>序列 <span class="math inline">\(\ln I\)</span>为单位根过程</strong>。</li><li><strong>检验逻辑</strong>：先检验高阶项（时间趋势），再逐步简化模型，避免过度参数化。</li></ul></blockquote><h4 id="3422-pp-检验">3.4.2.2 PP 检验</h4><ul><li><strong>为了解决 DF检验中残差项中潜在的序列相关和异方差问题</strong>，Phillips 和 Perron(1988) 提出一种非参数检验方法——Phillips-Perron 单位根检验（简称 PP检验）。该方法使用 New-West 标准误对 DF 统计量进行修正：</li><li>原假设 <span class="math inline">\(H_0 : \rho = 1\)</span>（存在单位根，时间序列是非平稳的） 备择假设 <spanclass="math inline">\(H_1 : \rho &lt; 1\)</span>（不存在单位根，时间序列是平稳的）。</li><li>PP 检验的 <span class="math inline">\(t\)</span> 统计量渐近分布与ADF 检验统计量相同，因而临界值也相同、也是左边单侧检验, 可作为 ADF检验的补充。</li><li>PP 检验须指定用于计算 Newey-West 标准误的滞后阶数，默认值为 <spanclass="math inline">\(4(\frac{T}{100})^\frac{2}{9}\)</span>。</li></ul><h4 id="3423-kpss-检验">3.4.2.3 KPSS 检验</h4><ul><li>另一种单位根检验是 Kwiatkowski, Phillips, and Shin 在 1992 年提出的KPSS 检验。</li><li>与以上检验方法相比，最大的不同点：<b> <font color="#245bdb"> KPSS检验的原假设是平稳序列或趋势平稳序列，而备择假设是存在单位根。</font></b></li><li>原假设：序列不存在单位根（时间序列是平稳的或趋势平稳的）</li><li>备择假设：序列存在单位根（时间序列是非平稳的）</li><li>假设时间序列 <span class="math inline">\(y_t\)</span>可以分解为时间趋势、随机游走和平稳过程之和，即</li></ul><p><span class="math display">\[y_t = \delta t + u_t + \varepsilon_t \quad  , \quad u_t = u_{t-1} + v_t\quad v_t \sim WN(0, \sigma_v^2)\]</span></p><p>原假设 <span class="math inline">\(H_0\)</span>：<spanclass="math inline">\(\sigma_v^2 = 0\)</span>，即趋势平稳。备择假设<span class="math inline">\(H_1\)</span>：<spanclass="math inline">\(\sigma_v^2 &gt; 0\)</span>，即不平稳。</p><h2 id="35-单位根检验的进阶方法">3.5 单位根检验的进阶方法</h2><p>上一节介绍了一系列常见的单位根检验方法。这些检验中均不能100%保证检验正确，请注意，ADF 检验的前提条件是没有异方差；PP检验适用于异方差场合，可认为是 ADF 检验的补充；KPSS检验不需要选择趋势类型，因而更具鲁棒性，同样也可和其他检验一同使用，当均认为是平稳或趋势平稳时方判定为平稳。</p><p>事实上，这些方法都是非季节性时间序列单位根检验方法，并不是全部方法。总体而言，单位根检验方法分为5 类，即：</p><ol type="1"><li>非季节性时间序列单位根检验：DF 检验、ADF 检验、WS 检验、RMA 检验、PP检验、KPSS 检验、ERS 点检验、NP 检验。</li><li>季节时间序列的单位根检验：DHF 检验、HEGY 检验、Kunst 检验</li><li>退势单位根检验：GLS 退势检验、KGLS 退势检验、ROLS退势检验。<strong>时间序列的退势是指从原时间序列中分离出确定性线性趋势项或周期性趋势项的处理过程。</strong></li><li>结构突变序列的单位根检验：Perron 检验、Zivot-Andrews 方法、BLS检验、递归检验、滚动检验、循序检验</li><li>面板数据的单位根检验：Quah 检验、LLC 检验、IPS 检验、崔仁检验、MW检验、Bai-Ng 检验、 Hadri 检验、Breitung 检验。</li></ol><p>关于平稳性检验的代码实现，请参考：<ahref="https://zhuanlan.zhihu.com/p/425664064">Python 实现</a>，<ahref="https://www.cnblogs.com/kisen/p/12587862.html">R 实现</a>，<ahref="https://zhuanlan.zhihu.com/p/687947331">Stata 实现</a></p><h4 id="351-有效性问题与退势单位根检验">3.5.1有效性问题与退势单位根检验</h4><h5 id="3511-有效性问题">3.5.1.1 有效性问题</h5><ul><li>通常一种检验的有效性 (power)在于拒绝一个错误的原假设的可能性。当问题中的序列平稳时，一个有效的检验将会拒绝存在单位根的原假设。</li><li>蒙特卡洛试验已经证明，各种 DF检验的有效性都较差。因此，这些检验往往显示序列存在单位根。而且它们在区分趋势平稳和漂移过程的时候有效性也很低。</li><li>怎么解决这个问题？有没有更好的办法？</li><li>一个重要的方法是对 DF检验进行变形来提高有效性。下面我们就介绍两种【退势】的方法——LM 检验和DF-GLS 检验（又叫 ERS 检验），经过去除趋势的操作，变形后的 DF检验会更有效。</li></ul><h5 id="3512-lm-检验">3.5.1.2 LM 检验</h5><ul><li>Schmidt 和 Phillips (1992) 提出了比 DF 检验更具有效性的<strong>两步检验法</strong>——拉格朗日乘子 (Lagrange Multiplier，LM)检验</li><li>LM 检验关键点是，不用持久性很强的解释变量 <spanclass="math inline">\(y_{t-1}\)</span>的模型，估计趋势参数会更有效。如果能够有效地估计出趋势，那么就有可能剔除数据趋势，并在已剔除趋势的数据上进行单位根检验。</li><li><strong>原假设：序列存在单位根；备择假设：时间序列是平稳的或趋势平稳的</strong></li></ul><blockquote><p>[!note] LM 检验 <strong>LM检验第一步：构建去除趋势的序列</strong></p><ul><li>与 DF 检验的设定不同，<span class="math inline">\(\{y_t\}\)</span>序列在原假设下是一个带漂移的随机游走过程，因此 <spanclass="math display">\[ y_t = a_0 + a_2 t + \sum_{i=0}^{t-1}\varepsilon_{t-i} \quad \to \quad \Delta y_t = a_2 +\varepsilon_t\]</span></li><li>这种检验方法的思想在于使用回归方程 <spanclass="math inline">\(\Delta y_t = a_2 + \varepsilon_t\)</span>估计趋势系数 <span class="math inline">\(a_2\)</span>。因此，随机趋势<span class="math inline">\(\Sigma \varepsilon_i\)</span>的存在并不影响对 <span class="math inline">\(a_2\)</span> 的估计。</li><li>估计结果 <span class="math inline">\(\hat{a}_2\)</span>是关于时间趋势斜率的估计。使用 <spanclass="math inline">\(\hat{a}_2\)</span> 构建去除趋势的序列： <spanclass="math display">\[y^d_t = y_t - (y_1 - \hat{a}_2) - \hat{a}_2t\]</span> 其中，<span class="math inline">\(y_1\)</span> 为序列 <spanclass="math inline">\(\{y_t\}\)</span> 初始值。请注意，当 <spanclass="math inline">\(t=1\)</span> 时，确定性部分为 <spanclass="math inline">\(y_1 = a_0 + a_2\)</span>。</li><li>因此，被估计的趋势线的截距为 <span class="math inline">\((y_1 -\hat{a}_2)\)</span>，斜率为 <spanclass="math inline">\(\hat{a}_2\)</span>。这样做保证了去除趋势的序列（即<span class="math inline">\(y^d_t\)</span>）的初始值为零。</li></ul><p><strong>LM 检验第二步：使用去趋势序列替代</strong></p><ul><li>在 DF 检验方程的 <span class="math inline">\(y_{t-1}\)</span>处用去除趋势的序列 <span class="math inline">\(y^d_{t-1}\)</span>替代，估计变形的 DF 检验方程 <span class="math display">\[ \Delta y_t =c_0 + \gamma y^d_{t-1} + \epsilon_t \]</span></li><li>如果残差中存在序列相关，则估计方程 <span class="math display">\[\Delta y_t = c_0 + \gamma y^d_{t-1} + \sum_{i=1}^{p} \beta_i \Deltay^d_{t-i} + \epsilon_t \]</span></li><li>如果得到 <span class="math inline">\(\gamma \neq0\)</span>，则拒绝存在单位根的原假设。</li></ul></blockquote><h5 id="3513-df-gls-检验ers-检验">3.5.1.3 DF-GLS 检验（ERS 检验）</h5><ul><li>DF-GLS 检验，是 Elliott, Rothenberg, and Stock 在 1996年提出的一种单位根检验方法，全称 Dickey-Fuller Test with GLSDetredding，即“使用广义最小二乘法去除趋势的检验”；模拟试验证明 DF-GLS检验有效性更强。</li><li>原假设：序列存在单位根（时间序列是非平稳的）</li><li>备择假设：序列不存在单位根（时间序列是平稳的或趋势平稳的）</li><li><strong>DF-GLS 检验的做法</strong><ul><li>利用广义最小二乘法，首先对要检验的数据进行一次“准差分”，</li><li>然后利用准差分的数据对原序列进行去除趋势处理，</li><li>再利用 ADF 检验的模型形式对去除趋势后的数据进行单位根检验，但此时ADF 检验模型中不再包含常数项或者时间趋势变量。</li></ul></li></ul><blockquote><p>[!Note] DF-GLS 检验的做法</p><p>考虑趋势平稳(TS)模型： <spanclass="math inline">\(y_t=a_0+a_2t+B(L)\varepsilon_t\)</span></p><ol type="1"><li><p><strong>消除趋势</strong> 为消除 <spanclass="math inline">\(y_t\)</span> 的趋势，事先选择接近 1 的常数 <spanclass="math inline">\(\alpha\)</span> 进行近似差分变换</p><p><span class="math display">\[\widetilde{y}_t = y_t-\alpha y_{t - 1} \quad (t = 2,\cdots,T) \quad \to\quad \widetilde{y}_t=(1 - \alpha)a_0+a_2[(1 - \alpha)t+\alpha]+e_t\]</span></p><p>其中， <span class="math inline">\(t = 1\)</span> 时 <spanclass="math inline">\(\widetilde{y}_1\)</span> 设定等于 <spanclass="math inline">\(y_1\)</span>。运行这一最小二乘估计，得到估计系数<span class="math inline">\(\hat{a}_0\)</span> 和 <spanclass="math inline">\(\hat{a}_2\)</span> ，进而得到去除趋势的序列</p><p><span class="math display">\[y_t^d=y_t-\hat{a}_0-\hat{a}_2t\]</span></p></li><li><p><strong>使用去趋势序列估计 DF 检验</strong></p><ul><li>使用去趋势数据估计基本 DF 检验回归方程</li></ul><p><span class="math display">\[\Delta y_t^d=\gamma y_{t - 1}^d+\varepsilon_t\]</span></p><ul><li>若残差存在序列相关，估计扩展形式</li></ul><p><span class="math display">\[\Delta y_t^d=\gamma y_{t - 1}^d+\sum_{i = 1}^{p}c_i\Delta y_{t -i}^d+\varepsilon_t\]</span></p><ul><li><strong>滞后期 <span class="math inline">\(p\)</span>的选择</strong>： ERS 的建议是使用 SBC 准则选取 p。</li></ul></li><li><p><strong>假设检验</strong>：根据 <spanclass="math inline">\(\gamma\)</span> 是否为 0判断能否拒绝存在单位根的原假设。</p><ul><li><strong>临界值确定依据</strong>：检验临界值依赖于数据中是否含有趋势。</li><li>存在截距无趋势时，临界值取 DF 的 <spanclass="math inline">\(\tau\)</span>检验对应值；存在趋势时，临界值取决于“近似差分”时 <spanclass="math inline">\(\alpha\)</span> 的选择值。</li><li>对于存在截距情形，<spanclass="math inline">\(\alpha=(1-\frac{7}{T})\)</span>；存在截距和趋势情形，<span class="math inline">\(\alpha=(1 -\frac{13.5}{T})\)</span> 。样本容量 <spanclass="math inline">\(T\)</span> 增加时，<spanclass="math inline">\(\alpha\)</span> 趋于 1 ，<spanclass="math inline">\(\widetilde{y}_t\)</span> 近似于 <spanclass="math inline">\(\Delta y_t\)</span> 。</li></ul></li></ol></blockquote><h3 id="352-结构突变的-perron-单位根检验">3.5.2 结构突变的 Perron单位根检验</h3><ul><li>自从 DF 检验、ADF 检验以及 PP检验被提出以来，有关单位根检验的各种方法和应用研究不断地刊登在主流学术期刊上。然而，经典的单位根分析框架中并没有考虑真实数据的外部因素或自我调整因素引起的结构性变化。</li><li><b> <font color="#245bdb">“佩伦现象”</font></b>：在进行单位根检验时，当存在结构性变化时，DF检验将更倾向于接受存在单位根的原假设。（容易将具有结构突变的平稳过程误判为单位根过程）。<ahref="https://www.shangyexinzhi.com/article/3214717.html">相关综述</a></li><li>怎么解决“佩伦现象”？<ol type="1"><li>分样本 DF 检验</li></ol><ul><li>不足：每个回归部分的自由度减少了，并且可能并不知道断点何时出现</li><li>因此，对整个样本进行一次性的检验更恰当。</li></ul><ol start="2" type="1"><li><strong>Perron 检验</strong></li></ol><ul><li>Perron(1989)扩展了用于在 <spanclass="math inline">\(t=\tau+1\)</span>期存在结构性变化时检验单位根的方法。</li><li>需要考虑的核心问题：结构突变的影响？存在一次性跳跃</li><li><strong>原假设：</strong> 序列存在单位根；$ y_t = \mu + y_{t-1} +\lambda_1 D_p + \varepsilon_t $</li><li><strong>备择假设</strong>： 序列趋势平稳（趋势项 0时为平稳过程）<span class="math inline">\(y_t = \mu +  \beta t  +\lambda_2 D_L + \varepsilon_t\)</span><ul><li><span class="math inline">\(D_p\)</span> 是脉冲虚拟变量（Pulse）；当<span class="math inline">\(t=τ+1\)</span> 时，<spanclass="math inline">\(D_P\)</span> = 1，否则为 0；</li><li><span class="math inline">\(D_L\)</span> 是水平虚拟变量（Level）；当<span class="math inline">\(t≥τ+1\)</span> 时，<spanclass="math inline">\(D_L\)</span> = 1，否则为 0。</li><li>在原假设下，序列是一个单位根过程，并且在时期 <spanclass="math inline">\(t=\tau+1\)</span>时，序列在原有水平上有一个一次性跳跃。</li><li>在备择假设下，序列趋势平稳，截距项有一个一次性跳跃。</li></ul></li></ul></li></ul><p><imgsrc="https://files.mdnice.com/user/77043/c17a3699-778e-4aac-b1f2-a0908f4df17f.png"alt="结构性突变的单位根检验" /></p><blockquote><p>[!Tip] Perron 检验的步骤 <strong><font color="#245bdb"> 在 <spanclass="math inline">\(t=\tau+1\)</span> 期存在结构性变化时，单位根Perron 检验步骤：</font></strong></p><ol type="1"><li><p><strong>第一步：构建回归方程并估计</strong></p><ul><li>将原假设（存在单位根且有结构性变化）与备择假设（趋势平稳且有结构性变化）结合为一个回归方程，常见形式为：<spanclass="math display">\[ y_t = c_0 +  \beta t +\rho y_{t-1} + \mu_1 D_p +\mu_2 D_L + \varepsilon_t \]</span></li><li><span class="math inline">\(D_{P}\)</span> 为脉冲虚拟变量（<spanclass="math inline">\(t = \tau + 1\)</span> 时，<spanclass="math inline">\(D_{P} = 1\)</span>，否则为 0）；</li><li><span class="math inline">\(D_{L}\)</span> 为水平虚拟变量（<spanclass="math inline">\(t &gt; \tau\)</span> 时，<spanclass="math inline">\(D_{L} =1\)</span>，否则为 0）。</li><li>使用 OLS 估计该方程，得到残差 <spanclass="math inline">\(\hat{\varepsilon_t}\)</span>。</li></ul></li><li><p><strong>第二步：对残差进行诊断性检验</strong></p></li></ol><ul><li>对估计方程的残差进行诊断，检查是否存在序列相关。</li><li>怎么检验？请回顾 <a href="#2.3.5.1%20白噪声检验">2.3.5.1白噪声检验</a>。实操可参考 <ahref="https://zhuanlan.zhihu.com/p/547614582">用 Stata做白噪声检验</a></li></ul><ol start="3" type="1"><li><strong>第三步：残差自回归估计</strong></li></ol><ul><li>若不存在序列相关：使用 OLS 方法对残差项 <spanclass="math inline">\(\hat{\varepsilon}_t\)</span> 进行自回归估计。$\hat{\varepsilon}<em>t = \rho \hat{\varepsilon}</em>{t-1} + v_t$</li><li>若存在序列相关，则需要消除序列相关。残差的序列相关本质上反映原方程遗漏了相关项，需从原方程层面进行调整。第一步的回归方程改为$ y_{i} = c_0 + \beta t + \rho y_{i - 1} + \mu_{1}D_{p} + \mu_{2}D_{L} +\sum_{i = 1}^{p}\beta_{i}\Delta y_{t - i} + \varepsilon_{t}$</li><li>Perron 检验就是针对 <span class="math inline">\(\rho\)</span>的检验。若原序列存在单位根，则应不显著异于 1。</li></ul><ol start="4" type="1"><li><strong>第四步：计算统计量并检验</strong></li></ol><ul><li>计算原假设 <span class="math inline">\(\rho = 1\)</span> 的 <spanclass="math inline">\(t\)</span> 统计量：<spanclass="math inline">\(t_{\rho} = \frac{\rho - 1}{sd(\rho)}\)</span></li><li>将该统计量与 Perron 计算的临界值比较。若 <spanclass="math inline">\(|t_{a_1}|\)</span>大于临界值，拒绝原假设（序列是发生结构性变化的趋势平稳过程）；若小于临界值，接受原假设（序列是发生结构性变化的单位根过程）。</li><li>怎么获得临界值？<ul><li>定义 <span class="math inline">\(\lambda =\dfrac{\tau}{T}\)</span>，期中 <span class="math inline">\(\tau\)</span>为冲击点前样本数，<span class="math inline">\(T\)</span> 为总样本数</li><li>若残差独立同分布，<span class="math inline">\(\rho\)</span> 的分布与<span class="math inline">\(\lambda\)</span> 相关。Perron 根据不同 <spanclass="math inline">\(\lambda\)</span> 模拟了临界值，例如在 5%显著水平下，不同 <span class="math inline">\(\lambda\)</span>区间对应不同临界值。</li></ul></li></ul><p>【拓展】Perron（<ahref="https://www.jstor.org/stable/1913712?seq=1">1989，ECMA</a>）将序列受到冲击后发生的结构性变化分为三类：- A：冲击前后序列的水平（序列均值）发生变化，但斜率不变； -B：冲击前后序列的斜率发生变化，但水平未变化； -C：冲击前后序列的水平和系列均发生了变化。 -对于三种情况的分别讨论，请参考 <ahref="https://zhuanlan.zhihu.com/p/563632525">三类结构性变化的详细讨论</a>。</p><p>关于 Perron 检验的代码，请参考 <ahref="https://zhuanlan.zhihu.com/p/563632525">R 语言实现</a>、<ahref="https://zhuanlan.zhihu.com/p/603543837">Stata 实现</a>。</p></blockquote><h3 id="353-面板数据的-ips-单位根检验">3.5.3 面板数据的 IPS单位根检验</h3><ul><li>当存在许多类似的时间序列变量（面板数据）时，Im，Pesaran 和 Shin(2002) 提出了一种构造单位根检验的方法，简称 IPS 检验。</li><li>假设我们有 n 个序列，每个序列包含 T 个观测样本值。对于每个序列构建ADF 检验形式：</li></ul><p><span class="math display">\[\begin{split} y_{it} =&amp; a_{i0} + \rho_i y_{it-1} + a_{i2} t +\sum_{j=1}^{p_i} \beta_{ij} \Delta y_{it-j} + \varepsilon_{it}\\\Downarrow \\ \Delta y_{it}= y_{it}-y_{it-1}=&amp;a_{i0} + (\rho_i-1)y_{it-1} + a_{i2} t + \sum_{j=1}^{p_i} \beta_{ij} \Delta y_{it-j} +\varepsilon_{it}\\ =&amp;a_{i0} + \gamma_i y_{it-1} + a_{i2} t +\sum_{j=1}^{p_i} \beta_{ij} \Delta y_{it-j} +\varepsilon_{it}\end{split}\]</span></p><p>其中 <span class="math inline">\(\gamma_i=\rho_i-1\)</span> 。在Panel 单位根检验中，原假设应该是：</p><ul><li><p><spanclass="math inline">\(H_0\)</span>：所有个体的时间序列都有单位根，即所有时间序列都是非平稳的。因此：<span class="math inline">\(\rho_1=\rho_2=⋯=\rho_n=1 \to\gamma_1=\gamma_2=⋯=\gamma_n=0\)</span></p></li><li><p><spanclass="math inline">\(H_1\)</span>：至少有一个个体的时间序列是平稳的，即不存在单位根。拒绝原假设意味着<span class="math inline">\(\gamma_i\)</span> 中至少有一个不为零。在单独序列检验时，我们只要估计 <spanclass="math inline">\(\gamma\)</span>，就可得到每个序列的 <spanclass="math inline">\(t\)</span> 统计量。</p></li><li><p><strong>请思考：推广到面板数据，应该怎么检验呢？</strong></p></li><li><p><strong>IPS 检验通过结合每个个体的 ADF 检验的 t值来构造一个综合的统计量</strong>。</p><ul><li>如果计算出的综合统计量对应的 p 值小于显著性水平（如0.05），则拒绝原假设，认为至少有一个个体是平稳的。</li><li>反之，如果不能拒绝原假设，则认为所有个体都是非平稳的。</li><li>因此，可以通过把每个序列的 <span class="math inline">\(t\)</span>统计量的取样本均值得到平均的 t 值 <span class="math inline">\(\bar{t} =\left( \frac{1}{n} \right) \sum_{i=1}^{n} t_i\)</span> 从而构造 Z统计量检验 <span class="math inline">\(Z_\bar{t} = \frac{\bar{t} -E(\bar{t})}{\sqrt{\dfrac{\text{var}(\bar{t})}{n}}} \sim Normal\)</span>式中，<span class="math inline">\(E_i\)</span> 和 <spanclass="math inline">\(\text{var}(\bar{t})\)</span> 表示 <spanclass="math inline">\(\bar{t}\)</span> 的理论均值和方差。如果各个检验的<span class="math inline">\(t_i\)</span> 的 OLS 估计是无偏的，则 <spanclass="math inline">\(E_i\)</span> 的值为零。</li><li>为了修正事实存在的偏移，<span class="math inline">\(E_i\)</span> 和<span class="math inline">\(\text{var}(\bar{t})\)</span>的值可通过蒙特卡洛模拟计算。</li></ul></li></ul><blockquote><blockquote><p>[!tip] 面板单位根检验的局限性（了解）</p></blockquote><ol type="1"><li><p><strong>原假设的模糊性与结果敏感性</strong></p><ul><li><strong>原假设设定</strong>：IPS检验的原假设为所有个体的自回归系数增量满足 <spanclass="math inline">\(\gamma_1 = \gamma_2 = \cdots = \gamma_n =0\)</span>（即 <span class="math inline">\(\rho_i =1\)</span>，存在单位根）。</li><li>IPS 检验中，可能因为 <span class="math inline">\(\gamma_i\)</span>中一个或两个值不为零而拒绝原假设。但没有特殊的方法可以知道 <spanclass="math inline">\(\gamma_i\)</span>中的哪些值不为零。可能因少数平稳序列的存在而得出整体拒绝原假设的结论，掩盖其他个体的非平稳性。</li></ul></li><li><p><strong>对小样本不准确</strong></p><ul><li>检验的渐近性质对时间维度（<spanclass="math inline">\(T\)</span>）和截面维度（<spanclass="math inline">\(n\)</span>）的增长方式敏感：例如，对于小 <spanclass="math inline">\(T\)</span> 和大 <spanclass="math inline">\(n\)</span>，临界值依赖于滞后项系数（如 <spanclass="math inline">\(\beta_{ij}\)</span>）。</li></ul></li><li><p><strong>误差项相关性与修正方法的不足</strong></p><ul><li><strong>序列相关与周期相关</strong>：检验要求误差项 <spanclass="math inline">\(\epsilon_{it}\)</span> 无自相关和跨期相关，但：<ul><li>滞后阶数 <span class="math inline">\(p_i\)</span>的选择可能无法完全消除自相关（<span class="math inline">\(E_{e_{it}}\neq 0\)</span>）。</li><li>截面相关性（个体间误差相关）会导致临界值失效。</li></ul></li><li><strong>修正方法的局限性</strong>：<ul><li>减去共同时间效应（如时间虚拟变量）可部分修正，但无法彻底解决。</li><li>修正可能引入新的非平稳问题（如 <spanclass="math inline">\(|\bar{\gamma}_i|\)</span>的非平稳性），影响检验可靠性。</li></ul></li></ul></li></ol></blockquote><h2 id="36-arima-模型与滤波器">3.6 ARIMA 模型与滤波器</h2><h3 id="361-arima">3.6.1 ARIMA</h3><p>前面我们已经学习了单位根过程和单位根的检验，事实上，单位根过程对应了ARIMA(p, 1, q) 模型。</p><ul><li>ARIMA (AutoRegressive Integrated Moving Average) 在 ARMA的基础上引入差分（Integration），模型表示为 ARIMA(p, d, q)。其中 d 为<strong>差分阶数</strong>（将非平稳序列转换为平稳序列所需的差分次数）</li><li>ARMA（自回归移动平均模型）和ARIMA（差分自回归移动平均模型）的核心区别在于<strong>是否处理非平稳数据</strong>。ARIMA适用于非平稳时间序列（通过差分消除趋势或季节性，得到平稳序列，再使用ARMA (p, q) 建模）。</li><li><strong>如何使用 ARIMA 模型？</strong><ol type="1"><li>检验平稳性：使用 ADF 检验或观察自相关图（ACF）。<ul><li>若平稳 → 直接使用 ARMA。</li><li>若非平稳 → 使用 ARIMA，并通过差分转换为平稳序列。</li></ul></li><li>确定差分阶数 d： 通常从 d = 1 开始，逐步增加直至序列平稳。</li><li>参数调优：通过 AIC/BIC 准则选择最优的 p 和 q，估计去趋势后的 ARMA模型。</li></ol></li></ul><h3 id="362-beveridge-nelson-分解去趋势">3.6.2 Beveridge-Nelson分解去趋势</h3><p>为了将数据分解为随机趋势和平稳周期，我们可以采用 Beveridge-Nelson分解法。</p><ul><li>Beveridge-Nelson（1981）提出将 <strong>非平稳时间序列</strong>（如ARIMA 模型）分解为 <strong>随机趋势成分</strong>（带漂移的随机游走）和<strong>平稳成分</strong>（无规则波动）。</li><li>其核心是通过长期预测函数识别趋势，剩余部分即为平稳成分。</li><li>当采用这种技术时，我们需要指定与平稳部分有关的滞后期的数量。</li></ul><blockquote><p>[!note] Beveridge-Nelson 分解步骤（略） <strong>步骤 1：估计 ARIMA模型</strong></p><ul><li>对 ARIMA (p, 1, q)原始序列 <span class="math inline">\(y_t\)</span>进行 1 阶差分，得到平稳的差分序列 <span class="math inline">\(\Deltay_t\)</span>。</li><li>使用 Box-Jenkins 方法拟合最优 ARMA (p, q) 模型，例如：</li></ul><p><span class="math display">\[\Delta y_t = a_0 + \varepsilon_t + \beta_1 \varepsilon_{t-1} + \beta_2\varepsilon_{t-2} + \cdots + \beta_q \varepsilon_{t-q}  \]</span></p><p><strong>步骤 2：构造预测函数</strong></p><ol type="1"><li><strong>计算多步预测值</strong> 对差分后的平稳序列 <spanclass="math inline">\(\Delta y_t\)</span>（服从 ARMA (p, q)），在时刻<span class="math inline">\(t\)</span> 预测未来 <spanclass="math inline">\(s\)</span> 步的差分值：</li></ol><p><span class="math display">\[E_t[\Delta y_{t+1}], \, E_t[\Delta y_{t+2}], \, \dots, \, E_t[\Deltay_{t+s}]\]</span></p><ul><li><strong>短期预测</strong>：前 <span class="math inline">\(q\)</span>步预测受移动平均（MA）项影响。例如，对 <spanclass="math inline">\(\Delta y_{t+1}\)</span> 的预测为：</li></ul><p><span class="math display">\[E_t[\Delta y_{t+1}] = a_0 + \beta_1 \varepsilon_t + \beta_2\varepsilon_{t-1} + \dots + \beta_q \varepsilon_{t-q+1}\]</span></p><ul><li><strong>长期预测</strong>：当 <span class="math inline">\(s &gt;q\)</span> 时，MA 项的影响消失，预测值仅由常数项 <spanclass="math inline">\(a_0\)</span> 主导：</li></ul><p><span class="math display">\[E_t[\Delta y_{t+s}] = a_0 \quad (s &gt; q)\]</span></p><ol start="2" type="1"><li><strong>预测值的长期极限</strong></li></ol><ul><li>将未来 <span class="math inline">\(s\)</span> 步预测值累加，得到<span class="math inline">\(y_{t+s}\)</span> 的预测：<spanclass="math inline">\(E_t[y_{t+s}] = y_t + \sum_{k=1}^s E_t[\Deltay_{t+k}]\)</span></li><li>当 <span class="math inline">\(s \to \infty\)</span>时，累加和分解为两部分：<ul><li><strong>确定性趋势</strong>：由常数项 <spanclass="math inline">\(a_0\)</span> 的累积构成，即 <spanclass="math inline">\(a_0 \cdot s\)</span>。</li><li><strong>随机趋势</strong>：由历史冲击 <spanclass="math inline">\(\{\varepsilon_t, \varepsilon_{t-1},\dots\}\)</span> 的长期影响构成，形式为： $ \mu_t = \psi(1) \sum<spandata-wrapper="1" data-j="0">_</span>^\infty \varepsilon_{t-j}$ 其中<span class="math inline">\(\psi(1) = 1 + \beta_1 + \beta_2 + \dots +\beta_q\)</span> 是移动平均系数的累积效应。</li></ul></li></ul><ol start="3" type="1"><li><strong>随机趋势的显式构造</strong> 随机趋势 <spanclass="math inline">\(\mu_t\)</span> 是历史冲击的加权和，权重为 <spanclass="math inline">\(\psi(1)\)</span>，反映了每个冲击的影响：<spanclass="math inline">\(\mu_t = y_t + \sum_{j=0}^{q-1} \left(\sum_{i=j+1}^q \beta_i \right) \varepsilon_{t-j}\)</span></li></ol><ul><li><strong>示例</strong>：若 <span class="math inline">\(\Deltay_t\)</span> 是 MA (2) 过程，则：$ \mu_t = y_t + (\beta_1 +\beta_2)\varepsilon_t + \beta_2 \varepsilon_{t-1} $</li></ul><ol start="4" type="1"><li><strong>B-N 分解的组成</strong><ul><li><strong>确定性趋势</strong>：斜率 <spanclass="math inline">\(a_0\)</span> 的线性项 <spanclass="math inline">\(a_0 \cdott\)</span>，代表序列的长期增长趋势。</li><li><strong>随机趋势</strong>：<spanclass="math inline">\(\mu_t\)</span> 是一个随机游走过程，增量受冲击<span class="math inline">\(\varepsilon_t\)</span> 驱动，即： $ \mu_t =\mu_{t-1} + a_0 + \psi(1)\varepsilon_t $</li><li><strong>平稳成分</strong>：原始序列与趋势的残差，即 <spanclass="math inline">\(y_t - \mu_t\)</span>，为有限阶 MA 过程，例如 MA(q-1)。</li></ul></li></ol><p><strong>步骤 3：分离平稳成分</strong></p><ul><li>平稳成分（无规则波动）为原始序列减去随机趋势：</li></ul><p><span class="math display">\[\text{平稳成分} = y_t - \mu_t = -\left ( \sum_{i=1}^\infty \beta_i\right) \varepsilon_t - \left ( \sum_{i=1}^\infty \beta_i \right)\varepsilon_{t-1} - \cdots  \]</span> <span class="math display">\[  Y_t- \mu_t = -(\beta_1 + \beta_2) \varepsilon_t - \beta_2\varepsilon_{t-1}  \]</span></p></blockquote><h3 id="363-hodrick-prescott-去趋势">3.6.3 Hodrick-Prescott 去趋势</h3><ol type="1"><li>基本原理与步骤 HP 分解通过最小化目标函数，将时间序列 <spanclass="math inline">\(y_t\)</span> 分解为趋势成分 <spanclass="math inline">\(\mu_t\)</span> 和平稳成分 <spanclass="math inline">\(y_t - \mu_t\)</span>：</li></ol><p><span class="math display">\[\min_{\{\mu_t\}} \left[ \frac{1}{T} \sum_{t=1}^T (y_t - \mu_t)^2 +\frac{\lambda}{T} \sum_{t=2}^{T-1} \left[ (\mu_{t+1} - \mu_t) - (\mu_t -\mu_{t-1}) \right]^2 \right]\]</span></p><ul><li>这个公式看上去很复杂！Hint：拉格朗日乘子法</li><li><strong>第一项</strong>：衡量趋势对原始序列的拟合程度（残差平方和）。</li><li><strong>第二项</strong>：惩罚趋势的二阶差分（即趋势的曲率），迫使趋势平滑。</li><li><strong>参数 <spanclass="math inline">\(\lambda\)</span></strong>：控制平滑程度。它是主观确定的常量，反映趋势中包含波动的惩罚。<ul><li><span class="math inline">\(\lambda \to 0\)</span>：当 <spanclass="math inline">\(y_t=\mu_t\)</span>平方和最小，趋势为序列本身。</li><li><span class="math inline">\(\lambda \to\infty\)</span>：第二项更加重要，所以平方和最小时 <spanclass="math inline">\(\mu_{t+1}-\mu_t=\mu_t-\mu_{t-1}\)</span>，这样，趋势变化恒定，退化为线性时间趋势。</li><li><span class="math inline">\(0 &lt; \lambda &lt;\infty\)</span>：允许趋势缓慢变化，适应长期波动。</li></ul></li></ul><ol start="2" type="1"><li>优点</li></ol><ul><li><strong>操作简单</strong>：无需预先建模（如ARIMA），直接通过优化问题求解。</li><li><strong>多变量一致性</strong>：统一方法应用于多个变量，确保趋势同步（如经济周期模型）。</li><li><strong>灵活调节</strong>：通过调整 <spanclass="math inline">\(\lambda\)</span>，可适应不同平滑需求。</li></ul><blockquote><p>[!tip] 补充：HP 分解与 Beveridge-Nelson（BN）分解对比 |<strong>维度</strong> | <strong>HP 分解</strong> | <strong>BN分解</strong> | |—————––|———————————––|————————————| |<strong>理论基础</strong> | 基于优化平滑，无明确假设 | 基于ARIMA，区分确定性与随机趋势 | | <strong>趋势一致性</strong> |多变量共享同一趋势 | 各变量独立分解，趋势可能不一致 | |<strong>参数依赖性</strong> | 依赖 <spanclass="math inline">\(\lambda\)</span> 的选择 | 依赖 ARIMA模型阶数的选择 | | <strong>适用序列类型</strong> | 适合 <spanclass="math inline">\(I(2)\)</span> 或需强平滑的序列 | 适合 <spanclass="math inline">\(I(1)\)</span> 序列，需差分平稳 | |<strong>端点敏感性</strong> | 较高 | 较低（依赖模型预测） | 什么是I(1)、I(2)？这就是一阶和二阶单整。关于协整的内容，在课本第 6章系统介绍。我们在此对协整做一个简单的介绍：</p><p><strong>协整</strong> 是指<strong>两个非平稳序列的线性组合平稳的性质</strong>。</p><ul><li>我们称平稳的时间序列为“零阶单整”(Integrated of order zero)，记为I(0)。</li><li>如果时间序列的一阶差分为平稳过程，称为“一阶单整”，记为I(1)。这就是“单位根过程”。</li><li>同理，二阶单整序列就是二阶差分具有平稳性的序列。</li><li>一般地，如果时间序列的 d 阶差分为平稳过程，称为“d 阶单整”，记为I(d)。</li></ul><p><strong>性质？</strong></p><ul><li>I(0)序列（平稳序列）对过去行为只有有限记忆，即发生在过去的扰动项对未来的影响随时间而衰减。因此，长期而言0 阶单整有回到期望值的趋势，即：“均值回复”(mean-reverting)。</li><li>I(1)序列则对过去行为有无限长的记忆，即任何过去的冲击都将永久地改变未来的整个序列。</li><li>对 <span class="math inline">\(y_t\)</span>进行单位根检验后，如认为非平稳，要进一步判断其为 I(1)或I(2)。在经济变量中，I(0)与 I(1)最常见，I(2)很少见。</li></ul></blockquote><h1 id="chapter-4-波动率模型">Chapter 4: 波动率模型</h1><blockquote><p>[!Important] 本章学习目标</p><ol type="1"><li>阐述与经济时间序列数据性质有关的“定式化事实”（见课本）。</li><li>介绍基本 ARCH 模型和 GARCH 模型。</li><li>阐述 ARCH 模型和 GARCH 模型如何用于估计通货膨胀率的波动性。</li><li>阐述 GARCH 模型如何捕捉石油价格、美国真实 GDP 和利差的波动。</li><li>阐述一个 GARCH 模型如何被用来估计某一经济部门的风险。</li><li>展示用 ARCH 模型如何估计一个随时间变化的风险溢价。</li><li>阐述 GARCH (1，1) 模型的特性并用 GARCH 模型进行预测。</li><li>得到一个 GARCH 过程的最大似然函数。</li><li>介绍 GARCH 的其他重要形式，包括 IGARCH、非对称 TARCH 和 EGARCH模型</li><li>阐述用 NYSE 100 指数估计 GARCH 模型的过程</li><li>阐述如何用多元 GARCH 模型来捕捉波动溢出。</li><li>形成波动脉冲响应函数并阐述用汇率数据的估计方法。</li></ol></blockquote><h2 id="41-arch-和-garch-过程">4.1 ARCH 和 GARCH 过程</h2><p><strong>在传统计量模型中，我们假设干扰项方差为常数。</strong></p><ul><li>对于资产收益率序列 <spanclass="math inline">\(\{𝑟_𝑡\}\)</span>，如果它是高斯过程（满足同方差homoskedasticily），则最优线性预测就是最优预测，通常只要建立一个 ARMA这样的线性模型就足够了。</li><li>但是，<strong>许多序列的波动并不会一直持续</strong>。在金融市场中，资产收益率常常不是正态分布的，而且金融资产的收益率会随时间𝑡 变化，存在“波动率聚集”现象，即某一段时间波动较大，而另一段时间波动较小。</li><li><strong>在这种情况下，假设方差为常数 (同方差)是不恰当的</strong>。</li><li>所以，我们有必要在对条件期望 <span class="math inline">\(E(r_t|F_{t-1})\)</span> 建模的同时对条件方差 <span class="math inline">\(Var(r_t |F_{t-1})\)</span> 建模。</li><li>作为资产持有者，我们会对该资产在持有期间的回报率及其方差的预测感兴趣。如果我们打算在t 期买进该资产，在 t+1 期卖出，无条件方差 (即：方差的长期预测)就不再重要。<strong>预测方差的一种方法是引入一个独立变量来估计波动性</strong>。</li></ul><h1 id="chapter-5-多元时间序列">Chapter 5: 多元时间序列</h1><blockquote><p>[!IMPORTANT] 本章学习目标</p><ol type="1"><li>介绍干扰分析和传递函数分析。</li><li>阐述当系统中不存在信息反馈时，传递函数分析是预测和假设检验的有效工具。</li><li>使用恐怖主义和意大利旅游的数据解释估计自回归分布滞后 (ADL)的适当方式。</li><li>阐述为什么传递函数和 ADL模型的主要限制是许多经济系统都呈现出信息反馈性。</li><li>介绍向量自回归 (VAR) 的原理。</li><li>展示怎样估计 VAR 模型。阐述为什么向量自回归 (VAR)的一个最基本形式就是均等地对待所有变量，而不涉及独立与否的争议。</li><li>展示怎样获得脉冲响应和方差分解。</li><li>阐述如何检验滞后期、Granger 因果关系和 VAR 的外生性。</li><li>采用打击国际恐怖活动的样本数据，阐述 VAR的估计过程和获得脉冲响应的过程</li><li>展示结合经济理论和多变量时间序列的结构性 VAR和多变量分解两种方法。</li><li>阐述几种不同类型的可用于确定向量自回归模型的限制条件。</li><li>展示如何检验过度识别限制。使用宏观经济和农业的例子阐述方法。</li><li>阐述怎样检验长期中立可用来确定 VAR 的 Blanchard-Ouah 约束条件。</li><li>用实际和名义利率数据阐述 Blanchard-Quah 分解过程。</li></ol></blockquote><p>前面的章节仅涉及单变量时间序列的分析，从本章开始涉及多变量的分析。</p><ul><li>与单一变量的时间序列相比，多变量时间序列涉及两个或更多的变量相互之间的关系，</li><li>这样的数据结构更加复杂。它不仅要求我们理解每个变量自身的动态特征，还要掌握这些变量之间的互动模式。</li></ul><h2 id="51-干扰分析">5.1 干扰分析</h2><p>稳定的时间序列可能由于某些事件的发生变得不稳定，比如自然事件（如地震）、政策等。这时，我们希望研究外生变量z 对时间序列变量 y 的影响。怎么做？</p><p><b> <center> 干扰分析（干预分析，intervention analysis）</center></b></p><ul><li>干扰分析的一般模型形式如下：<span class="math display">\[y_t = a_0 +A(L)y_{t-1} + cz_t + B(L)\varepsilon_t\]</span></li><li>其中，A(L)、B(L)为滞后算子的多项式，<spanclass="math inline">\(z_t\)</span> 为外生变量，c为为我们感兴趣的系数。</li><li><span class="math inline">\({y_t}\)</span>需要为平稳序列。也就是说，在进行干扰分析前应进行单位根检验，若原始序列为平稳序列，可以直接使用，若为非平稳序列，则需进行差分或去除趋势等平稳化操作。</li><li>如果干扰因素对时间序列数据的影响存在延迟，可取干扰变量的滞后形式<span class="math inline">\(z_{t-d}\)</span> 替换 <spanclass="math inline">\(z_t\)</span> 。</li></ul><p><strong>干扰因素的出现使得时间序列数据被分为两段：干扰前和干扰后</strong>。针对不同的情况，可以选取不同的变量形式来刻画干扰因素：</p><ol type="1"><li><p><strong>虚拟变量</strong></p><ul><li>若在 t 时刻干扰因素存在，则 <span class="math inline">\(z_t =1\)</span>，否则 <span class="math inline">\(z_t = 0\)</span>。</li><li>举例来说，若某项政策在 <span class="math inline">\(t = 10\)</span>时颁布后一直实行，则对于 <span class="math inline">\(t &lt;10\)</span>，可设 <span class="math inline">\(z_t = 0\)</span>；对于<span class="math inline">\(t \geq 10\)</span> 时，可设 <spanclass="math inline">\(z_t = 1\)</span>，这是一种<strong>纯粹跳跃</strong> 的情况。</li><li>若某项特殊政策仅在 <span class="math inline">\(t = 10\)</span>时实行过一次，此后就恢复之前的状态了，那么可以仅在 <spanclass="math inline">\(t = 10\)</span> 时设 <spanclass="math inline">\(z_t = 1\)</span>，其余时刻 <spanclass="math inline">\(z_t = 0\)</span>，这种情况也称为<strong>脉冲</strong>。</li></ul></li><li><p><strong>渐进式</strong>（渐进变化函数）</p><ul><li>这种形式是对纯粹跳跃的改进，即干扰因素不是一次性地从 0 跳跃到1，而是经历了一个渐进的过程。</li><li>比如，设 <span class="math inline">\(z_{10} = 0.25\)</span>，<spanclass="math inline">\(z_{11} = 0.5\)</span>，<spanclass="math inline">\(z_{12} = 0.75\)</span>，<spanclass="math inline">\(z_{13} = 1\)</span>，此后均有 <spanclass="math inline">\(z_t = 1\)</span>。</li></ul></li><li><p><strong>衰减式</strong>（延长的脉冲函数）</p><ul><li>这种情况是对脉冲的改进。</li><li>脉冲形式假定干扰因素是一下子消失的，而衰减式则假定干扰因素是逐渐衰减的，也就是说<span class="math inline">\(z_t\)</span> 从 1 恢复为 0需要经历一个过程。</li><li>比如，设 <span class="math inline">\(z_{10} = 1\)</span>，<spanclass="math inline">\(z_{11} = 0.75\)</span>，<spanclass="math inline">\(z_{12} = 0.5\)</span>，<spanclass="math inline">\(z_{13} = 0.25\)</span>，此后均有 <spanclass="math inline">\(z_t = 0\)</span>。</li></ul></li></ol><p><strong>干扰分析建模步骤</strong></p><ul><li><strong>步骤1</strong>：把时间序列分为干扰前和干扰后两段，选择其中较长的一段识别ARIMA 模型</li><li><strong>步骤 2</strong>：以步骤 1确定的模型阶数为基础，使用全样本（干扰前+干扰后）对干扰模型进行拟合。</li><li><strong>步骤3</strong>：诊断检验。一个估计出的好的干扰模型应具备如下特征</li><li><strong>估计出的所有系数都应该是统计显著的</strong>。而且，自回归系数应该显示<span class="math inline">\(y_t\)</span> 收敛。</li><li><strong>残差应该近似白噪声过程。</strong>请注意：如果残差并不类似于正态分布，通常小样本的估计检验的推断是无效的；如果误差看上去服从ARCH 过程，则需要将整个干扰模型当作 ARCH 模型重新进行估计。</li><li><strong>预测模型应当优于看似合理的备择模型</strong>。</li></ul><h2 id="52-传递函数分析与-adl-模型">5.2 传递函数分析与 ADL 模型</h2><h3 id="521-传递函数模型">5.2.1 传递函数模型</h3><p>对干扰模型的自然扩展就是 <strong>允许序列 <spanclass="math inline">\({z_t}\)</span>不仅仅是一个确定性的虚拟变量</strong>。 考虑传递函数的一般形式如下：</p><p><span class="math display">\[y_{t}=a_0+A(L)y_{t-1}+C(L)z_{t}+B(L)\varepsilon_{t}\]</span></p><p>式中，<span class="math inline">\(A (L)\)</span>、<spanclass="math inline">\(B (L)\)</span> 和 <span class="math inline">\(C(L)\)</span> 是滞后算子 L 的多项式。</p><ul><li>其中，<span class="math inline">\(C (L)\)</span> 被称为<strong>传递函数</strong>，因为它展示了外生变量 <spanclass="math inline">\({z_t}\)</span> 中的变动如何影响（转换为）内生变量<span class="math inline">\({y_t}\)</span> 的时间路径。</li><li>我们可以设 <span class="math inline">\(C(L)=c_0+c_1L+c_2L^2+\cdots\)</span> 。其中系数 <spanclass="math inline">\(c_i\)</span> 被称为传递函数权重。</li><li>在一个典型的传递函数分析中，研究者必将收集内生变量 <spanclass="math inline">\(\{y_t\}\)</span> 和外生变量 <spanclass="math inline">\(\{z_t\}\)</span> 的数据，其目的在于估计参数 <spanclass="math inline">\(a_0\)</span> 和多项式 <spanclass="math inline">\(A (L)\)</span>、<span class="math inline">\(B(L)\)</span> 和 <span class="math inline">\(C (L)\)</span> 的参数。</li></ul><blockquote><p>[!note] 传递函数模型 v.s 干扰模型</p><ul><li>干扰模型和传递函数模型的共同点是：都假定 z 为外生变量，即只允许 z影响 y，而不允许反过来 y 影响 z。</li><li>传递函数模型较干扰模型更具一般性：<ul><li>对于干扰模型，无论是当期值，还是滞后值，都仅含一项与 z相关的项，</li><li>而在传递函数模型中， <span class="math inline">\(\{z_t\}\)</span>并没有受到特殊的确定性时间路径的约束，而是允许干扰变量为任意随机外生过程，允许出现分布滞后项。</li></ul></li><li><strong>对于在多个时期分配 z 对 y影响的模型，称为分布滞后（distributed lag）模型</strong>。</li></ul></blockquote><h3 id="522-特例adl-模型">5.2.2 特例：ADL 模型</h3><p>ADL 模型是传递函数模型的特例。令 <span class="math inline">\(B(L)=1\)</span>，模型形式如下：</p><p><span class="math display">\[y_{t}=a_0+A(L)y_{t-1}+C(L)z_{t}+\varepsilon_{t}\]</span></p><ul><li>此时，模型中仅含有的自回归项和分布滞后项，不含误差的移动平均项，因此称为<strong>自回归分布滞后模型</strong>（ADL 模型）。</li><li>与纯粹的干扰模型相比，ADL模型并没有干扰前和干扰后之分，所以我们不能按照估计干扰模型的那种形式估计。</li><li>尽管不能照搬，但其目的都是为了估计一个简练的模型，所以估计方法是类似的。</li></ul><blockquote><p>[!tip] 拟合 ADL 模型的步骤 我们考虑一个简单的 ADL 模型</p><p><span class="math display">\[y_t = a_1 y_{t-1} + c_d z_{t-d} + \varepsilon_t\]</span></p><p>其中，<spanclass="math inline">\(\{z_{t}\},\{\varepsilon_{t}\}\)</span>为独立的白噪声过程，<spanclass="math inline">\(E(z_{t}\varepsilon_{t-i})=0\)</span>， <spanclass="math inline">\(a_1,c_d\)</span> 为未知系数，d是我们设定的滞后期。</p><p><strong>第一步</strong>：计算 <spanclass="math inline">\(y_t\)</span> 与不同 <spanclass="math inline">\(z_{t-i}\)</span>的值的互相关系数(cross-correlations)。</p><ul><li><span class="math inline">\(y_t\)</span> 和 <spanclass="math inline">\(z_{t-i}\)</span> 的互相关系数定义为</li></ul><p><span class="math display">\[\rho_{yz}(i) = \frac{Cov(y_t, z_{t-i})}{\sigma_y \sigma_z}\]</span></p><ul><li>用 <span class="math inline">\(\rho_{yz}\)</span> 作图，得到<strong>互相关函数</strong>（cross-correlation function,CCF）或互相关图。</li><li>在实践中，我们必须用到通过样本数据计算的互相关系数，因为我们并不知道准确的协方差和标准差。</li></ul><p><strong>第二步</strong>：计算互协方差</p><ul><li>求解前述 ADL 模型，得到</li></ul><p><span class="math display">\[y_{t} = \frac{c_d z_{t-d}}{(1-a_1 L)} + \frac{\varepsilon_t}{(1-a_1 L)}\]</span></p><ul><li>根据滞后算子的性质，展开表达式 <spanclass="math inline">\(\dfrac{c_d z_{t-d}}{(1-a_1 L)}\)</span>，得到</li></ul><p><span class="math display">\[y_{t} =c_d(z_{t-d}+a_1z_{t-d-1}+a_1^2z_{t-d-2}+a_1^3z_{t-d-3}+\cdots)+\frac{\varepsilon_t}{(1-a_1L)}\]</span></p><ul><li>我们通过用 <span class="math inline">\(z_t, z_{t-1}, \cdots\)</span>依次乘以 <span class="math inline">\(y_t\)</span>就可以得到互协方差(cross-covariances)。</li><li>进一步依次计算期望值，写出一般形式：</li></ul><p><span class="math display">\[E\left(y_{t} z_{t-i}\right)=\left\{\begin{array}{ll}0, &amp; \text { 当} i&lt;d \\ c_{d} a_1^{i-d} \sigma_{z}^{2}, &amp; \text { 当 } i \geqd\end{array}\right.\]</span></p><p><strong>第三步</strong>：代入得到互协方差 CCF 函数</p><p><span class="math display">\[\rho_{y z}(i)=\frac{\operatorname{cov}\left(y_{t},z_{t-i}\right)}{\sigma_{y} \sigma_{z}}=\frac{E\left(y_{t}z_{t-i}\right)}{\sigma_{y} \sigma_{z}}=\left\{\begin{array}{ll}0, &amp;\text { 当 } i&lt;d \\ \dfrac{c_{d} a_1^{i-d} \sigma_{z}}{\sigma_{y}},&amp; \text { 当 } i \geq d\end{array}\right.\]</span></p><ul><li><span class="math inline">\(Cov(X,Y) = E(X - EX)(Y -EY)=E(XY)-EXEY\)</span>，且 <span class="math inline">\({z_t}\)</span>白噪声，<span class="math inline">\(E(z_t)=0\)</span></li><li>第一个非零的互相关系数的大小的绝对值与 <spanclass="math inline">\(c_d\)</span> 和 <spanclass="math inline">\(a_1\)</span> 的数值正相关</li><li>此后，互相关系数按照比例 <span class="math inline">\(a_1\)</span>衰减。<strong>互相关图的衰减与序列 <spanclass="math inline">\(y_t\)</span> 的 AR 相匹配。</strong></li><li>互相关系数为 <span class="math inline">\(E(y_t z_{t-i}) / (\sigma_y\sigma_z)\)</span>。在文献中，用 <span class="math inline">\(E(y_tz_{t-i}) / \sigma_z^2\)</span>表示标准化互协方差的做法很普遍。对两种表示方法的选择无关紧要，因为互协方差函数CCF 和标准化的互协方差函数(CCVF)是互成比例的。根据互协方差为 <spanclass="math inline">\(E(y_t z_{t-i})\)</span>，CCVF 为</li></ul><p><span class="math display">\[\gamma_{yz}(i) = \begin{cases} 0, &amp; \text{当 } i &lt; d \\ c_d,&amp; \text{当 } i = d \\ a_1^{i-d-1} (c_d a_1 + c_{d+1}), &amp;\text{当 } i \geq d + 1 \end{cases}\]</span></p><p>它前面的规律仍然适用：当 <spanclass="math inline">\(i&gt;d+1\)</span> 时，CCVF 呈指数衰减，衰减比例为<span class="math inline">\(a_1\)</span>。</p><p><strong>更高阶 AR 过程的情况</strong></p><ul><li>当向模型中加入 <span class="math inline">\(y_t\)</span> 的滞后项<span class="math inline">\(y_{t-2}\)</span>（系数设定为 <spanclass="math inline">\(a_2\)</span>），即保持 <spanclass="math inline">\(C(L)\)</span> 不变、改变 <spanclass="math inline">\(A(L)\)</span> 的形式时，<spanclass="math inline">\(\gamma_{yz}(i)\)</span> 存在如下关系：</li></ul><p><span class="math display">\[\gamma_{yz}(i) = a_1 \gamma_{yz}(i-1) + a_2 \gamma_{yz}(i-2) \quad i\geq d+2\]</span></p><ul><li>所刻画的 <span class="math inline">\(\gamma_{yz}(i)\)</span>的变化趋势与 <span class="math inline">\(A(L)\)</span> 对应的 AR(2) 的ACF 变化趋势也完全一致。</li><li>拓展地看，当 <span class="math inline">\(\{ z_t \}\)</span>为白噪声序列时，CCVF 从某一滞后期后的变化趋势能够大致反映出 <spanclass="math inline">\(A(L)\)</span> 的形式。此外，CCVF 也能大致反映<span class="math inline">\(C(L)\)</span> 的形式：CCVF 的第一个非零值与<span class="math inline">\(C(L)\)</span>的第一个非零滞后项相对应；其峰值绝对值在 <spanclass="math inline">\(C(L)\)</span> 最大滞后项附近。</li></ul></blockquote><p>理论上，互相关函数 CCF 与 CCVF 具有如下的特征：</p><ol type="1"><li>在多项式 <span class="math inline">\(C(L)\)</span>的第一个非零元素出现之前，所有的 <spanclass="math inline">\(\gamma_{yz}(i)=0\)</span>。</li><li>CCVF 中的峰值表示 <span class="math inline">\(C (L)\)</span>的非零元素。因此滞后期 <span class="math inline">\(d\)</span>处的峰值表示 <span class="math inline">\(z_{t-d}\)</span> 直接影响 <spanclass="math inline">\(y_t\)</span>。</li><li>所有的峰值都以比例 <span class="math inline">\(a_1\)</span>衰减。收敛性暗示 <span class="math inline">\(a_1\)</span> 的绝对值小于1。如果 <spanclass="math inline">\(0&lt;a_1&lt;1\)</span>，则互协方差是直接衰减的，而如果<spanclass="math inline">\(-1&lt;a_1&lt;0\)</span>，<strong>则互协方差是震荡衰减的</strong>。</li></ol><h3 id="523-滤波与-adl-模型估计">5.2.3 滤波与 ADL 模型估计</h3><p>现在我们知道。可以通过 CCF 或 CCVF 判断出 A (L) 和 C (L)的阶数，但是这一结论是在 <span class="math inline">\({z_t}\)</span>为白噪音序列的前提下推导的，更一般的情况是：假设它为一个平稳 ARMA过程：</p><p><span class="math display">\[D(L)z_t = E(L)\varepsilon_{zt}\]</span></p><p>其中 <span class="math inline">\(D(L)\)</span>、<spanclass="math inline">\(E(L)\)</span> 为滞后算子多项式，<spanclass="math inline">\(\varepsilon_{zt}\)</span> 为白噪音序列。</p><p>转换后，有：<spanclass="math inline">\(z_t=\dfrac{E(L)}{D(L)}\varepsilon_{zt}\)</span>。进而有，</p><p><span class="math display">\[\begin{split} y_t&amp;=a_0+A(L)y_{t-1}+C(L)\frac{E(L)}{D(L)}\varepsilon_{zt}+B(L)\varepsilon_t\\ \downarrow \\\frac{D(L)}{E(L)}y_t&amp;=\frac{D(L)}{E(L)}a_0+\frac{D(L)}{E(L)}A(L)y_{t-1}+C(L)\varepsilon_{zt}+\frac{D(L)}{E(L)}B(L)\varepsilon_t\end{split}\]</span></p><p>令 <spanclass="math inline">\(y_{ft}=\dfrac{D(L)}{E(L)}y_t\)</span>，则上式可转换为如下形式：</p><p><span class="math display">\[y_{ft}=\frac{D(L)}{E(L)}a_0+A(L)y_{f(t-1)}+C(L)\varepsilon_{zt}+\frac{D(L)}{E(L)}B(L)\varepsilon_t\]</span></p><ul><li>这样，传递函数模型中的外生变量就转换成白噪音的形式了（即 <spanclass="math inline">\(\varepsilon_{zt}\)</span>）。</li><li>对 <span class="math inline">\(y_{ft}\)</span> 和 <spanclass="math inline">\(\varepsilon_{zt}\)</span>求互相关函数，其变化趋势仍能反映出原始模型中 <spanclass="math inline">\(A(L)\)</span>、<spanclass="math inline">\(C(L)\)</span> 的形式。</li><li><span class="math inline">\(\dfrac{D(L)}{E(L)}\)</span> 称为<strong>滤波</strong>（filter）；<spanclass="math inline">\(y_{ft}\)</span> 是 <spanclass="math inline">\(y_t\)</span> 经过滤波后的值，称为<strong>新息</strong>（innovation）。</li></ul><blockquote><p>[!tip] <strong>传递函数模型估计的步骤</strong>：</p><ol type="1"><li><p><strong>使用 AR 模型拟合 <spanclass="math inline">\(z_t\)</span></strong></p><ul><li>若 <span class="math inline">\(z_t\)</span> 存在自相关，用<strong>AR 模型</strong> 捕捉其滞后结构。</li><li>同时，可能需检验 <span class="math inline">\(z_t\)</span>的平稳性（如 ADF 检验），避免伪回归。</li></ul></li><li><p><strong>识别 <span class="math inline">\(C (L)\)</span>的合理候选（分布滞后项）</strong></p><ul><li>首先，使用 <span class="math inline">\(z_t\)</span> 的 AR模型结果，借助滤波 <spanclass="math inline">\(\dfrac{D(L)}{E(L)}\)</span> <strong>构建过滤序列<span class="math inline">\(y_{ft}\)</span></strong>，以去除 <spanclass="math inline">\(y_t\)</span> 中与 <spanclass="math inline">\(z_t\)</span> 相关的自相关噪声，突出 <spanclass="math inline">\(z_t\)</span> 对 <spanclass="math inline">\(y_t\)</span> 的直接影响。</li><li><strong>识别 <span class="math inline">\(C (L)\)</span></strong>：通过分析 <span class="math inline">\(y_{ft}\)</span> 与 <spanclass="math inline">\(z_t\)</span> 的互相关函数（CCF），确定 <spanclass="math inline">\(z_t\)</span> 的滞后阶数，初步构建分布滞后项 <spanclass="math inline">\(C (L) z_t\)</span>。</li></ul></li><li><p><strong>识别 <span class="math inline">\(A (L)\)</span>的合理候选（自回归项）</strong></p><ul><li>直接 <span class="math inline">\(y_t\)</span> 对 <spanclass="math inline">\(z_t\)</span> 进行回归（如 <spanclass="math inline">\(y_t = c_0 z_t + c_1 z_{t-1} +e_t\)</span>），得到初步的分布滞后模型。</li><li><strong>分离自回归项 <span class="math inline">\(A(L)\)</span></strong>：通过残差分析（如 ACF/PACF 检验）识别 <spanclass="math inline">\(y_t\)</span>的自回归结构。例如，若残差存在一阶自相关，则引入 <spanclass="math inline">\(y_{t-1}\)</span>。</li></ul></li><li><p><strong>将步骤 2 和 3 的结果整合为完整 ADL 模型</strong></p><ul><li>同时估计 A(L) 和 C(L) 。</li></ul><p><span class="math display">\[Y_t = \underbrace{a_1 y_{t-1} + a_2 y_{t-2} + \dots}_{A (L)} +\underbrace{c_0 z_t + c_1 z_{t-1} + \dots}_{C (L)} + \varepsilon_t\]</span></p><ul><li>注意：如果 <span class="math inline">\({y_t}\)</span> 、 <spanclass="math inline">\({z_t}\)</span>任一个非平稳，则样本的互相关系数没有意义。</li></ul></li></ol></blockquote><h2 id="53-向量自回归var模型">5.3 向量自回归（VAR）模型</h2><p>上篇介绍的传递函数模型的假设是，<spanclass="math inline">\(z_t\)</span> 会影响到 <spanclass="math inline">\(y_t\)</span>，而 <spanclass="math inline">\(y_t\)</span> 不会影响 <spanclass="math inline">\(z_t\)</span>，因此称 <spanclass="math inline">\(z_t\)</span> 为外生变量（exogenousvariable）。那么，如果 <span class="math inline">\(z_t\)</span> 和 <spanclass="math inline">\(y_t\)</span>以及更多的变量之间能够相互影响呢？</p><ul><li>此时，它们就是内生变量（endogenous variable）。</li><li>当我们难以判断变量是否外生，传递函数分析的自然扩展就是均等地对待每一个变量。</li><li><strong>向量自回归模型</strong>（vector autoregressivemodel）研究了内生变量之间的相互影响作用。</li></ul><h3 id="531-var-模型含义与性质">5.3.1 VAR 模型含义与性质</h3><p>考虑如下简单的双变量系统：</p><p><span class="math display">\[y_t = \alpha_1 + \beta_1 z_t + B_1(L)y_{t-1} + C_1(L)z_{t-1} +\varepsilon_{y_t}\]</span></p><p><span class="math display">\[z_t = \alpha_2 + \beta_2 y_t + B_2(L)y_{t-1} + C_2(L)z_{t-1} +\varepsilon_{z_t}\]</span></p><p>式中，<span class="math inline">\(B_1 (L)\)</span>、<spanclass="math inline">\(B_2 (L)\)</span>、<span class="math inline">\(C_1(L)\)</span>、<span class="math inline">\(C_2 (L)\)</span>是阶数相同的滞后算子多项式，</p><ul><li>假设其阶数为 <span class="math inline">\(p\)</span>，它也称作是 VAR模型的阶数。</li><li>对于每个变量来说，预测变量包括本身的 <spanclass="math inline">\(p\)</span> 阶滞后值、其他变量的 <spanclass="math inline">\(p\)</span> 阶滞后值、其他变量的当期值（<spanclass="math inline">\(z_t\)</span> 或 <spanclass="math inline">\(y_t\)</span>）。</li><li><span class="math inline">\(\varepsilon_{yt}\)</span> 和 <spanclass="math inline">\(\varepsilon_{zt}\)</span>为白噪声，且彼此互不相关。</li></ul><p>将模型形式中的当期值移到等号左侧，变成如下形式：</p><p><span class="math display">\[y_t - \beta_1 z_t = \alpha_1 + B_1 (L) y_{t-1} + C_1 (L) z_{t-1} +\varepsilon_{y_t}\]</span></p><p><span class="math display">\[-\beta_2 y_t + z_t = \alpha_2 + B_2 (L) y_{t-1} + C_2 (L) z_{t-1} +\varepsilon_{z_t}\]</span></p><p>以矩阵形式写出， <span class="math display">\[\begin{bmatrix}1 &amp; -\beta_1 \\-\beta_2 &amp;1\end{bmatrix}\begin{bmatrix}y_t \\z_t\end{bmatrix}=\begin{bmatrix}\alpha_1 \\\alpha_2\end{bmatrix}+\begin{bmatrix}B_1 (L) &amp; C_1 (L) \\B_2 (L) &amp; C_2(L)\end{bmatrix}\begin{bmatrix}y_{t-1}\\z_{t-1}\end{bmatrix}+\begin{bmatrix}\varepsilon_{y_t}\\\varepsilon_{z_t}\end{bmatrix}\]</span></p><p>再变换得，</p><p><span class="math display">\[\begin{bmatrix}y_t \\z_t\end{bmatrix}=\begin{bmatrix}1 &amp; -\beta_1 \\-\beta_2 &amp; 1\end{bmatrix}^{-1}\begin{bmatrix}\alpha_1 \\\alpha_2\end{bmatrix}+\begin{bmatrix}1 &amp; -\beta_1 \\-\beta_2 &amp; 1\end{bmatrix}^{-1}\begin{bmatrix}B_1 (L) &amp; C_1 (L) \\B_2 (L) &amp; C_2 (L)\end{bmatrix}\begin{bmatrix}y_{t-1} \\z_{t-1}\end{bmatrix}+\begin{bmatrix}1 &amp; -\beta_1 \\-\beta_2 &amp; 1\end{bmatrix}^{-1}\begin{bmatrix}\varepsilon_{y_t} \\\varepsilon_{z_t}\end{bmatrix}\]</span></p><p>使用一些符号代替上式中的矩阵，得到下式：</p><p><span class="math display">\[X_t = A_0 + AX_{t-1} + e_t\]</span></p><p>式中，<span class="math inline">\(X_t = [y_t,z_t]^{T}\)</span>，其余依次类推。</p><ul><li>这样，等号右侧不再包含变量的当期值，这被称为 <strong>VAR模型的标准形式</strong>，</li><li>可以看出，模型的基本形式是弱平稳过程的自回归表达式。</li><li>包含当期值的形式则被称为 <strong>结构性 VAR 模型</strong>。</li><li>变量当期值之间的相关性被隐藏在模型残差 <spanclass="math inline">\(e_t\)</span> 之中。它是两个冲击 <spanclass="math inline">\(\varepsilon\)</span> 的组合</li></ul><p><span class="math display">\[e_t = \left[\begin{array}{cc}1 &amp; -\beta_1 \\-\beta_2 &amp; 1\end{array}\right]^{-1} \left[\begin{array}{c}\varepsilon_{y_t} \\\varepsilon_{z_t}\end{array}\right] = \frac{1}{1 - \beta_1 \beta_2}\left[\begin{array}{cc}1 &amp; \beta_1 \\\beta_2 &amp; 1\end{array}\right] \left[\begin{array}{c}\varepsilon_{y_t} \\\varepsilon_{z_t}\end{array}\right]\]</span></p><p>显然，若变量的当期值之间存在联系，即 <spanclass="math inline">\(\beta_1\)</span> 和 <spanclass="math inline">\(\beta_2\)</span> 至少有一个不为 0，则 <spanclass="math inline">\(\varepsilon_{y_t}\)</span> 和 <spanclass="math inline">\(\varepsilon_{z_t}\)</span>必然相关；反之，若变量的当期值不存在相互影响，则 <spanclass="math inline">\(\varepsilon_{y_t}\)</span> 和 <spanclass="math inline">\(\varepsilon_{z_t}\)</span> 也不相关。</p><blockquote><p>[!note] 矩阵求逆 对于一个 2×2 矩阵 A，其逆矩阵为： <spanclass="math display">\[A = \left[\begin{array}{cc}a &amp; b \\c &amp; d\end{array}\right]= ad-bc\quad \to  \quadA^{-1} = \frac{1}{|A|}adj(A) = \frac{1}{ad - bc} \left[\begin{array}{cc}d &amp; -b \\-c &amp; a\end{array}\right]\]</span></p><p>Why?</p><ul><li>伴随矩阵 adj(A) 是余子式矩阵的转置</li><li>A 的余子式矩阵：<span class="math inline">\(\left[\begin{array}{cc}d&amp; -c \\-b &amp; a\end{array}\right]\)</span></li><li>进一步 <strong>转置</strong> 才得到伴随矩阵 adj(A) 。</li></ul><p>应用到我们的矩阵：</p><p><span class="math display">\[A = \left[\begin{array}{cc}1 &amp; -\beta_1 \\-\beta_2 &amp; 1\end{array}\right]=  1 - \beta_1 \beta_2\toA^{-1} = \frac{1}{1 - \beta_1 \beta_2} \left[\begin{array}{cc}1 &amp; \beta_1 \\\beta_2 &amp; 1\end{array}\right]\]</span></p></blockquote><p>因此：</p><p><span class="math display">\[\begin{cases}e_{1 t}=\dfrac{\varepsilon_{y t}-\beta_1 \varepsilon_{zt}}{1-\beta_1\beta_2}\\e_{2 t}=\dfrac{\varepsilon_{z t}-\beta_2 \varepsilon_{yt}}{1-\beta_1\beta_2}\end{cases}\]</span></p><p>因为 <span class="math inline">\(\varepsilon_{y}\)</span> 和 <spanclass="math inline">\(\varepsilon_{z}\)</span>服从白噪声过程，所以，<span class="math inline">\(e_{1t}\)</span> 和<span class="math inline">\(e_{2t}\)</span> 的均值为0，方差恒定且独立不相关（自协方差 = 0，如果两个冲击相关，互协方差不为0；如果两个冲击不相关，互协方差为 0）。</p><p>顺理成章地，我们可以推广到 k 维，也就是 k 元时间序列的 VAR 模型。</p><p><span class="math display">\[Y_{t}=\Phi_{0}+\Phi_{1} Y_{t-1}+\cdots+\Phi_{p} Y_{t-p}+BX_{t}+\varepsilon_{t}, \quad t = 1,2, \cdots, T\]</span></p><p>其中</p><p><span class="math display">\[\boldsymbol{Y}_{t}=\left (\begin{array}{c}Y_{1 t} \\Y_{2 t} \\\vdots \\Y_{k t}\end{array}\right), \quad \boldsymbol{\varepsilon}_{t}=\left(\begin{array}{c}\varepsilon_{1 t} \\\varepsilon_{2 t} \\\vdots \\\varepsilon_{k t}\end{array}\right), \quad \boldsymbol{\Phi}_{0}=\left (\begin{array}{c}\phi_{10} \\\phi_{20} \\\vdots \\\phi_{k 0}\end{array}\right)\]</span></p><p><span class="math display">\[\boldsymbol{\Phi}_{i}=\left (\begin{array}{ccc}\phi_{11}(i) &amp; \cdots &amp; \phi_{1 k}(i) \\\phi_{21}(i) &amp; \cdots &amp; \phi_{2 k}(i) \\\vdots &amp; \ddots &amp; \vdots \\\phi_{k 1}(i) &amp; \cdots &amp; \phi_{k k}(i)\end{array}\right), i = 1,2, \cdots, p\]</span></p><h3 id="532-多元时间序列平稳性可逆性">5.3.2多元时间序列平稳性、可逆性</h3><h4 id="5321-平稳性">5.3.2.1 平稳性</h4><p>如果一个 <span class="math inline">\(k\)</span> 维时间序列 <spanclass="math inline">\(Y_t\)</span> 弱平稳，它需要满足下列两个条件：</p><ul><li><span class="math inline">\(E (Y_t) = \mu\)</span>;</li><li><span class="math inline">\(Cov (Y_t) = E[(Y_t - \mu)(Y_t - \mu)^T]= V\)</span>, 其中 <span class="math inline">\(V\)</span> 是 <spanclass="math inline">\(k \times k\)</span> 维的常数正定矩阵。</li></ul><p>为了使模型平稳，当 <span class="math inline">\(k \to \infty\)</span>时，系数矩阵的幂收敛到零矩阵：<spanclass="math inline">\(\Phi_1^{\infty} = 0\)</span></p><ul><li><strong>数学条件</strong>：矩阵 <spanclass="math inline">\(\Phi_1\)</span> 的特征根全部小于 1。</li><li>设 <span class="math inline">\(\Phi_1\)</span> 对应的特征根为 <spanclass="math inline">\(\lambda\)</span>，即 <spanclass="math inline">\(\lambda\)</span> 是方程 <spanclass="math inline">\(|\lambda I_2-\Phi_1|=0\)</span>的根。为使模型平稳，方程的根必须在单位圆内（也可以表述为：对应的特征方程的根全在单位圆外）</li></ul><h4 id="5322-可逆性">5.3.2.2 可逆性</h4><blockquote><p>[!tip] 多元时间序列可逆的定义： 如果一个 <spanclass="math inline">\(k\)</span> 维时间序列 <spanclass="math inline">\(Y_t\)</span> 可以表示如下形式则称该序列可逆：<spanclass="math display">\[Y_t = c + \sum_{j=1}^{\infty} \pi_j Y_{t-j} +\varepsilon_t\]</span></p><p>根据可逆性定义知，<span class="math inline">\(k\)</span> 元 VAR(<span class="math inline">\(p\)</span>) 模型总是可逆的。</p><ul><li>事实上，请回忆：AR 模型是可逆的。</li><li>对于 VAR (<span class="math inline">\(p\)</span>) 模型，对任意 <spanclass="math inline">\(j &gt; p\)</span>，<spanclass="math inline">\(\pi_j = 0\)</span>。因此也是可逆的。</li></ul></blockquote><p>由于 VAR 具有可逆性，每一个 VAR 模型都可以表示成为一个无限阶的向量 MA(∞) 过程。 我们知道双变量的 VAR 模型的标准形式如下：</p><p><span class="math display">\[X_t = A_0 + AX_{t-1} + e_t\]</span></p><p>通过不断迭代，可以将上式进行如下转换：</p><p><span class="math display">\[\begin{split}X_t =&amp; A_0 + AX_{t-1} + e_t \\=&amp; A_0 + A (A_0 +AX_{t-2} + e_{t-1}) + e_t \\=&amp; (I + A) A_0 + A^2 X_{t-2} + Ae_{t-1} + e_t \\&amp;... \\=&amp; (I + A + A^2 + ... + A^n) + A^{n+1}X_{t-n-1} + \sum_{i = 0}^{n}A^ie_{t-i}\end{split}\]</span></p><p>当 <span class="math inline">\(n \to \infty\)</span>，<spanclass="math inline">\(A^{n+1} \to 0\)</span>，而 <spanclass="math inline">\(\sum_{i=0}^{n} A^ie_{t-i}\)</span> 的期望始终为0，则 <span class="math inline">\(I + A + A^2 + ... + A^n\)</span> 为<span class="math inline">\(X_t\)</span> 的数学期望，记为 <spanclass="math inline">\(\mu\)</span>。则有，</p><p><span class="math display">\[X_t = \mu + \sum_{i = 0}^{\infty} A^ie_{t-i}\]</span></p><p>我们还知道，</p><p><span class="math display">\[e_t = \frac{1}{1-\beta_1\beta_2}\begin{bmatrix} 1 &amp; \beta_1 \\\beta_2 &amp; 1 \end{bmatrix}\begin{bmatrix} \varepsilon_{yt} \\\varepsilon_{zt} \end{bmatrix}=\frac{1}{1-\beta_1\beta_2}\begin{bmatrix} 1 &amp; \beta_1 \\ \beta_2&amp; 1 \end{bmatrix}\varepsilon_t\]</span></p><p>代入得到，</p><p><span class="math display">\[X_t = \mu + \frac{1}{1-\beta_1\beta_2}\sum_{i = 0}^{\infty}A^i\begin{bmatrix} 1 &amp; \beta_1 \\ \beta_2 &amp; 1\end{bmatrix}\varepsilon_{t-i}\]</span></p><p>这被称为 VAR 的 <strong>移动平均形式 VMA</strong>（vector movingaverage）。</p><h3 id="533-var-参数估计识别与预测">5.3.3 VAR 参数估计、识别与预测</h3><ul><li>对于平稳VAR(p)模型，使用普通最小二乘估计和广义最小二乘估计的结果是相同的；<ul><li>在正态分布的假设下，最大似然估计与最小二乘估计的结果近似相等。</li><li>一旦 VAR 被估计以后，它就能作为一个多元预测模型。</li><li>由于无约束 VAR是过度参数化的，因而，预测可能不可信。为了得到一个精简模型，许多预测者将VAR 中不重要的系数排除并用 SUR 重新估计。这就是近似 VAR模型，在估计得到近似 VAR 模型后，用它进行预测。</li><li>另一些人在估计参数时，将 VAR与贝叶斯方法联系，基于后验分布进行统计推断。</li></ul></li><li><strong>定阶</strong>：建立 VAR模型除了要满足平稳性条件外，还应该正确确定滞后期。如果滞后期太少，误差项的自相关会很严重，并导致参数的非一致性估计。在VAR 模型中适当加大 p值（增加滞后变量个数），可以消除误差项中存在的自相关；但从另一方面看，p值又不宜过大，p值过大会导致自由度减小，直接影响模型参数估计量的有效性。<strong>我们可以基于似然比检验结果和信息准则确定滞后阶数p。</strong>（课本 5.8 节）<ul><li><strong>似然比检验</strong>（Likelihood RatioTest, <strong>LR</strong>），其思路是比较 VAR(<spanclass="math inline">\(k\)</span>) 和 VAR(<spanclass="math inline">\(k+1\)</span>) 模型的拟合能力。原假设 H0：<spanclass="math inline">\(Φ_l\)</span> = 0，备择假设 H1：<spanclass="math inline">\(Φ_l\)</span> ≠0。通过逐步回归，比较模型的似然比，构建统计量。<spanclass="math display">\[LR = −2(\log L(k) − \log L(k+1)) \simχ²(N²)\]</span> k 表示 VAR 模型中滞后变量的最大滞后期。当 VAR模型滞后期的增加不会给极大似然函数值带来显著性增大时，即 LR统计量的值小于临界值时，新增加的滞后变量对 VAR 模型毫无意义。</li><li><strong>信息准则</strong>：<span style="background:#fff88f">AIC可能会超调（overshooting）真实值p；Hannan-QuinnIC和BIC结果比较一致。</span>（详见 <ahref="https://www.math.pku.edu.cn/teachers/lidf/course/fts/ftsnotes/html/_ftsnotes/fts-var.html#var-estorder">Link</a>）</li></ul></li><li><strong>模型验证</strong>：多元混成检验。<ul><li>准确的模型的残差应该是白噪声序列。</li><li>多元混成检验是为了检验残差的序列相关性，其原假设 H0 为：残差相关矩阵<span class="math inline">\(ρ_{a1} = · · · = ρ_{a m} =0\)</span>，备择假设 H1 为：对于某些 1 ≤ j ≤ m，<spanclass="math inline">\(ρ_{a j}= 0\)</span>。在这组假设下构造统计量。</li><li>多元混成检验把一元的 Ljung-Box 白噪声检验推广到了多元的情形。</li></ul></li></ul><h3 id="534-var-的脉冲响应函数">5.3.4 VAR 的脉冲响应函数</h3><p>VAR模型研究的是多个时间序列变量之间的相互影响关系，但是模型估计出的参数结果及其显著水平似乎并不能直观地反映这种影响关系，而要想直观地呈现这种关系，就需要使用<strong>脉冲响应函数</strong>（impulse response function）。</p><p>对脉冲响应函数进行描图是展现 |y| 与|z|对各种冲击的响应行为的实用方法。</p><p>我们从 VAR 的移动平均形式（VMA）出发：</p><p><span class="math display">\[X_t = \mu + \frac{1}{1-\beta_1\beta_2}\sum_{i = 0}^{\infty}A^i\begin{bmatrix} 1 &amp; \beta_1 \\ \beta_2 &amp; 1\end{bmatrix}\varepsilon_{t-i}\]</span></p><p>通过定义如下符号：</p><p><span class="math display">\[\Phi_{i}=\frac{1}{1-\beta_1 \beta_2}A^i \begin{bmatrix}1&amp;\beta_1\\\beta_2&amp;1\end{bmatrix}\]</span></p><p>VMA 可以写成如下形式：</p><p><span class="math display">\[X_t = \mu + \sum_{i=0}^\infty \Phi_i \varepsilon_{t-i}= \mu + \Phi_0\varepsilon_t + \Phi_1 \varepsilon_{t-1} + \Phi_2 \varepsilon_{t-2} +\ldots\]</span></p><p>可以看出，<span class="math inline">\(\Phi_i\)</span> 中的元素刻画了<span class="math inline">\(\varepsilon_{t-i}\)</span>的冲击对时间序列变量当期值的影响（也就是偏导数）。</p><p>以双变量为例，每个 <span class="math inline">\(\Phi_i\)</span>都是一个二行、二列的矩阵：</p><ul><li>第一行、第一列：<spanclass="math inline">\(\varepsilon_{yt-i}\)</span> 的单位变化对 <spanclass="math inline">\(y_t\)</span> 的影响作用；</li><li>第一行、第二列：<spanclass="math inline">\(\varepsilon_{zt-i}\)</span> 的单位变化对 <spanclass="math inline">\(y_t\)</span> 的影响作用；</li><li>第二行、第一列：<spanclass="math inline">\(\varepsilon_{yt-i}\)</span> 的单位变化对 <spanclass="math inline">\(z_t\)</span> 的影响作用；</li><li>第二行、第二列：<spanclass="math inline">\(\varepsilon_{zt-i}\)</span> 的单位变化对 <spanclass="math inline">\(z_t\)</span> 的影响作用。 <spanclass="math inline">\(\Phi_i\)</span>每个位置的元素构成了一个脉冲响应函数，反映了不同滞后期的 <spanclass="math inline">\(\epsilon_{t-i}\)</span> 的单位变化对 <spanclass="math inline">\(X_t\)</span> 的影响的变化趋势。</li><li>对于每一个误差项，内生变量都对应着一个脉冲响应函数。这样，一个含有 4个内生变量的 VAR 将有 16 个脉冲响应函数。</li><li>对于 VAR(p)模型，有类似的分析，只是脉冲反应函数更加复杂。</li></ul><h3 id="535-格兰杰因果检验">5.3.5 格兰杰因果检验</h3><p>VAR 模型还可用来检验<strong>一个变量与另一个变量是否存在因果关系</strong>，</p><ul><li><span class="math inline">\(x_t\)</span> 对 <spanclass="math inline">\(y_t\)</span> 是否存在因果关系的检验可通过检验 VAR模型以 <span class="math inline">\(y_t\)</span>为被解释变量的方程中是否可以把 <span class="math inline">\(x_t\)</span>的全部滞后变量剔除掉而完成。</li><li>比如 VAR 模型中以 <span class="math inline">\(y_t\)</span>为被解释变量的方程表示如下：</li></ul><p><span class="math display">\[y_t = \sum_{i=1}^{k} \alpha_i y_{t-i} + \sum_{i=1}^{k} \beta_i x_{t-i} +u_{1,t}\]</span></p><ul><li>则检验 <span class="math inline">\(x_t\)</span> 对 <spanclass="math inline">\(y_t\)</span> 存在格兰杰非因果性的零假设是</li></ul><p><span class="math display">\[H_0: \beta_1 = \beta_2 = \ldots = \beta_k = 0\]</span></p><ul><li>为了比较无约束与约束的模型，使用对数似然比检验（LR检验），得到的统计量在约束参数等于零的零假设下渐近服从卡方分布。</li><li>如果 <span class="math inline">\(x_t\)</span>的任何一个滞后变量的回归参数的估计值存在显著性，则拒绝原假设，<spanclass="math inline">\(x_t\)</span> 对 <spanclass="math inline">\(y_t\)</span> 存在格兰杰因果关系。</li><li><strong>注意：</strong> 在格兰杰因果检验中，我们关心 <spanclass="math inline">\(\beta\)</span> （二者之间的关系）而非 <spanclass="math inline">\(\alpha\)</span>；关心滞后项系数（而不关心当期<span class="math inline">\(i=0\)</span> 对应的 <spanclass="math inline">\(x_t\)</span> 系数）。</li><li>关于格兰杰检验的更多细节详见课本 5.8.1 -5.8.2 节。</li><li>格兰杰因果关系检验经常被解释为在 VAR模型中，某个变量是否可以用来提高对其他相关变量的预测能力。因此格兰杰因果关系的实质是一种“预测”关系，而并非真正汉语意义上的“因果关系”。</li></ul><h3 id="536-结构性-var-估计">5.3.6 结构性 VAR 估计</h3><ul><li>在 20 世纪 80年代，传统的联立方程模型曾经很流行。这些结构模型越建越大，仿佛能够很好的反应样本的情况，但是对样本外的数据预测能力却很弱。因此Sim（1980）提出了标准 VAR 模型。</li><li>标准 VAR只能捕捉变量间相关性，脉冲效应函数并不是唯一的，并且不包含变量之间的当期影响。</li><li>结构性VAR（SVAR）借助结构限制条件，将复合冲击分解为结构性冲击，能够揭示经济变量因果机制，并且考虑变量之间的当期影响。这表明：SVAR是在标准 VAR模型基础上，通过引入经济理论限制来识别变量间同期因果关系和特定冲击影响。</li><li>估计方法：通常需先确定结构限制条件，再进行参数估计。比如可利用Choleski分解，它能将协方差矩阵分解为下三角矩阵与其转置的乘积形式，为识别结构性冲击提供一种方式，但变量排序会影响结果。<strong>SVAR 进行识别</strong></li><li>短期约束（Sim-Bernanke 方法）假设某些冲击对特定变量无即时影响。</li><li>长期约束（Blanchard-Quah 方法）假设某些冲击长期不影响特定变量。</li></ul><h2 id="第五章练习">第五章练习</h2><ol type="1"><li>已知双变量 VAR 模型的矩阵形式如下：</li></ol><p><span class="math display">\[\begin{pmatrix}y_{1t}\\ y_{2t}\end{pmatrix}=\begin{pmatrix}0.5 &amp;0.3\\ 0.3 &amp; 0.5\end{pmatrix}\begin{pmatrix}y_{1t-1}\\y_{2t-1}\end{pmatrix}+\begin{pmatrix}u_{1t}\\ u_{2t}\end{pmatrix}\]</span></p><p>其中，<span class="math inline">\(u_{1t}\)</span> 和 <spanclass="math inline">\(u_{2t}\)</span> 是白噪声过程，且 Cov (<spanclass="math inline">\(u_{1t},u_{2t})=0\)</span>。下列说法正确的是（）</p><p>A. 其它因素不变，<span class="math inline">\(u_{1t}\)</span> 变动 1个单位，<span class="math inline">\(y_{1t}\)</span> 将变动 1 个单位 B.其它因素不变，<span class="math inline">\(u_{1t}\)</span> 变动 1个单位，<span class="math inline">\(y_{1t+1}\)</span> 将变动 0.5 个单位C. 其它因素不变，<span class="math inline">\(u_{1t}\)</span> 变动 1个单位，<span class="math inline">\(y_{2t}\)</span> 将变动 0.3 个单位 D.其它因素不变，<span class="math inline">\(u_{1t}\)</span> 变动 1个单位，<span class="math inline">\(y_{2t+1}\)</span> 将变动 0.3 个单位E. 其它因素不变，<span class="math inline">\(u_{1t}\)</span> 变动 1个单位，<span class="math inline">\(y_{1t+2}\)</span> 将变动 0.34个单位</p><p>分析：改写</p><p><span class="math display">\[\begin{cases}Y_{1 t} = 0.5 y_{1 t-1} + 0.3 y_{2 t-1} + u_{1 t}, \\Y_{2 t} = 0.3 y_{1 t-1} + 0.5 y_{2 t-1} + u_{2 t},\end{cases}\]</span></p><p>通过计算脉冲响应函数，分析 <span class="math inline">\(u_{1 t} =1\)</span> 在时间 <span class="math inline">\(t = 0\)</span>的冲击：</p><ul><li><strong>在 <spanclass="math inline">\(t=0\)</span>（冲击当期）</strong>：</li><li><span class="math inline">\(y_{10} = 0.5 \cdot y_{1,-1} + 0.3 \cdoty_{2,-1} + u_{10} = 0.5 \cdot 0 + 0.3 \cdot 0 + 1 = 1\)</span></li><li><span class="math inline">\(y_{20} = 0.3 \cdot y_{1,-1} + 0.5 \cdoty_{2,-1} + u_{20} = 0.3 \cdot 0 + 0.5 \cdot 0 + 0 = 0\)</span></li><li>因此，<span class="math inline">\(y_{1 t}\)</span> 变动 1个单位，<span class="math inline">\(y_{2 t}\)</span> 变动 0个单位。</li><li><strong>在 <spanclass="math inline">\(t=1\)</span>（下一期）</strong>：<ul><li><span class="math inline">\(y_{11} = 0.5 \cdot y_{10} + 0.3 \cdoty_{20} + u_{11} = 0.5 \cdot 1 + 0.3 \cdot 0 + 0 = 0.5\)</span></li><li><span class="math inline">\(y_{21} = 0.3 \cdot y_{10} + 0.5 \cdoty_{20} + u_{21} = 0.3 \cdot 1 + 0.5 \cdot 0 + 0 = 0.3\)</span></li><li>因此，<span class="math inline">\(y_{1 t+1}\)</span> 变动 0.5个单位，<span class="math inline">\(y_{2 t+1}\)</span> 变动 0.3个单位。</li></ul></li><li><strong>在 <spanclass="math inline">\(t=2\)</span>（下两期）</strong>：<ul><li><span class="math inline">\(y_{12} = 0.5 \cdot y_{11} + 0.3 \cdoty_{21} + u_{12} = 0.5 \cdot 0.5 + 0.3 \cdot 0.3 + 0 = 0.25 + 0.09 =0.34\)</span></li><li><span class="math inline">\(y_{22} = 0.3 \cdot y_{11} + 0.5 \cdoty_{21} + u_{22} = 0.3 \cdot 0.5 + 0.5 \cdot 0.3 + 0 = 0.15 + 0.15 =0.3\)</span></li><li>因此，<span class="math inline">\(y_{1 t+2}\)</span> 变动 0.34个单位。</li><li>Ans：选项 A、B、D、E 均正确， C 错误。</li></ul></li></ul><ol start="2" type="1"><li>给定模型：</li></ol><p><span class="math display">\[Y_t = 0.5 y_{t-1} + 0.3\varepsilon_{t-1} + \varepsilon_t\]</span></p><p>已知 <span class="math inline">\(y_3 = 4\)</span>, <spanclass="math inline">\(\varepsilon_3 = 10\)</span>, <spanclass="math inline">\(\varepsilon_4 = 1\)</span>。需要预测 <spanclass="math inline">\(y_5\)</span>。</p><p>答案：<span class="math inline">\(y_5\)</span> 的预测值为3.3。（Hint：<span class="math inline">\(\varepsilon_5\)</span>是未来的误差项。在预测时，我们通常假设未来误差项的期望为0，因为它们是白噪声。）</p><ol start="3" type="1"><li>给定向量移动平均（VMA）表示：</li></ol><p><span class="math display">\[\begin{bmatrix}Y_t \\Z_t\end{bmatrix}=\sum_{i = 0}^{\infty}\begin{bmatrix}\phi_{11}(i) &amp; \phi_{12}(i) \\\phi_{21}(i) &amp; \phi_{22}(i)\end{bmatrix}\begin{bmatrix}\varepsilon_{y, t-i} \\\varepsilon_{z, t-i}\end{bmatrix}\]</span></p><p>问：<span class="math inline">\(\phi_{11}(1)\)</span> 的含义。</p><ul><li>这考察的是脉冲响应的含义。 <spanclass="math inline">\(\phi_{jk}(i)\)</span> 表示滞后 <spanclass="math inline">\(i\)</span> 期时，冲击 <spanclass="math inline">\(\varepsilon_{k}\)</span> 对变量 <spanclass="math inline">\(j\)</span> 的影响系数。</li><li>在本题中， <span class="math inline">\(\phi_{11}(i)\)</span> 是<span class="math inline">\(\varepsilon_{y, t-i}\)</span> 对 <spanclass="math inline">\(y_t\)</span> 的影响系数。特别地，<spanclass="math inline">\(\phi_{11}(1)\)</span> 表示滞后 1 期（即 <spanclass="math inline">\(i = 1\)</span>) 时，<spanclass="math inline">\(\varepsilon_{y, t-1}\)</span> 对 <spanclass="math inline">\(y_t\)</span> 的影响。</li><li>答案： <strong>A</strong>。</li></ul><h1 id="chapter-6协整与误差修正模型">Chapter 6：协整与误差修正模型</h1><blockquote><p>[!Tip] 本章学习目标</p><ol type="1"><li>介绍协整的基本概念，展示它在各种经济模型中的应用。</li><li>介绍协整意味着将非静态变量的随机趋势联系起来。</li><li>考察协整变量的动态路径。由于协整变量的趋势是相联系的，所以，这些变量的动态路径一定与现在偏离均衡关系的离差具有联系。</li><li>阐述 Engle-Granger协整检验。检验过程的计量经济学方法来源于齐次差分方程组的理论。</li><li>Engle-Granger 方法需要用模拟数据说明。</li><li>用实际汇率说明 Engle-Granger 方法。</li><li>阐述 Johansen 完整信息极大似然协整检验。</li><li>介绍怎样限制协整向量。讨论含 I(1)和(2)变量模型的推论。</li><li>用模拟数据说明 Johansen 检验。</li><li>介绍怎样用非稳定变量估计 ADL 模型，研究 ADL 协整检验</li><li>用利率数据比较 Engle-Granger、Johansen、ADL 协整检验。</li></ol></blockquote><h2 id="61-从单整到协整">6.1 从单整到协整</h2><h3 id="611-单整">6.1.1 单整</h3><p>在 <a href="#Chapter%203%20包含趋势的模型">第 3 章</a>的最后，我们介绍了 <strong>【单整】</strong>（Integration）的概念。我们不妨在此回顾一下：</p><p>如果序列在成为稳定序列之前必须经过 <spanclass="math inline">\(d\)</span> 次差分，则该序列被称为 <spanclass="math inline">\(d\)</span> 阶单整。记为 <spanclass="math inline">\(I (d)\)</span>。换句话说，如果序列 <spanclass="math inline">\(x_t\)</span> 是非稳定序列，<spanclass="math inline">\(\Delta^d x_t\)</span> 是稳定序列，则是 <spanclass="math inline">\(x_t\)</span> 序列 <span class="math inline">\(I(d)\)</span>。其中</p><p><span class="math display">\[\Delta x_t = x_t - x_{t-1}, \quad \Delta^2 x_t = \Delta (\Delta x_t),\quad \Delta^d x_t = \Delta (\Delta^{d-1} x_t)\]</span></p><ul><li><strong>单整的判别？</strong> 对于时间序列 <spanclass="math inline">\(x_t\)</span>，建立下列方程：</li></ul><p><span class="math display">\[x_t = \rho x_{t-1} + \varepsilon_t \quad or \quad \Delta x_t = (\rho -1) x_{t-1} + \varepsilon_t\]</span></p><p>如果 <span class="math inline">\(\rho-1\)</span> 不显著为 0，则序列<span class="math inline">\(x_t\)</span> 至少为 1 阶单整 <spanclass="math inline">\(I (1)\)</span>。</p><p>那么，<strong>如何判断 <span class="math inline">\(\rho-1\)</span>是否显著为 0？</strong>—— <a href="#3.4%20样本平稳性检验">第 3.4节：样本平稳性检验（单位根检验）</a>。</p><ul><li><strong>性质？</strong><ul><li>I (0)序列（平稳序列）对过去行为只有有限记忆，即发生在过去的扰动项对未来的影响随时间而衰减。因此，长期而言0 阶单整有回到期望值的趋势（均值回复）。</li><li>I (1)序列对过去行为有无限长记忆，任何过去的冲击都将永久改变未来的整个序列。</li><li>对 <span class="math inline">\(y_t\)</span>进行单位根检验后，如认为非平稳，要进一步判断其为 I (1) 或 I(2)。在经济变量中，I (0) 与 I (1) 最常见，I (2) 很少见。</li></ul></li></ul><h3 id="612-协整">6.1.2 协整</h3><p>在多元时间序列情况下，我们不仅要考虑单个时间序列的平稳性，还要考虑变量组合的平稳性。那么，单整变量（非平稳）的线性组合一定非平稳吗？有可能是平稳的吗？</p><ul><li>若多个 d 阶时间序列变量的线性组合的单整阶数 b 小于d，则称这些变量具有 <strong>协整关系</strong>，记作 CI(d,d-b)。由线性组合系数组成的向量称作协整向量（cointegratingvector）。</li><li><b><span style="background:#fff88f"><font color="#245bdb">注意：协整通常要求序列具有相同的单整阶数，并存在线性组合使其阶数降低。</font></span></b></li></ul><p>现在，我们数学化地定义协整：</p><ul><li>如果时间序列 <span class="math inline">\(Y_{t1}, Y_{t2}, \ldots,Y_{tk}\)</span> 都是 <span class="math inline">\(d\)</span>阶单整的，存在向量 <span class="math inline">\(\alpha = (\alpha_1,\alpha_2, \ldots, \alpha_k)\)</span>，使得</li></ul><p><span class="math display">\[Z_t = \alpha^T Y_t = \alpha_1 Y_{t1} + \alpha_2 Y_{t2} + \cdots +\alpha_k Y_{tk} \sim I(d-b), \quad d \geq b \geq 0\]</span></p><p>则称序列 <span class="math inline">\(Y_{t1}, Y_{t2}, \ldots,Y_{tk}\)</span> 是 <span class="math inline">\((d,b)\)</span>阶协整，记为 <span class="math inline">\(CI(d,b)\)</span>。</p><ul><li><b><span style="background:#fff88f">请注意：d 是原始序列单整阶数，b是组合序列单整阶数。</span></b></li><li><span class="math inline">\(CI (d, b)\)</span>的经济意义：虽然变量具有各自的长期波动规律，但是如果它们是 <spanclass="math inline">\((d, b)\)</span> 阶协整的，则它们之间<strong>存在着一个长期稳定的比例关系</strong>。<font color="#245bdb">即使这些时间序列单独来看是非平稳的，也可以用经典的回归分析方法建立回归模型。</font></li><li>例如，居民收入时间序列 <span class="math inline">\(Y_t\)</span> 为 1阶单整序列，居民消费时间序列 <span class="math inline">\(C_t\)</span>也为 1 阶单整序列，如果二者的线性组合 <span class="math inline">\(a_1Y_t + a_2 C_t\)</span> 构成的新序列为 0 阶单整序列，于是认为序列 <spanclass="math inline">\(Y_t\)</span> 与 <spanclass="math inline">\(C_t\)</span> 是（1，1）阶协整。</li></ul><blockquote><p>[!caution] 组成协整的单整阶数限制注意：<strong>协整通常要求序列具有相同的单整阶数</strong></p><p>如果有两个序列分别为 <span class="math inline">\(d\)</span> 阶单整和<span class="math inline">\(e\)</span> 阶单整，即 <spanclass="math display">\[x_t \sim I (d), \quad y_t \sim I (e), \quad e&gt; d\]</span> 则两个序列的线性组合是 <spanclass="math inline">\(e\)</span> 阶单整序列，即 <spanclass="math display">\[z_t = \alpha x_t + \beta y_t \sim I (\max (d,e))\]</span> 由于 <span class="math inline">\(e &gt;d\)</span>，这两个序列不存在协整关系，其线性组合需要经过 <spanclass="math inline">\(\max (d, e)\)</span>次差分才能转化为平稳序列（而不能直接分析）。</p><p>请思考：<strong>对于多个变量，协整阶数一定完全相等吗？——多重协整</strong></p><ul><li>若序列线性组合的单整阶数小于它们自身，但它们的阶数并不一定完全相等，则称它们具有多重协整（multi-cointegration）关系。</li><li>两个序列不可能出现 <strong>多重</strong>协整！所以多重协整至少要三个序列。</li><li><strong>举例：</strong> x 和 y 是CI(2,1)，记它们的一阶单整的线性组合为 xy；若 xy 又和 z 是 CI(1,1)，则x、y、z 三个变量的线性组合就可以是平稳的，即<strong>线性组合阶数小于它们各自的阶数</strong>。</li><li>你可能已经意识到：多重协整并不容易实现。上面的例子是<strong>两次协整</strong> 实现的效果。</li></ul></blockquote><h2 id="62-协整的检验">6.2 协整的检验</h2><p>进一步的疑问：<strong>有了数据怎么检验协整关系？有了协整关系又有什么用？</strong></p><ul><li>如果 k 个序列都是 d阶单整的，可以建立回归方程，得到其残差序列，对残差序列进行平稳性检验，如果不存在单位根，则可以说明k 个序列是协整关系。</li><li>在协整关系确定的基础上，再可以做格兰杰因果检验去判断“谁引起谁的变化”。</li></ul><h3 id="621-两变量-engle-granger-检验">6.2.1 两变量 Engle-Granger检验</h3><p>我们首先解决第一个问题，我们的目标是：<strong>检验两变量 <spanclass="math inline">\(y_t, x_t\)</span> 是否协整。</strong>一种常用的方法是：Engle 和 Granger（1987）提出的两步检验法。</p><p>这种方法的核心是：<b>对<span style="background:#fff88f">一阶残差</span>进行平稳性检验，如果是平稳的时间序列则证明是协整的。</b></p><p><strong>步骤一：协整回归计算非均衡误差</strong></p><ul><li>用 OLS 估计如下方程：$ y_t = \alpha x_t + \varepsilon_t $</li><li>得到估计的误差</li></ul><p><span class="math display">\[\hat{y_t} = \hat{\alpha} x_t  \quad \to \quad e_t = y_t - \hat{y}_t =(\alpha- \hat{\alpha}) x_t+ \varepsilon_t\]</span></p><p><strong>步骤二： 检验 <span class="math inline">\(e_t\)</span>的单整性（平稳性）</strong>：</p><ul><li>如果 <span class="math inline">\(e_t\)</span> 是平稳序列（即 0阶单整），则 <span class="math inline">\(y_t, x_t \sim CI(1,1)\)</span>，<span class="math inline">\(x_t\)</span> 与 <spanclass="math inline">\(y_t\)</span> 之间存在协整关系；</li><li>如果 <span class="math inline">\(e_t\)</span> 是非平稳的，则 <spanclass="math inline">\(x_t\)</span> 与 <spanclass="math inline">\(y_t\)</span> 之间不存在协整关系。</li><li>检验方法：DF 检验或 ADF 检验</li><li>拓展：这里的检验对象是协整回归计算出的误差项，并非真正的非均衡误差。由于OLS 估计最小化残差平方和的原理，估计量 <spanclass="math inline">\(\delta\)</span>是向下偏倚的，拒绝零假设的机会比实际大。因此对于 <spanclass="math inline">\(e_t\)</span> 的平稳性检验的 DF 与 ADF临界值比正常的 DF 与 ADF 检验的临界值小。</li><li>也可进行协整回归 Durbin-Watson 检验，DW检验常用于检验回归分析中残差一阶自相关性。DW 统计量：<spanclass="math inline">\(DW=\dfrac{\sum_{i=2}^n\left(\boldsymbol{e}_i-\boldsymbol{e}_{i-1}\right)^2}{\sum_{i=1}^n\left(\boldsymbol{e}_i-\bar{e}\right)^2}\)</span>。DW检验的原假设是 DW 统计量 = 0。若 H0成立，则残差为随机游走，不存在协整，反之则存在协整。DW检验只能检验一阶自相关，<a href="#3.5.1.2%20LM%20检验">LM 检验</a>可以检验一阶或高阶自相关，但需要构建辅助回归模型。</li></ul><h3 id="622-误差修正模型">6.2.2 误差修正模型</h3><h4 id="6221-一般差分模型的问题">6.2.2.1 一般差分模型的问题</h4><p>对于非平稳时间序列，可以通过差分的方法将其化为稳定序列。 <spanclass="math display">\[Y_t = \alpha_0 + \alpha_1 X_t + \mu_t \quad \to \quad \Delta Y_t =\alpha_1 \Delta X_t + v_t \quad (v_t = \mu_t - \mu_{t-1})\]</span> 但是这种做法会引起两个问题：</p><ul><li>如果 <span class="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span> 之间存在长期稳定的均衡关系，且误差项<span class="math inline">\(\mu_t\)</span>不存在序列相关性，则差分式中的 <span class="math inline">\(v_t\)</span>是一阶移动平均时间序列，存在序列相关的问题。</li><li><strong>如果采用差分形式进行估计，则关于变量水平值的重要信息将被忽略，这时的模型只表达了<span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span>之间的短期关系，而没有揭示它们间的长期关系</strong>。</li></ul><p>例如，当我们使用 <span class="math inline">\(\Delta Y_t = \alpha_1\Delta X_t + v_t\)</span> 进行回归分析时，容易出现截距项显著不为 0的情况，即我们得到的估计方程是</p><p><span class="math display">\[\Delta Y_t = \hat{\alpha}_0 + \hat{\alpha}_1 \Delta X_t +\hat{v}_t,\quad \hat{\alpha}_0 \neq 0\]</span></p><p>此时即使保持 <span class="math inline">\(X\)</span> 不变，<spanclass="math inline">\(Y\)</span>也会出于长期的上升或下降的过程中，这意味着 <spanclass="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span>之间不存在静态均衡，与大多数具有长期均衡的经济理论假说不相符。</p><h4 id="6222-误差修正模型-ecm">6.2.2.2 误差修正模型 ECM</h4><p>如何克服一般差分的局限？——误差修正模型（Error CorrectionModel，ECM）</p><ul><li>什么是误差修正模型呢？长期均衡的两个序列，短期的误差都会被修正。</li><li><strong>注意：只有存在协整关系才可以做误差修正模型。</strong></li></ul><blockquote><p>[!note] 需要修正的是什么误差？</p><ul><li>假设 <span class="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span>之间的非均衡关系体现为如下（1,1）阶分布滞后模型的形式：<br /><span class="math display">\[Y_t = \beta_0 + \beta_1 X_t + \beta_2X_{t-1} + \delta Y_{t-1} + u_t,\]</span> 该模型显示出 <spanclass="math inline">\(t\)</span> 期的 <spanclass="math inline">\(Y\)</span> 不仅与 <spanclass="math inline">\(X\)</span> 的变化有关，而且与 <spanclass="math inline">\(t-1\)</span> 期的 <spanclass="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span>的状态值有关。但由于变量可能具有非平稳性，因此不能直接进行 OLS估计。</li><li>差分变形得<br /><span class="math display">\[\begin{split}\Delta Y_t =&amp; \beta_0 +\beta_1 \Delta X_t + (\beta_1 + \beta_2) X_{t-1} - (1-\delta) Y_{t-1} +u_t \\=&amp; \beta_1 \Delta X_t - (1-\delta)\left(Y_{t-1} -\frac{\beta_0}{1-\delta} - \frac{\beta_1 + \beta_2}{1-\delta}X_{t-1}\right) + u_t \\\triangleq&amp; \beta_1 \Delta X_t - \lambda(Y_{t-1} - \alpha_0 - \alpha_1 X_{t-1}) + u_t\end{split}\]</span></li><li>将上式中的误差项与一般差分模型差分方法的误差项对比：<spanclass="math display">\[Y_t = \alpha_0 + \alpha_1 X_t + \mu_t \quad \to\quad \Delta Y_t = \beta_1 \Delta X_t + v_t\]</span></li><li>不难发现，二者的差别是多出了一项： <span class="math inline">\(-\lambda (Y_{t-1} - \alpha_0 - \alpha_1 X_{t-1})\)</span> 。</li><li>其中， <span class="math inline">\(Y_{t-1} - \alpha_0 - \alpha_1X_{t-1}=\mu_{t-1}\)</span> ，<strong>正是 <spanclass="math inline">\(t-1\)</span> 期的非均衡误差项。</strong></li><li>这表明 <span class="math inline">\(Y\)</span> 的短期变化 <spanclass="math inline">\(\Delta Y_t\)</span> 不仅受 <spanclass="math inline">\(X\)</span> 的短期变化 <spanclass="math inline">\(\Delta X_t\)</span>影响，而且根据前一时期的非均衡程度进行相应的修正调整。</li></ul></blockquote><p>由此，我们得到了误差修正项 <spanclass="math inline">\(ecm\)</span>：</p><p><span class="math display">\[ecm_{t-1} = Y_{t-1} - (\alpha_0 + \alpha_1 X_{t-1})\]</span></p><p>对于上述 (1, 1)阶自回归分布滞后模型，在一般差分的基础上，我们纳入误差修正项，就得到<font color="#245bdb"> 一阶误差修正模型 </font>：</p><p><span class="math display">\[\Delta Y_t = \beta_1 \Delta X_t - \lambda \cdot ecm_{t-1} + u_t\]</span></p><ul><li><p>由于 <span class="math inline">\(\delta\)</span> 反映了 <spanclass="math inline">\(Y_t\)</span> 与 <spanclass="math inline">\(Y_{t-1}\)</span> 的关系，一般情况下 <spanclass="math inline">\(|\delta| &lt; 1\)</span>，因此 <spanclass="math inline">\(0 &lt; \lambda=1-\delta &lt; 1\)</span>。</p></li><li><p>据此分析 ECM 模型的修正作用：</p><ul><li>若上期的实际值大于长期均衡值，即 <span class="math inline">\(Y_{t-1}&gt; \alpha_0 + \alpha_1 X_{t-1}\)</span>，则 <spanclass="math inline">\(ecm\)</span> 为正，当期的短期变动 <spanclass="math inline">\(\Delta Y_t\)</span> 减少；</li><li>若上期的实际值小于长期均衡值，即 <span class="math inline">\(Y_{t-1}&lt; \alpha_0 + \alpha_1 X_{t-1}\)</span>，则 <spanclass="math inline">\(ecm\)</span> 为负，当期的短期变动 <spanclass="math inline">\(\Delta Y_t\)</span> 增大。</li></ul></li><li><p>是否变量间的关系都可以通过 ECM 来表述？——Granger表述定理：如果变量 X 与 Y是协整的，则它们间的短期非均衡关系总能由一个误差修正模型表述。</p></li></ul><h4 id="6223-建立误差修正模型的步骤">6.2.2.3 建立误差修正模型的步骤</h4><ol type="1"><li>总体思路<ul><li>首先，对经济系统进行观察和分析，提出长期均衡关系假设。</li><li>然后，对变量进行协整分析，检验长期均衡关系假设，并构成误差修正项。</li><li>最后，建立短期模型，将误差修正项看作一个解释变量，连同其他反映短期波动的解释变量一起，建立短期模型，即误差修正模型。</li></ul></li><li><strong>EG 两步法</strong><ul><li>第一步：利用 OLS进行协整回归，检验变量间的协整关系，估计协整向量（长期均衡关系参数）</li><li>第二步：若协整性存在，则以<font color="#245bdb"><span style="background:#fff88f">第一步求得的残差在滞后一期之后</span></font>作为非均衡误差项 ecm 加入到误差修正模型中，并用 OLS 估计相应参数</li><li>注意：第二步在确定 <strong>ECM 模型滞后项阶数</strong>时，需要先对模型进行回归，之后检验 ECM模型的残差是否具有自相关性，或者采用 Q统计量检验残差是否为白噪声。如果接受了不具有自相关性的零假设，则说明 ECM模型的滞后阶数选择正确，否则需重新调整参数。</li></ul></li></ol><blockquote><p>[!tip] 通过 Stata 代码理解 EG 两步法</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">*Step 1：E-G两步法*</span><br>（1）生成残差<br><span class="hljs-keyword">reg</span> y x  <span class="hljs-comment">//OLS回归</span><br><span class="hljs-keyword">predict</span> <span class="hljs-keyword">e</span>, residual <span class="hljs-comment">//生成残差</span><br>（2）对残差做单位根检验<br><span class="hljs-keyword">tsset</span> year <span class="hljs-comment">//先将e设置成时间序列</span><br><span class="hljs-keyword">dfuller</span> <span class="hljs-keyword">e</span>，nocons <span class="hljs-keyword">reg</span>  <span class="hljs-comment">//进行单位根检验</span><br><br><span class="hljs-comment">*Step 2：如果1.2有协整关系，建立误差修正模型(ECM)*</span><br>（1）生成残差的滞后项<br><span class="hljs-keyword">gen</span> ecm=<span class="hljs-keyword">l</span>.<span class="hljs-keyword">e</span> <br>（2）生成被解释变量的滞后项（注：dy、dx是Δy和Δx）<br><span class="hljs-keyword">gen</span> dy_lar=<span class="hljs-keyword">l</span>.dy<br>（3）用OLS法估计误差修正模型的参数（加入了被解释变量和残差的滞后项）<br><span class="hljs-keyword">reg</span> dy dx dy_lar ecm<br></code></pre></td></tr></table></figure></blockquote><h3 id="623-多变量协整关系的检验">6.2.3 多变量协整关系的检验</h3><p>Engle-Granger检验通常用于检验两变量之间的协整关系，对于多变量之间的协整关系，通常使用Johansen 协整检验来确定变量之间是否有协整关系，并由此估计模型。</p><ul><li>Johansen 协整检验分为两种，一个叫迹检验（tracetest），有一个叫极大特征根检验（maximum eigenvaluetest），这两个检验通常会给出一样的结论。</li><li>关于 Johansen 检验的原理，详见 <ahref="https://zhuanlan.zhihu.com/p/144783461">链接</a></li></ul><blockquote><p>[!tip] 【了解】为什么多变量协整关系的检验比双变量复杂？协整变量间可能存在多种稳定的线性组合。 例如：假设有 4 个 I(1)的变量 Z,X, Y, W，它们有如下的长期均衡关系： <span class="math inline">\(Z_t =\alpha_0 + \alpha_1W_t + \alpha_2X_t + \alpha_3Y_t + \mu_t,\)</span>得到非均衡误差 <span class="math inline">\(\mu_t\)</span> 是 I(0)序列<span class="math inline">\(\mu_t = Z_t - \alpha_0 - \alpha_1W_t -\alpha_2X_t - \alpha_3Y_t \sim I(0).\)</span> 但存在另一种情况，假设 Z与 W，X 与 Y 之间分别存在长期均衡关系 <span class="math inline">\(Z_t =\beta_0 + \beta_1W_t + u_t,\)</span> <span class="math inline">\(X_t =\gamma_0 + \gamma_1Y_t + v_t,\)</span> 则非均衡误差项 <spanclass="math inline">\(u_t\)</span> 和 <spanclass="math inline">\(v_t\)</span>一定平稳。它们的线性组合也一定是平稳序列，如： <spanclass="math inline">\(w_t = u_t + v_t = Z_t - \beta_0 - \gamma_0 -\beta_1W_t + X_t - \gamma_1Y_t \sim I(0).\)</span>因此存在多组协整向量。</p></blockquote><p><strong>多变量的协整检验步骤</strong>：</p><ul><li>与双变量基本相同，需要检验变量是否具有同阶单整性，以及是否存在稳定的线性组合。</li><li>在检验是否存在稳定的线性组合时，需要通过设置一个变量为被解释变量，其他变量为解释变量，进行OLS估计并检验残差序列是否为平稳序列。如果不平稳则需更换被解释变量，进行同样的OLS 估计和相应的残差序列的平稳性检验。</li><li>当所有的变量都被作为被解释变量检验之后，仍不能得到平稳的残差项序列，则认为这些变量间不存在( 1 , 1 ) 阶协整。</li></ul><h3 id="624-小结">6.2.4 小结</h3><ol type="1"><li>检验协整的一种方法是分析偏离长期均衡关系的残差。如果残差存在单位根，则变量间不是(1,1) 阶协整的。（E-G 方法）</li><li>在 I(1) 变量中检验协整的另一种方法是估计 1 阶差分 VAR模型，该模型包含变量的滞后值。Johansen 方法运用 <spanclass="math inline">\(\lambda_{trace}\)</span> 和 <spanclass="math inline">\(\lambda_{max}\)</span>检验统计量来确定变量间是否是协整的和协整向量的数量。这些检验对包含在协整向量的确定性回归变量很敏感。协整向量和(或) 速度调整系数的约束条件可以用 X统计量进行检验。我们应该知道在协整框架下确定性回归变量所起的作用。为了确定是否存在确定性趋势、协整向量之外的漂移项或协整向量中出现的常数，Johansen(1994) 提出了如何进行检验的方法。</li><li>第三个检验协整的方法是估计误差修正模型。如果只有一个变量对偏离长期均衡的离差做出反应进行调整的话，则倾向于估计自回归分布滞后模型ADL。用 OLS 估计模型，并进行协整向量系数的假设检验很直截了当。</li><li>对于更复杂的情况，附录 6.2 讨论了 Phillips-Hansen (1990)单方程结构建模的方法。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Better Lucky Than Rich? Welfare Analysis of Automobile Licence Allocations in Beijing and Shanghai</title>
    <link href="/2025/09/13/Better%20Lucky%20Than%20Rich/"/>
    <url>/2025/09/13/Better%20Lucky%20Than%20Rich/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1id="幸运总比有钱好北京和上海汽车牌照分配的福利分析">幸运总比有钱好？北京和上海汽车牌照分配的福利分析</h1><p><strong>Ref：</strong> Li, S. (2018). Better Lucky Than Rich? WelfareAnalysis of Automobile Licence Allocations in Beijing and Shanghai. TheReview of Economic Studies, 85(4), 2389–2428.</p><p><strong>Link：</strong><strong>https://doi.org/10.1093/restud/rdx067</strong></p><p><imgsrc="https://files.mdnice.com/user/77043/a013902b-ba1e-4372-a9a9-d5c4ff239ddd.png" /></p><h1 id="摘要"><strong>摘要</strong></h1><p>经济学家往往倾向于基于市场机制而非基于非市场机制，以经济效率和创收为理由配置稀缺的公共资源。当相关资源的使用产生类型依赖的负外部性时，福利比较可能变得模糊不清。中国主要城市正在实施这两种分配机制，通过发放有限的车辆牌照应对日益恶化的交通拥堵和空气污染。不同的是，北京使用了不可转让的抽签Lottery，但上海使用的是拍卖系统。本文通过同时考虑配置效率和配置后的汽车外部性，实证量化了这两种机制的福利后果。分析显示，不同的分配机制导致社会福利的巨大差异。虽然北京的抽签系统在降低汽车外部性方面比拍卖有很大优势，但这种优势被配置不当带来的显著配置成本所抵消。仅在2012年，北京的抽签制度就造成了300亿元（近50亿美元）的社会福利损失。统一价格拍卖将为北京市政府带来近200亿元，超过其对当地公交系统的全部补贴。</p><h1 id="背景">背景</h1><p>基于市场的机制（即拍卖）经常被倡导以经济效率和创收为理由配置稀缺的公共资源，而不是基于非市场的机制（即抽签）。两者在实践中都得到了广泛应用，往往针对不同类型的资源。例如，拍卖通常用于出售矿权、木材和无线电频谱，而抽签则用于发放狩猎许可证、特许学校招生和陪审团义务。基于市场的机制可能通过使用价格信号来将稀缺资源分配给支付意愿（WTP）最高者以实现效率，而不可转让的抽签可能会导致分配不当和福利损失。然而，当资源的使用产生了WTP中不断增加的负外部性时，两种机制之间的福利比较可能变得模糊不清。在这种情况下，衡量社会福利的基础——社会福利（外部性的消费者福利净额）与市场化机制下资源配置的基础——WTP存在偏离，甚至可能随着WTP而减少。</p><p><strong>【北京】</strong>为缓解交通拥堵及改善空气质量，北京市政府于2011年引入车辆牌照配额制度，以限制车辆拥有量的增长。2011-2013年期间，每月通过不可转让的抽签发放约2万个新牌照，2013年后每月配额减少至约1.2万个。抽中的难度越来越大：赔率从2011年1月的1:10降至2013年底的1:100，并进一步降至2016年8月的1/700以下。</p><p><strong>【上海】</strong>上海建立了车辆牌照配额制度，但其牌照分配是通过拍卖系统，而不是抽签。事实上，自1994年以来就已经有了一个拍卖系统，但减少车辆拥有量的目标直到最近才出现。2008年，上海市政府采取多单位、歧视性、动态拍卖（multi-unit,discriminatory and dynamicauction）的形式，每月在网上发放约1万张牌照。2012年，拍卖系统向上海市政府产生超过67亿元（超过10亿美元）的收入。2013年3月，一张牌照的平均竞价达到9.2万元以上，高于许多入门级车型的价格。</p><h1 id="研究问题与研究目的">研究问题与研究目的</h1><p>本研究的主要目的是实证量化两种分配机制在分配车辆牌照时的福利后果，同时考虑分配效率和与车辆使用相关的外部性。</p><p>这是一个重要的问题，至少有两个原因。</p><ul><li>首先，交通拥堵和空气污染给社会带来了巨大的成本（Parry等，2007）。Creutzig和He（2008）估计，北京市汽车使用的外部成本占其GDP的比重超过7.5%。在中央政府的背书下，中国许多大城市正在采用牌照配额制，并采用不同的分配机制。然而，<strong>这些政策的影响和福利后果不得而知。</strong></li><li>其次，两种机制在福利比较上存在理论上的先验模糊性，因为牌照的使用（登记并最终驾驶车辆）与拥堵、污染等负外部性相关。这些外部性很可能会在消费者的WTP中增加，因为WTP高的消费者往往收入高。与此同时，中美两国的家庭出行调查数据显示，高收入家庭平均购买燃油效率较低的汽车，驾驶率高于低收入家庭。<strong>抽签或拍卖制度是否会带来更高的社会福利，关键取决于WTP中消费者异质性的水平及其与汽车外部性的关系。</strong>因此，效率比较和福利影响的大小归根结底是实证问题。</li></ul><p><imgsrc="https://files.mdnice.com/user/77043/593ef8c6-70d5-478c-9758-fdd5a3e3419a.png"alt="表1显示了2010年北京家庭出行调查中七个收入群体的平均发动机尺寸和年车辆行驶里程（VMT）。对于车主，该调查包含有关家庭收入、发动机尺寸和车辆年度VMT的信息。" /></p><p>该表显示，高收入家庭拥有发动机更大的汽车，而且开车平均而言更频繁。这些正相关关系与美国汽车拥有和出行行为的证据一致（Small&amp; VanDender，2007；Li等，2009，2014）。因为城市地区汽车使用的外部性主要来自拥堵和空气污染，这些外部性与出行距离和汽油使用量直接相关（Parry等，2007）。这意味着，与收入较低的家庭相比，收入较高的家庭可能从汽车使用中产生更大的外部性。福利分析将回到这一点，并为具有不同WTP的不同家庭提供外部性估计。</p><h1 id="数据">数据</h1><p>本文依靠四个主要数据集以及各种辅助数据进行分析。</p><ol type="1"><li>2008年至2012年每个城市按车型（年份-铭牌）划分的月度<strong>汽车销量</strong>。有84,912个观测值（城市-模型-年-月），有1,769种车型。</li><li>销售数据中每个车型的<strong>车辆特征</strong>。这些特征包括价格、燃油经济性（升/100公里）、车辆尺寸、发动机尺寸、车辆类型和车辆细分市场。车辆价格是基于制造商<strong>建议零售价（MSRP）</strong>和销售税计算得到的。销售税通常定为10%，但在2009年和2010年，发动机排量不超过1.6升的车辆分别降至5%和7.5%。</li><li>各城市按年份划分的收入分布。</li><li>福特汽车公司对新车购买者进行的年度全国代表性家庭调查的汇总信息。我们获得了每个城市每年四个收入群体中新车辆购买者的家庭份额数据。</li></ol><p>注：制造商建议零售价（MSRP）通常在不同地点和车型年内保持不变，由于中国汽车市场很少有制造商或经销商的促销活动，零售价通常与建议零售价相同或非常接近建议零售价。</p><h1 id="策略与结果">策略与结果</h1><p><strong>【策略】</strong>为了估计汽车拥有量的消费者剩余，本文估计了Berry等（1995）开发的汽车需求的<strong>随机系数离散选择模型（以下简称BLP）</strong>，该模型考虑了消费者偏好异质性和未观察到的产品属性。与Petrin（2002）类似，本文的估计策略采用汇总的市场水平数据和来自家庭调查的信息来形成矩条件。从对新车购买者的家庭调查中获得了不同收入群体中购买者的份额。本文用它们来形成矩条件，它们对于识别消费者偏好异质性至关重要。</p><p>本文的识别策略与文献的一个重要偏离是：不依赖于维持的外生假设，即未观察到的产品属性与观察到的产品属性不相关。利用数据的多市场性质，我们包括车辆模型固定效应来控制未观察到的产品属性。</p><p>此外，<strong>本文明确采用了DID框架中隐含的共同趋势假设，以更好地将政策冲击的影响与未观察到的需求冲击隔离开来</strong>：没有共同趋势假设的模型倾向于将2011年的大幅销售下降归因于巨大的（未观察到的）负面需求冲击。</p><p>我们的市场层面数据包括北京、南京、上海、天津四个城市的数据。南京和天津（<strong>对照组</strong>）分别是上海和北京（<strong>处理组</strong>）旁边的两个大城市。在数据期间，它们没有牌照配额制度，正如我们通过图表和回归显示的那样，<em>在没有政策的情况下，这两个城市的汽车市场表现出与北京和上海相似的趋势</em>。</p><p><strong>【结果】</strong> 我们的分析得出了几个重要结论：</p><ul><li>首先，北京和上海的两项政策都明显限制了新车销量：北京的抽签制度在2011年和2012年减少了120多万辆新车销量，而上海拍卖会在2008年至2012年期间减少了近200万辆销量。这些下降幅度很大，反映了配额制度的严格性。</li><li>二是不同配置机制的福利后果巨大。虽然北京的抽签系统在降低汽车外部性方面比拍卖系统有30亿元的不小优势，但其因配置不当而产生的配置成本在2012年超过330亿元，这意味着仅2012年北京就有近300亿的福利损失。抽签系统带来的巨大配置成本是由WTP牌照的巨大消费者异质性驱动的。</li><li>第三，如果拍卖，能在2012年为北京市政府带来近200亿收入，这足以覆盖其对当地公交系统的所有补贴。</li><li>第四，基于一系列看似合理的假设，北京的最优配额水平低于2012年使用的配额，进一步降低配额将增加净社会福利。</li></ul><h1 id="结论">结论</h1><p>空气污染和交通拥堵可以说是中国城市居民最紧迫的两个问题。为应对这些问题，中国多个主要城市的公交部门正在实施车辆牌照配额制度，以遏制车辆保有量的增长。他们应该如何发放数量有限的车辆牌照？有人可能会说，将资源分配给价值最高者的基于市场的机制将更有效率。然而，<em>如果资源的使用产生了与支付意愿正相关的负外部性，市场化的效率优势机制可能会消失</em>，因为私人收益最高的人使用资源可能会导致较小的社会收益。</p><p>尽管自科斯（1959）以来，已有大量关于资源配置机制的杰出理论文献，但除拍卖文献外，量化资源配置不当及其福利影响的实证研究却寥寥无几。本研究首次对中国城市不同机动车牌照发放机制的福利结果进行了实证分析。</p><p>我们的分析显示，配额制下不同的分配机制导致福利结果的巨大差异。抽签系统在减少汽车外部性方面比拍卖系统有很大优势。尽管如此，这种优势主要是由配置不当带来的显著配置成本决定的。综合考虑配置产生的消费者剩余和配置后的汽车外部性，仅2012年，北京市抽签系统的福利损失估计约300亿元（近50亿美元）。<strong>这突显了在消费者异质性较大的情况下，配置效率的重要性</strong>。这一重大损失尤其令人担忧，因为中央政府已将配额制作为一项打击主要城市地区空气污染的政策，而北京方面往往是制定地方政策的领导者。自2011年以来，另外五个主要城市采用了配额制：两个城市使用抽签，其他城市则采用混合制。虽然选择抽签制度的理由尚未公开，但可以假设，这一决定反映了对平等的担忧。我们发现，在2012年，统一价格拍卖可能会给北京市政府带来近200亿元的收益，可以用来将其对公交系统的补贴翻倍，或者用其他措施解决分配问题。</p><p>中国城市交通部门正在采用的车辆牌照配额制度是一个外生的工具。经济学家长期以来一直在倡导以市场为基础的机制，如庇古政策，以纠正外部性。在现实世界的实施中，拥堵定价方案已在伦敦、新加坡和斯德哥尔摩被采用，并被发现在减少拥堵方面有效（Anas和Lindsey，2011）。燃油税为应对多重汽车外部性提供了次优且管理简单的政策（Parry等，2007）。在本文中，我们重点研究了许可证配额制度框架内两种分配机制的福利后果。<em>在未来，配额制本身与道路定价、汽油税等其他政策选择的比较值得进一步研究。</em></p><p><strong><font size=4><center>## The End ##</center></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Is 60 the New 50? Examining Changes in Biological Age Over the Past Two Decades</title>
    <link href="/2025/09/13/Is%2060%20the%20New%2050/"/>
    <url>/2025/09/13/Is%2060%20the%20New%2050/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><strong>Ref:</strong> Levine, M. E., &amp; Crimmins, E. M. (2018). Is60 the New 50? Examining Changes in Biological Age Over the Past TwoDecades. <em>Demography</em>, 55(2), 387–402.https://doi.org/10.1007/s13524-017-0644-5</p><h2 id="motivaton">Motivaton</h2><p>为什么想起来要给这篇做一个推文呢？这是因为最近在想形势政策课程报告的主题，想起来之前那篇关于美国延迟退休政策的JLE 论文 （传送门：<ahref="https://mp.weixin.qq.com/s/j67T3csOPbDtR0VYZVp1jw">JLE2023_TheImpact of the Retirement Slowdown</a>）。</p><p>由于时间比较久，我们简单总结这篇论文：基于美国的结论是中性偏负面的——中性在于，没有证据表明美国延迟退休政策对青年就业存在显著影响；偏负面的是论文发现延迟退休政策对青年工资、职业类型和工作流动性存在一定的不利影响。具体而言，发现是退休人数减少1%，青年劳动者从事高技能工作比例下降1.2%（主要是更难成为管理层）、工作流动性下降0.35%、工资时薪下降约5%。</p><p>既然其他国家证据发现延迟退休的影响没有那么正面，为什么我国还要推行呢？一个受到很多讨论的原因当然是<em>老龄化趋势下养老金体系的现收现付压力</em>。而另一方面基于人文关怀需要考虑的是：延迟退休的这部分劳动者是否还有能力（体力+精力）继续履职？</p><p>换言之，我国当时确定退休年龄政策时的国情与现在毫无疑问存在变化。<strong>在1949年，我国人均预期寿命仅为35岁，到1978年平均年龄是68.3岁，而在2023年，中国的平均年龄已经达到78.6岁。</strong>就像经济学中常常区分的名义 GDP 和实际 GDP一样，我们在平时计算的退休年龄是通过名义年龄——也就是出生年份衡量的，这并不能完全反映劳动者的劳动能力——事实上，<em>以实际劳动能力低于某一限度作为退休的标准可能才更合理</em>。（类比地，就像机器的折旧一样，如果随着技术进步，机器保养越来越好，那么机器的额定使用年限也会在安全的范围内逐渐延长。）</p><p>作为实际劳动能力的一个代理变量，现有文献对于<em>生理年龄</em>的讨论也不断增加。在西方有宣传称“60the New40”，有点像咱们的“夕阳红”的意思，毫无疑问对比于40岁说法有点夸张，但*“同样名义年龄的人群有更低的生理年龄”*可能所言非虚。今天介绍的这篇人口学顶刊文章就以美国为背景进行了有趣的对比。</p><h2 id="摘要">摘要</h2><p>延长预期寿命被解释为改善人口的健康状况。然而，死亡率并不总是衰老速度的可靠代表，而是可能反映出让患病者活着的成就。使用来自NHANES-3 的1988-1994年数据和 NHANES-4的2007-2010年数据，本文<em>研究了美国人在 1988-2010年间生理年龄相对于时序年龄的变化</em>，同时估计了可改变健康行为变化的贡献。</p><p>结果表明，<em>更近时间范围的人有着较低的生理年龄；降低的程度因年龄组和性别组而异</em>。总体而言，老年人的生理年龄改善幅度最大。男性（尤其是最年轻和最年长群体的男性）生理年龄下降幅度大于女性。这些差异部分是由年龄和性别特异性的行为变化解释的，例如吸烟、肥胖和药物使用。减缓老龄化速度以及延长预期寿命具有重要的社会和经济影响，因此确定导致健康和老龄化队列差异的可改变风险因素至关重要。</p><h2 id="样本与变量测度">样本与变量测度</h2><p>本文的分析样本包括来自美国 National Health and Examination Survey第三波 （n= 13,426） 和第四波 （n= 8,149） 的 21,575 名年龄在 20-79岁之间的受试者。两轮调查的未加权回复率分别为 78.0% 和 77.3%。</p><p>生物年龄方程的参数来自调查的汇总数据；所有计算均使用抽样权重。该算法包含实际年龄信息，以及表明代谢、心血管、炎症、肾脏、肝脏和肺功能的八个因素（通过医学指标得到）。我们的测量基于Klemera 和 Doubal （2006）提出的算法，该算法生成了一个测量“生理年龄”的方程。</p><p>在调查中有两个问题报告了吸烟状况：（1） “您一生中至少抽过 100支香烟吗？”、 （2）“您目前抽烟吗？”使用常用的吸烟状况分类，参与者被分类为（1）<em>当前吸烟者</em>，对两个问题的回答都是肯定的;（2）<em>前吸烟者</em>：如果他们报告至少吸烟100 支，但目前不吸烟;（3） <em>非吸烟者</em>：回答都是否定的。</p><p>体重指数 （BMI） 的计算方法是测量的体重 （kg） 除以测量的身高 （米）的平方。BMI 在 25 到 29.9 之间的参与者被归类为超重，而 BMI 为 30或以上的参与者被归类为肥胖。由于体重不足 （BMI &lt;18.5）没有产生明显不同的结果，因此作者把体重不足的样本合并进体重正常的组别。</p><p>使用自我报告确定药物使用情况。参与者被问及他们是否正在服用治疗 （1）高血压和 （2）高胆固醇的处方药。对于服药的人，通过使用收缩压和总胆固醇的估算水平重新计算生物年龄。</p><p>社会人口学特征方面，作者使用了调查中汇报的种族、教育程度、性别和实际年龄。</p><ul><li>使用种族信息，作者把受访者分为四个种族群体：非西班牙裔白人、非西班牙裔黑人、西班牙裔和其他。</li><li>使用受教育年限信息，作者把受访者分为四个教育组：（1） 受教育年限少于12 年，（2） 受教育年限正好为 12 年，（3） 受教育年限为 13-15 年，以及（4） 受教育年限为 16 年或以上。</li><li>使用性别信息，作者创建虚拟变量：男性为 0，女性为 1。</li><li>使用实际年龄信息，作者把受访者分为年轻 （2039）、中年 （40-59）还是老年 （60-79） 三个年龄组。</li></ul><p>下面这个表格展示了样本描述性统计： <imgsrc="https://files.mdnice.com/user/77043/65809a0d-b04c-42dd-a0ae-37b145026b38.png"alt="描述性统计" /></p><h2 id="模型与研究结果">模型与研究结果</h2><p><imgsrc="https://files.mdnice.com/user/77043/5425fd79-25bc-4559-b9f8-e7efb182bb88.png"alt="模型，其中BA是生理年龄" /></p><p>结果方面主要通过论文图表来介绍~</p><p><imgsrc="https://files.mdnice.com/user/77043/d51f9c88-6734-48e0-92a8-09ab97b13bb1.png"alt="图1.生理年龄的变化" /></p><p>怎么解释这张图片？以老年人组为例，2007-2010年美国60-79岁男性生理年龄较1988-1994年降低4.29岁、女性生理年龄降低3.63岁。<em>这意味着60岁群体的劳动力与十年前的55岁群体基本相当</em>。p值0.088意味着不同性别间存在显著差异。</p><p>这张图片正是我们最感兴趣的：相较于10年前，所有年龄组和性别组的参与者的生理年龄都更年轻。</p><ul><li>对于女性，20-39 岁、40-59 岁和 60-79岁女性的生理年龄在两个时期之间分别下降了 0.63 岁、2.36 岁和 3.63岁；</li><li>对于男性，20-39 岁、40-59 岁和 60-79 岁男性的生物年龄分别减少了 1.27岁、2.65 岁和 4.29 岁。</li></ul><p>总体而言，每个年龄组的女性的生理年龄都明显低于男性。例如，对于第 1 期20-39 岁、40-59 岁和 60-79 岁的人，女性的平均生理年龄相对于男性分别低3.48 岁、2.21 岁和 1.31 岁。同样，对于第 2 期 20-39 岁、40-59 岁和 60-79岁的人，女性的生理年龄分别比男性低 2.84 岁、1.91 岁和 0.65 岁。</p><p>尽管女性的生理年龄始终低于男性，并且所有年龄/性别组在两个时期之间都表现出改善，但结果还表明：性别差异随着时间的推移而减少。性别差距的缩小对于中年群体（p= 0.299） 不显著，但对于最年轻的年龄组 （p= 0.003）具有统计学意义，对于最年长的年龄组 （p= 0.088）具有较弱的显著性。此外，这一变化表明，尽管男性和女性在两个时期之间的生物年龄都有显着改善，但男性的改善更大，有助于缩小性别差距。</p><p>进一步，作者还检查了一些生理年龄的重要影响因素：吸烟、肥胖、药物使用。更多相关内容请见原文~</p><p><imgsrc="https://files.mdnice.com/user/77043/2236feec-1a3e-4c2c-99c6-e6c05df69a6d.png"alt="图2.吸烟和肥胖对生物年龄的增加" /></p><p><imgsrc="https://files.mdnice.com/user/77043/24865c7f-503e-412f-abb6-2274f3714939.png"alt="图3.肥胖患病率和当前吸烟率的变化" /></p><p><imgsrc="https://files.mdnice.com/user/77043/54780a6f-478c-4129-9be2-c27e0cc445f4.png"alt="图4.BMI 和吸烟对生物年龄的影响。" /></p><p>前面三张图片反映了吸烟、肥胖对生理年龄的不利影响；下面的图5则相反，讨论了药物使用增加对生物年龄改善的积极作用。其中，药物使用对老年人的影响最大。</p><p><imgsrc="https://files.mdnice.com/user/77043/b846f714-d80e-4d10-8f4b-15a0a9d58e23.png"alt="图5.药物使用对生物年龄的影响。这里使用了四种模型：模型 1：调整协变量（种族/民族、社会经济地位和年龄）。模型 2：针对协变量以及与BMI的交互项进行调整。模型 3：针对协变量以及与吸烟的交互项进行调整。模型 4：针对协变量以及与吸烟、BMI以及吸烟与BMI之间的交互项进行调整" /></p><p><strong><font size=4><center>## The End ##</center></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
