

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/fluid.png">
  <link rel="icon" href="../../../../img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jack Zhang">
  <meta name="keywords" content="">
  
    <meta name="description" content="【Author】：Jack Zhang, Sun Yat-sen University  【Textbook】：Applied Econometric Time Series (4e), by Walter Enders  【Original Slides】：https: &#x2F;&#x2F;www.time-series.net&#x2F;powerpoint_slides  Chapter 1: Differen">
<meta property="og:type" content="article">
<meta property="og:title" content="时间序列分析自学笔记">
<meta property="og:url" content="https://zhangwj235.github.io/2025/09/13/Time%20Series%20Note/index.html">
<meta property="og:site_name" content="Jack Zhang&#39;s Personal Website">
<meta property="og:description" content="【Author】：Jack Zhang, Sun Yat-sen University  【Textbook】：Applied Econometric Time Series (4e), by Walter Enders  【Original Slides】：https: &#x2F;&#x2F;www.time-series.net&#x2F;powerpoint_slides  Chapter 1: Differen">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://files.mdnice.com/user/77043/f24960d4-5001-4d7b-8e77-a815329da5bd.png">
<meta property="og:image" content="https://zhangwj235.github.io/2025/09/13/Time%20Series%20Note/%E8%BF%B9%E5%9B%BE.png">
<meta property="og:image" content="https://zhangwj235.github.io/2025/09/13/Time%20Series%20Note/ACF%E5%92%8CPACF%E7%A1%AE%E5%AE%9A%E5%B9%B3%E7%A8%B3%E6%80%A7.png">
<meta property="og:image" content="https://files.mdnice.com/user/77043/c17a3699-778e-4aac-b1f2-a0908f4df17f.png">
<meta property="article:published_time" content="2025-09-13T09:59:11.385Z">
<meta property="article:modified_time" content="2025-09-13T16:01:50.800Z">
<meta property="article:author" content="Jack Zhang">
<meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://files.mdnice.com/user/77043/f24960d4-5001-4d7b-8e77-a815329da5bd.png">
  
  
  
  <title>时间序列分析自学笔记 - Jack Zhang&#39;s Personal Website</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhangwj235.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"3TFsZbI0jqQpxYcUS0JdmgZ8-gzGzoHsz","app_key":"fUDXRfmqg8dNdLUuv5DZT7YD","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Jack Zhang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About me</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../cv/" target="_self">
                <i class="iconfont icon-codeforces"></i>
                <span>CV</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archive</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="时间序列分析自学笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-13 17:59" pubdate>
          September 13, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          53k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          440 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> views
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">时间序列分析自学笔记</h1>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer"/>

<ul>
<li>【Author】：Jack Zhang, Sun Yat-sen University </li>
<li>【Textbook】：Applied Econometric Time Series (4e), by Walter Enders </li>
<li>【Original Slides】：https: //www.time-series.net/powerpoint_slides</li>
</ul>
<h1 id="Chapter-1-Difference-Equations-差分方程"><a href="#Chapter-1-Difference-Equations-差分方程" class="headerlink" title="Chapter 1: Difference Equations 差分方程"></a>Chapter 1: Difference Equations 差分方程</h1><blockquote>
<p>[!IMPORTANT] 本章学习目标</p>
<ol>
<li>阐述随机差分方程如何用来预测，说明该方程如何产生于熟悉的经济模型。</li>
<li>阐述差分方程的解的含义。</li>
<li>阐述如何用迭代求解随机差分方程。</li>
<li>阐述如何求差分方程的齐次解。</li>
<li>阐述求齐次解的过程。</li>
<li>阐述如何求高阶差分方程的齐次解。</li>
<li>阐述如何求确定的差分方程的特解。</li>
<li>阐述如何用待定系数法求随机差分方程的特解。</li>
<li>阐述如何用滞后因子求随机差分方程的特解。</li>
</ol>
</blockquote>
<h2 id="1-1-时间序列模型"><a href="#1-1-时间序列模型" class="headerlink" title="1.1 时间序列模型"></a>1.1 时间序列模型</h2><p>当我们拿到一个时间序列模型，我们可能不假思索地就能说出一些直观的信息。比如，GDP 逐年增长的趋势、增速放缓的趋势。这就是直观的描述性分析。</p>
<p><img src="https://files.mdnice.com/user/77043/f24960d4-5001-4d7b-8e77-a815329da5bd.png" srcset="/img/loading.gif" lazyload alt="可能思路"></p>
<p>但是，很多规律并不那么容易发现——他们潜藏在大量的复杂的数据背后。我们研究模型的目的就是理解这些潜在的规律，并用以预测。这时，模型的作用就是 <strong>提取特征</strong>，用统计学的语言使得这些特征从模糊的感觉转变为确切的定理。</p>
<p><strong>那么，有什么方法可以 “提取特征” 呢？</strong> 当前，时间序列分析主要有两大“流派”——<strong>统计时间序列分析</strong> 和 <strong>机器学习方法</strong>。统计时间序列分析基于统计学方法对时间序列的概率特性进行估计，一般基于（线性） 随机过程假设。我们之前学习的 AR 模型、MA 模型、ARMA 模型等都属于这一类。另一类是机器学习方法，顾名思义，是基于机器学习方法从历史或相关序列中学习时间序列预测的方法。比如基于近邻的方法、RNN/LSTM、Transformer、TCN、Meta-Learning 等。我们目前主要学习的是统计时间序列分析方法。</p>
<h3 id="1-1-1-时间序列分析的用途"><a href="#1-1-1-时间序列分析的用途" class="headerlink" title="1.1.1 时间序列分析的用途"></a>1.1.1 时间序列分析的用途</h3><ul>
<li><p><strong>传统用途</strong>：预测</p>
<ul>
<li><p>基于线性模型 $y<em>{t+1} = a_0 + a_1 y_t + \varepsilon</em>{t+1}$，已知当期 $y<em>t$，预测下一期期望 $E_t[y</em>{t+1}] = a_0 + a_1 y_t$。</p>
</li>
<li><p>那么，$t+2$ 期？在第一期的基础上递推。<br>-$y<em>{t+2}=a_0+a_1y</em>{t+1}+\varepsilon<em>{t+2}$<br>-$E</em>{y<em>{t+2}}=a_0+a_1E</em>{y_{t+1}}=a_0+a_1(a_0+a_1y_t)=a_0+a_1a_0+(a_1)^2y_t$</p>
</li>
<li><p>“递推”的本质就是【迭代】，即本章的核心内容。</p>
</li>
<li><p>例如：通过滞后一期的价格预测下一期价格，GDP 预测。</p>
</li>
</ul>
</li>
<li><p><strong>现代用途</strong>：</p>
<ul>
<li><strong>动态关系捕捉</strong>：分析变量间的滞后影响（如货币政策对经济的滞后效应）。</li>
<li><strong>假设检验</strong>：验证经济理论（如随机游走假设）。</li>
<li><strong>发展“典型事实”</strong>：从数据中提炼规律（如商业周期的波动特征）。</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-典型的时间序列问题"><a href="#1-1-2-典型的时间序列问题" class="headerlink" title="1.1.2 典型的时间序列问题"></a>1.1.2 典型的时间序列问题</h3><ul>
<li><p><strong>【单方程模型】随机游走假设</strong>：</p>
<pre><code class="hljs">- **模型**：$y_&#123;t+1&#125; = y_t + \varepsilon_&#123;t+1&#125;$，即 $\Delta y_&#123;t+1&#125; = \varepsilon_&#123;t+1&#125;$。
- **检验**：对更一般的方程 $\Delta y_&#123;t+1&#125; = a_0 + a_1 y_t + \varepsilon_&#123;t+1&#125;$，需验证 $a_0 = a_1 = 0$。
- 第 2 章到第 4 章将再次讨论如何恰当地估计单方程模型。
</code></pre></li>
<li><p><strong>【诱导方程和结构方程】</strong></p>
<pre><code class="hljs">- **结构方程**（structural equation）的内生因变量依赖于另一个内生变量（自变量）的当期实现值。
- **诱导方程**（reduced-form equation，我们也常说是简约式，例如计量中的 IV 估计）则是将内生变量表示成该变量 **滞后值**、其他内生变量的 **滞后值**、**外生变量** 的当期和过去值以及 **扰动项** 的函数。
- 我们可以简单的用“是否自变量纯粹为滞后变量”来判别。
</code></pre><blockquote>
<p>[!Example]</p>
<p>【例】</p>
<script type="math/tex; mode=display">
\begin{cases}
y_t = c_t + i_t \\
c_t = \alpha y_{t-1} + \varepsilon_{ct} \quad 0 < \alpha < 1 \\
i_t = \beta (c_t - c_{t-1}) + \varepsilon_{it} \quad \beta > 0 
\end{cases}\notag</script><p>消费函数中的当期消费仅仅依赖于滞后收入 $y_{t-1}$ 和扰动项 $\varepsilon$，它已经表示成了诱导方程。</p>
<p>而投资函数还不是诱导方程，因为当期投资还依赖于当期消费。那么，它的投资函数的诱导方程是什么？</p>
<script type="math/tex; mode=display">
\begin{align}
i_t &= \beta (c_t - c_{t-1}) + \varepsilon_{it} \notag \\ 
&= \beta (\alpha y_{t-1} + \varepsilon_{ct} - c_{t-1}) + \varepsilon_{it} \notag \\
&= \alpha \beta y_{t-1} - \beta c_{t-1} + \beta \varepsilon_t + \varepsilon_{it} \notag 
\end{align} \notag</script><p><strong>【练习】：请推导 $y_t$ 的诱导方程。如果消去所有 $c$ 呢？</strong></p>
<p>我们可以进一步简化得到下面的形式：</p>
<script type="math/tex; mode=display">
y_t = ay_{t-1} + by_{t-2} + x_t \notag</script><p>这是一个单变量诱导方程，$y_t$ 完全被表示为其滞后值和干扰项的函数。单变量模型用于预测特别有效，我们只需根据它当期和过去的实现值，就可对序列进行预测。</p>
</blockquote>
</li>
</ul>
<p>在学完第 2 章到第 4 章阐述的单变量时间序列分析方法后，第 5 章讨论当所有变量都被当作联合内生变量时的多变量模型估计。该章也讨论从已估诱导模型还原到结构模型所需的约束条件。</p>
<ul>
<li><strong>【误差纠正】无偏远期汇率（UFR）假设</strong>：<pre><code class="hljs">- **模型**：$s_&#123;t+1&#125; = f_t + \varepsilon_&#123;t+1&#125;$，其中 $s_&#123;t+1&#125;$ 为未来即期汇率，$f_t$ 为当前远期汇率。
- **回归检验**：$s_&#123;t+1&#125; = a_0 + a_1 f_t + \varepsilon_&#123;t+1&#125;$，要求 $a_0 = 0$、$a_1 = 1$，且残差 $\varepsilon_&#123;t+1&#125;$ 均值为零。
- **调整机制**：若 $s_&#123;t+1&#125; \neq f_t$，后续汇率和远期利率会通过下面的误差纠正模型联立调整： 
         - 如果即期汇率与远期汇率相等（$s_&#123;t+1&#125; = f_t$），则即期和远期汇率倾向于保持不变。
         - 如果即期与远期汇率之差为正，即 $s_&#123;t+1&#125; - f_t&gt;0$，则预期：即期汇率会趋于下降，远期汇率会趋于上升。
</code></pre></li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}
s_{t+2} = s_{t+1} - a(s_{t+1} - f_t) + \varepsilon_{s, t+2} \\
f_{t+1} = f_t + b(s_{t+1} - f_t) + \varepsilon_{f, t+1} \notag
\end{cases}</script><ul>
<li><strong>【非线性动态模型】趋势-周期关系</strong>：<pre><code class="hljs">- **分解公式**：$y_t = Trend + Cycle + Noise$。
- **趋势**：长期稳定增长或下降（如 GDP 的长期趋势）。
- **周期**：围绕趋势的短期波动（如商业周期）。
- **噪声**：随机不可预测部分（如突发政策冲击）。
- **应用**：摩擦性失业（Noise）、结构性失业（Trend，如房地产业）、周期性失业（Cycle，如经济危机）
</code></pre></li>
</ul>
<p>第 7 章将专门讨论一些具有更为复杂的 <strong>动态结构模型</strong> 的估计。</p>
<h2 id="1-2-平稳性"><a href="#1-2-平稳性" class="headerlink" title="1.2 平稳性"></a>1.2 平稳性</h2><p><strong>平稳性是时间序列分析的基础。</strong> </p>
<p>平稳性的存在使得不同时间点的随机变量具有类似的统计性质，这是统计推断和预测的基础。类比随机实验，任何一次实验的统计性质是一致的，因此，可以进行统计推断。</p>
<p><strong>平稳序列围绕 x 轴上下波动，非平稳序列则无序波动</strong>。平稳的本质是让系统稳定，让变量收敛。</p>
<p>平稳性有 <strong>严平稳</strong>（strictly stationary）和 <strong>弱平稳</strong>（weakly stationary）之分。</p>
<ul>
<li><p>严平稳是非常强的假设，它认为只有当序列所有的统计性质都不会随着时间的推移而发生变化时，该序列才被认为平稳。该假设使时间序列与无数次随机实验一致，这难以用经验方法验证。</p>
</li>
<li><p>弱平稳又被称为宽平稳。弱平稳不对随机变量的分布作要求，这就类似于每一次随机实验，可以是不同的实验，但任意两次实验之间存在一定关系，即均值和协方差。弱平稳下数据的时间序列图是围绕一个常数水平以相同的幅度上下波动。弱平稳性使我们可以对未来观测进行推断，即预测。</p>
</li>
<li><p><strong>严平稳太过严格，我们通常考虑弱平稳序列</strong>。</p>
</li>
</ul>
<blockquote>
<p>[!NOTE] 弱平稳的定义：</p>
<p>对于任意整数 $l$，如果 $y_t$ 的均值，以及 $y_t$ 和 $y_t-l$ 的协方差不随时间而改变，那么时间序列 $y_t$ 是弱平稳的。</p>
<p>换言之，当：$\mathbb{E}(y<em>t)$ 是常数、$\mathbb{Cov}(y_t, y</em>{t-l})$ 只依赖于 $l$ 时，时间序列 $y_t$ 是弱平稳的。</p>
<p>其中，$\gamma<em>l = \mathbb{Cov}(y_t, y</em>{t-l})$ 称为 $y<em>t$ 的间隔为 $l$ 的 <strong>自协方差</strong>，它满足：<br>    （1）当 $l=0$ 时， $\gamma_0 = \mathbb{Cov}(y_t, y_t) = \mathbb{Var}(y_t)$；<br>    （2）$\gamma_l = \gamma</em>{-l}$   这表明自协方差对于“预测未来“和”追溯过去”都是适用的。</p>
<p>对应的，我们也可以定义 <strong>自相关系数</strong>。$\rho = \dfrac{\gamma<em>l}{\gamma_0}$，也即是 $\rho = \dfrac{\mathbb{Cov}(y_t, y</em>{t-l})}{\mathbb{Var}(y_t)}$</p>
</blockquote>
<p>或者，我们更通俗地认识：</p>
<blockquote>
<p>[!Tip]   <strong>弱平稳</strong>（协方差平稳）需满足的条件： </p>
<ol>
<li><strong>均值恒定</strong>：$E(y_t) = \mu$（各时期数学期望恒定）  </li>
<li><strong>方差恒定</strong>：$\text{Var}(y_t) = \sigma^2$（各时期方差恒定） </li>
<li><strong>协方差仅依赖时间间隔（而不随时间变化）</strong>：$\text{Cov}(y<em>i, y_j) = \gamma</em>{|i-j|}$（任意两时期的协方差仅与时间间隔绝对值有关）</li>
</ol>
<p>怎么好像多了一个条件？事实上，方差恒定可以被涵盖在协方差不随时间变化的条件中。</p>
</blockquote>
<h2 id="1-3-差分方程及其解"><a href="#1-3-差分方程及其解" class="headerlink" title="1.3 差分方程及其解"></a>1.3 差分方程及其解</h2><h3 id="1-3-1-什么是差分？"><a href="#1-3-1-什么是差分？" class="headerlink" title="1.3.1 什么是差分？"></a>1.3.1 什么是差分？</h3><ul>
<li>我们首先认识一下“<strong>差分算子</strong>”，虽然名字很陌生，但事实上我们在学习微积分的时候就已经了解它了。让我们回忆亿下高数的导数内容：</li>
</ul>
<blockquote>
<p>[!Note] 导数的定义</p>
<p>导数描述了一个函数在某一点处的变化率。导数的定义基于极限的概念。</p>
<p>给定一个实数函数 $f(x)$，如果存在极限</p>
<script type="math/tex; mode=display">
f'(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h} \notag</script><p>那么，这个极限值称为函数 $f(x)$ 在点 $x$ 处的导数 。或者，我们常简写为：</p>
<script type="math/tex; mode=display">
f'(x) = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} \notag</script></blockquote>
<p>$\Delta$ 就是差分算子。一阶差分本质上就是做差。</p>
<ul>
<li><p>微积分中允许自变量的变化趋近于零。但由于大多数经济数据都是离散型的，所以，允许时间跨度大于零会更有益。运用差分方程时，我们将单位标准化，使 $h$ 代表时期（例如，$h=1$）的单位变化。</p>
</li>
<li><p>一阶差分 $\Delta y<em>t = y_t - y</em>{t-1}$。</p>
</li>
<li><p>二阶差分 $\Delta^2 y<em>t \equiv \Delta(\Delta y_t) = \Delta(y_t - y</em>{t-1}) = (y<em>t - y</em>{t-1}) - (y<em>{t-1} - y</em>{t-2}) = y<em>t - 2y</em>{t-1} + y_{t-2}$</p>
</li>
<li><p>类似地，可以给出 n 阶差分的定义。此时，我们已 <strong>冒险</strong> 将差分方程理论推广得过远。在时间序列分析中，很少需要使用差分。在实际应用中，几乎不会使用 3 阶及更高阶的差分方程。</p>
</li>
<li><p>为什么是 <strong>“冒险”</strong>？——类比于天气预报，更长期限的预测更失真。在第 1.4.2.1 节中（<a href="#1.4.2.1%20迭代法">1.4.2.1 迭代法</a>），我们有更数理直观的解释。</p>
</li>
</ul>
<h3 id="1-3-2-什么是差分方程？"><a href="#1-3-2-什么是差分方程？" class="headerlink" title="1.3.2 什么是差分方程？"></a>1.3.2 什么是差分方程？</h3><p>通常形式下，<strong>差分方程</strong> 将变量表示为该变量滞后值、时间和其他变量的函数。</p>
<blockquote>
<p>[!Note]</p>
<p>趋势性：$T_t = 1 + 0.1t$</p>
<p>季节性：$S_t = 1.6\sin\left(\frac{t\pi}{6}\right)$</p>
<p>无规则：$I<em>t = 0.7I</em>{t-1} + \varepsilon_t$</p>
<p>其中，趋势成分和季节成分都是时间 $t$ 的函数，而无规则成分则是它的滞后值和随机变量 $\varepsilon$ 的函数。</p>
</blockquote>
<p>由于大部分情况下，我们讨论的是线性时间序列，可以只考察带常数系数的 $n$​ 阶线性差分方程的特例。这种特殊类型的差分方程的形式为：</p>
<script type="math/tex; mode=display">
y_t = a_0 + \sum_{i = 1}^{n} a_i y_{t-i} + x_t \notag</script><p>公式的结构可以分解为以下几个部分：</p>
<ol>
<li>常数项 $a_0$</li>
<li>过去输出值的加权和：$\sum<em>{i=1}^{n} a_i y</em>{t-i}$，即从 $t-1$ 到 $t-n$ 的所有过去输出值的线性组合。$a_i$ 是权重。</li>
<li>当前外部输入 $x_t$（驱动因素、激励 、推动过程）。它可能是时间、其他变量的当期值或滞后值，和（或）随机干扰项的任一函数。通过恰当地选择推动过程，我们就可以得到大量重要的宏观经济模型。</li>
</ol>
<p>你可能会差评：这个差分方程看起来一点也不差分。的确，让我们给它变个形：</p>
<script type="math/tex; mode=display">
\Delta y_{t} = y_{t}-y_{t-1}= a_0+(a_1-1) y_{t-1}+\sum_{i = 2}^{n}a_{i}y_{t-i}+x_{t}\notag</script><p>它变丑了，也变得更让人眼熟了。</p>
<h2 id="1-4-差分方程的求解方法"><a href="#1-4-差分方程的求解方法" class="headerlink" title="1.4 差分方程的求解方法"></a>1.4 差分方程的求解方法</h2><h3 id="1-4-1-差分方程的解"><a href="#1-4-1-差分方程的解" class="headerlink" title="1.4.1 差分方程的解"></a>1.4.1 差分方程的解</h3><p>好了，我们现在认识了差分方程。这就够了吗？当然不。我们的目标是估计它，换言之，我们要：<strong>求解差分方程</strong>。</p>
<p>在求解之前，我们最好还是先明确我们的预期目标，也就是 <strong>差分方程的解</strong>（solution）。</p>
<p>差分方程的解是将 $y_t$ 值表示为序列 $x_t$ 的元素和 $t$ 的函数。解式中可能包括一些初始条件（initial condtion，即 $y_t$ 的一些给定值）。</p>
<blockquote>
<p>[!TIP]</p>
<p>解的主要特征在于：<strong>当时间 $t$ 和外部输入的 $x$ 取任何允许值时，它都满足差分方程</strong>。这使得我们可以对解进行验证。</p>
<p>换言之，只要满足差分方程，它就是差分方程的解。</p>
</blockquote>
<p><strong>【引例】</strong>：<strong>考察简单差分方程 $\Delta y_t = 2$ 的解</strong></p>
<p>由于 $\Delta y<em>t = y_t - y</em>{t-1} = 2$，我们很容易证明 $y_t$ 是公差为 2 的等差数列。$y_t = 2t + c$ 是差分方程 $\Delta y_t = 2$ 的解，这里 $c$ 为任意常数。</p>
<p>根据定义，如果 $2t + c$ 为一个解，则必定满足 $t$ 的所有允许值。因此，对于 $t-1$ 期，有 $y_{t-1} = 2(t-1) + c$，现在将解代入方程得：$2t + c \equiv 2(t-1) + c + 2$。这是一个恒等式。这也说明差分方程的解不是唯一的，$c$ 的任意一个取值都对应着一个解。</p>
<p>我们发现，差分方程的解有点像通项公式。事实上，一阶线性递推数列的通项公式是“常数+等比”；二阶线性递推数列的通项公式是“等比+等比”的形式。</p>
<blockquote>
<p>[!TIP]</p>
<p>解是一个函数而非数字。类似于数列的通项公式，我们最终求解差分方程的目标是一个涵盖每一个“特解”的函数，称为“通解”。我们将在后面的迭代法中介绍（尽管这些概念并不依赖于迭代求解方法）。</p>
<h3 id="1-4-2-迭代法求解差分方程"><a href="#1-4-2-迭代法求解差分方程" class="headerlink" title="1.4.2 迭代法求解差分方程"></a>1.4.2 迭代法求解差分方程</h3></blockquote>
<p>尽管迭代法是一种最麻烦、最耗时的方法，但它很直观。</p>
<h4 id="1-4-2-1-迭代法"><a href="#1-4-2-1-迭代法" class="headerlink" title="1.4.2.1 迭代法"></a>1.4.2.1 迭代法</h4><ul>
<li><p><strong>一阶方程迭代</strong>：</p>
<ul>
<li><p><strong>方程</strong>：$y<em>t = a_0 + a_1 y</em>{t-1} + \varepsilon_t$。</p>
</li>
<li><p><strong>迭代过程</strong>：</p>
<ul>
<li>第一期 $y_1 = a_0 + a_1 y_0 + \varepsilon_1$。</li>
<li>第二期 $y_2 = a_0 + a_1 y_1 + \varepsilon_2 = a_0(1 + a_1) + a_1^2 y_0 + a_1 \varepsilon_1 + \varepsilon_2$。</li>
<li>第三期 $y_3 =a_0 + a_1 y_2 + \varepsilon_3 = a_0(1 + a_1 + a_1^2) + a_1^3 y_0 + a_1^2 \varepsilon_1 + a_1 \varepsilon_2 + \varepsilon_3$。</li>
<li>第 $t$ 期 ？    <script type="math/tex; mode=display">
  y_t = a_0 \sum_{i = 0}^{t-1} a_1^i + a_1^t y_0 + \sum_{i = 0}^{t-1} a_1^i \varepsilon_{t-i} \notag</script><blockquote>
<p>[!Tip]</p>
<p>更多次的迭代，就有更大的误差。这在数理上呼应了 <a href="#1.3.1%20什么是差分？">1.3.1 什么是差分？</a> 关于更长时间序列预测的“冒险”。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>极限情况：当 $t \rightarrow ∞$ 时</strong></p>
</li>
<li><p><strong>当 $|a_1| &lt; 1$ 时</strong>：【第一项是几何级数，第二项趋于 0】</p>
<script type="math/tex; mode=display">
y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^∞ a_1^i \varepsilon_{t-i}\notag</script><ul>
<li><p><strong>思考</strong>：相对于其他情况，我们更关心 $|a_1| &lt; 1$ 的情况。为什么？</p>
<ul>
<li>数理上，这时收敛。站在 $t$ 期的节点上，上一期的 $y_{t-1}$ 是已知的参数。当 $|a_1| \geq 1$，无穷级数发散。</li>
<li>仅仅是因为数理上收敛可以求出吗？经济意义是什么？（Hint：类似于 WLS，你认为 2015 年 GDP 对今年 GDP 影响大还是 2024 年 GDP 对今年 GDP 影响大？所以我们应该怎么赋予权重？）</li>
</ul>
</li>
<li><p><strong>验证</strong>：这是 $y<em>t = a_0 + a_1 y</em>{t-1} + \varepsilon_t$ 的解吗？代入公式验证是成立的。</p>
</li>
<li><p>如果 <strong>反向迭代</strong>，这个式子还成立吗？</p>
<script type="math/tex; mode=display">
y_t = a_0 + a_1 y_{t-1} + \varepsilon_t \notag</script><p>将 $y_{t-1}$ 代入上述表达式中：</p>
<script type="math/tex; mode=display">
\begin{align}
y_t &= a_0 + a_1 [a_0 + a_1 y_{t-2} + \varepsilon_{t-1}] + \varepsilon_t  \notag\\
& = a_0 (1 + a_1) + a_1 \varepsilon_{t-1} + \varepsilon_t + a_1^2 [a_0 + a_1 y_{t-3} + \varepsilon_{t-2}]  \notag
\end{align}\notag</script><p>当 $|a_1| &lt; 1$ 时，$t \rightarrow ∞$ 的极限情况：</p>
<script type="math/tex; mode=display">
y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^\infty a_1^i \varepsilon_{t-i}\notag</script><script type="math/tex; mode=display">
y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^\infty a_1^i \varepsilon_{t-i}\notag</script></li>
</ul>
</li>
<li><p><strong>通解</strong>：在第 1.4.1 节（<a href="#1.4.1%20差分方程的解">1.4.1 差分方程的解</a>）最后，我们提到：差分方程的解有点像通项公式。那么，应该能够写出一个 <strong>通解</strong>，以涵盖前面的各个解（称为 <strong>特解</strong>）。课本对通解的提出比较突兀，这是因为涉及了齐次解的内容，我们在第 1.4.2.2 节讨论这一点。</p>
</li>
</ul>
<h4 id="1-4-2-2-齐次解和通解"><a href="#1-4-2-2-齐次解和通解" class="headerlink" title="1.4.2.2 齐次解和通解"></a>1.4.2.2 齐次解和通解</h4><ul>
<li><strong>齐次解</strong>：<ul>
<li>前面我们提到的是 $y<em>t = a_0 + a_1 y</em>{t-1} + \varepsilon_t$，仅考虑其中的齐次部分，就是齐次方程。</li>
<li><strong>一阶齐次方程</strong>：$y<em>t = a_1 y</em>{t-1}$，这可以被视作等比数列，通项公式还记得吗？</li>
<li>该齐次方程的解称为 <strong>齐次解</strong>（homogeneous solution），为 $y_t =A×(a_1)^t= A a_1^t$（A 任取）。</li>
<li><strong>收敛条件</strong>：$|a_1| &lt; 1$。这与 <a href="#1.2%20平稳性">1.2 平稳性</a> 是呼应的。</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!Note] 一阶齐次方程的齐次解与平稳性</p>
<ol>
<li><strong>当 $|a_1| &lt; 1$ 时</strong>：<ul>
<li>当 $t$ 趋于无穷大时，$a_1^t$ 收敛于零。</li>
<li>如果 $0 &lt; a_1 &lt; 1$，则称为直接收敛。</li>
<li>如果 $-1 &lt; a_1 &lt; 0$，则称为震荡收敛。</li>
</ul>
</li>
<li><strong>当 $|a_1| &gt; 1$ 时</strong>：<ul>
<li>齐次解不稳定。</li>
<li>如果 $a_1 &gt; 1$，齐次解随 $t$ 的增大趋于无穷大。</li>
<li>如果 $a_1 &lt; -1$，齐次解是震荡发散性的。</li>
</ul>
</li>
<li><strong>当 $a_1 = 1$ 时</strong>：任意一个常数 $A$ 都满足齐次方程 $y<em>t = y</em>{t-1}$。</li>
<li><strong>当 $a_1 = -1$ 时</strong>，方程的解正负交替变化：$t$ 取偶数，$a_1^t = 1$；$t$ 取奇数，$a_1^t = -1$。</li>
</ol>
</blockquote>
<ul>
<li><strong>通解</strong>： 正如我们在第 1.4.1 节（<a href="#1.4.1%20差分方程的解">1.4.1 差分方程的解</a>）最后部分所指出的，差分方程的解更像一种通项公式。那么，应该能够写出一个 <strong>通解</strong>，以涵盖 $y<em>t = a_0 + a_1 y</em>{t-1} + \varepsilon_t$ 的所有 <strong>特解</strong>。在第 1.4.2.1 节（<a href="#1.4.2.1%20迭代法">1.4.2.1 迭代法</a>）中，我们考虑到了一个比较特殊的特解：当 $t \rightarrow ∞$ 时的特解：<script type="math/tex; mode=display">
y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^∞ a_1^i \varepsilon_{t-i}\notag</script></li>
</ul>
<p>现在，我们构造 <strong>通解</strong>：其两个组成部分正是齐次解、特解。如上所述，齐次解为 $y_t = A a_1^t$，A 可以任意取值。</p>
<script type="math/tex; mode=display">
y_t = A a_1^t + \frac{a_0}{1 - a_1} + \sum_{i = 0}^{\infty} a_1^i \varepsilon_{t-i} \notag</script><p>在通解的基础上，如果我们再施加初始条件 $y_0$，就可以消去任意常数 A 了。</p>
<h3 id="1-4-3-解差分方程的通用步骤"><a href="#1-4-3-解差分方程的通用步骤" class="headerlink" title="1.4.3 解差分方程的通用步骤"></a>1.4.3 解差分方程的通用步骤</h3><p>我们已经分析了一阶的情况，现在考虑更高阶的。迭代法求解方程不宜用于高阶方程，在复杂的代数式面前，任何试图求解的努力都是徒劳的。那么，有什么好办法呢？</p>
<p>在经济分析中，出现更高阶的差分方程并不奇怪。根据萨缪尔森模型(1939)得到的 GDP 的诱导方程（见 <a href="#1.1.2%20典型的时间序列问题">1.1.2 典型的时间序列问题</a>），就是 <strong>二阶差分方程</strong> 的例子。此外，在时间序列计量经济学中对二阶和更高阶差分方程的估计也相当典型。</p>
<blockquote>
<p>[!TIP] <strong>【通用步骤】</strong><br>一阶例子中的结论直接适用于 n 阶差分方程。一般情况下，寻找特解更为困难，并且还有 n 个不同的齐次解。但是，解答时总是遵照以下四个步骤。</p>
<p>第 1 步：建立齐次方程，求出 n 个齐次解；</p>
<p>第 2 步：求出一个特解；</p>
<p>第 3 步：求特解和所有齐次解的一个线性组合，求和得出通解；</p>
<p>第 4 步：将初始条件代入通解中，消去任意常数。</p>
</blockquote>
<p>要考察齐次差分方程的解法，首先，我们考察二阶差分。按照上面的步骤，我们做个例题：</p>
<blockquote>
<p>[!Note] 【例 1】 求解 $y<em>t = 0.9y</em>{t-1} - 0.2y<em>{t-2} + 3$，初始条件 $y</em>{0}=13$，$y_{1}=11.4$</p>
<p><strong>第 1 步：建立齐次方程</strong></p>
<script type="math/tex; mode=display">
y_t - 0.9y_{t-1} + 0.2y_{t-2} = 0 \notag</script><p><strong>找到齐次解</strong>：稍后我们将说明如何找到完整的齐次解。现在，我们直接给出两个齐次解为：</p>
<p>$y^h<em>{1t} = (0.5)^t \quad \text{和} \quad y^h</em>{2t} = (0.4)^t$</p>
<p>要证明第一个解，应注意到 $y^h<em>{1,t-1} = (0.5)^{t-1}$ 和 $y^h</em>{1,t-2} = (0.5)^{t-2}$。因此，如果满足：$(0.5)^t - 0.9(0.5)^{t-1} + 0.2(0.5)^{t-2} = 0$， 那么 $y^h_{1t}$ 就是一个解。等式两边同除以 $(0.5)^{t-2}$，问题就变为是否满足下式：$(0.5)^2 - 0.9(0.5) + 0.2 = 0$。显而易见，确实等于零，同理也可验证另一个。</p>
<p><strong>第 2 步：求出一个特解</strong>。</p>
<p>显然，很容易证明特解 $y_{t}^{p}=10$ 也是一个解，因为 $10=0.9\cdot(10)-0.2\cdot(10)+3$。</p>
<p><strong>第 3 步：合并特解和两个齐次解的线性组合</strong></p>
<script type="math/tex; mode=display">
y_{t}= a_1(0.5)^{t}+A_{2}(0.4)^{t}+10 \notag</script><p>这里，$a<em>1$ 和 $A</em>{2}$ 为任意常数。</p>
<p><strong>第 4 步：序列初始条件</strong></p>
<p>在 0 期和 1 期，解必须满足</p>
<script type="math/tex; mode=display">
\begin{cases}
13 = a_1+A_{2}+10 \\
11.3 = a_1\cdot(0.5)+A_{2}\cdot(0.4)+10 
\end{cases}\notag</script><p>联立求解，得 $a<em>1=1,A</em>{2}=2$。因此，$y_t$ 的解为</p>
<script type="math/tex; mode=display">
y_{t}=(0.5)^{t}+2(0.4)^{t}+10 \notag</script></blockquote>
<h3 id="1-4-4-高阶齐次解：特征根"><a href="#1-4-4-高阶齐次解：特征根" class="headerlink" title="1.4.4 高阶齐次解：特征根"></a>1.4.4 高阶齐次解：特征根</h3><p>第一步很麻烦，有没有什么办法？事实上，从验证齐次解的方式中，我们可以窥见特征根分析的端倪。下面，我们更系统地介绍如何得到齐次解。</p>
<p>设数列 ${x<em>n}$ 的前两项 $x_1$ 和 $x_2$ 已知，且满足递推关系 $x</em>{n+1} = px<em>n + qx</em>{n-1}$。则称方程 $x^2 - px - q = 0$ 为该数列的 <strong>特征方程</strong>。特征方程的根为该数列的 <strong>特征根</strong>。</p>
<blockquote>
<p>[!tip]</p>
<ul>
<li><strong>方程</strong>：$y<em>t - a_1 y</em>{t-1} - a<em>2 y</em>{t-2} = 0$。</li>
<li><strong>特征方程</strong>：$\alpha^2 - a_1 \alpha - a_2 = 0$。</li>
<li><strong>根的情况</strong>：<ul>
<li><strong>实根且不同</strong>：$y_t = A_1 \alpha_1^t + A_2 \alpha_2^t$。</li>
<li><strong>实根且相同</strong>：$y_t = (A_1 + A_2 t) \alpha^t$。</li>
<li><strong>虚根</strong>：用欧拉公式表示为 $y_t = r^t (C_1 \cos \theta t + C_2 \sin \theta t)$，其中 $r = \sqrt{a_2}$，$\theta = \arctan\left(\frac{\sqrt{4a_2 - a_1^2}}{a_1}\right)$。</li>
</ul>
</li>
<li><strong>稳定性条件</strong>：所有特征根绝对值小于 1。稳定性条件要求 r &lt; 1，因此，当把根绘制在复数平面上时，必须让它们位于一个半径为 1 的圆内。在时间序列文献中，稳定性条件的简单表述是：<strong>所有的特征根都位于单位圆之内</strong>。</li>
</ul>
</blockquote>
<p>我们再看个例子：</p>
<blockquote>
<p>[!note] 【例 2】：求齐次解</p>
<ul>
<li><strong>方程</strong>：$y<em>t = 0.2 y</em>{t-1} + 0.35 y_{t-2}$。</li>
<li><strong>特征方程</strong>：$\alpha^2 - 0.2 \alpha - 0.35 = 0$，解得特征根 $\alpha_1 = 0.7$，$\alpha_2 = -0.5$。</li>
<li><strong>齐次解</strong>：$y_t = A_1 (0.7)^t + A_2 (-0.5)^t$。</li>
</ul>
</blockquote>
<p>很好！我们会算第一步了。返回刚才的例 1，我们可以重新算一下。</p>
<h3 id="1-4-5-特解的处理"><a href="#1-4-5-特解的处理" class="headerlink" title="1.4.5 特解的处理"></a>1.4.5 特解的处理</h3><p>除了第一步对于高阶齐次解计算有着精妙的技巧，在例 1 中，我们非常不负责任的“显然易得”了特解。也很显然，我们的运气可能不总是能让我们“显然”发现特解。基于此，我们这一小节讨论特解的情况。需要强调的是，由于特解本就是“妙手偶得”的，我们在（<a href="#1.4.4%20高阶齐次解：特征根">1.4.4 高阶齐次解：特征根</a>）中讨论的所有找特解方法都只是方便找特解的技巧。</p>
<h4 id="1-4-5-1-推动过程为零的特解"><a href="#1-4-5-1-推动过程为零的特解" class="headerlink" title="1.4.5.1 推动过程为零的特解"></a>1.4.5.1 推动过程为零的特解</h4><p>寻找差分方程的特解需要智慧和毅力，方法的选取主要取决于序列 ${x}$ 的形式。遵循由浅入深的原则，我们先讨论一种特殊情况的特解，即 <strong>当 $x_t=0$ 时</strong> 的特解。</p>
<p>当序列 ${x_{t}}$ 的所有元素均为零时，差分方程变为  </p>
<script type="math/tex; mode=display">
  y_{i} = a_0 + a_1y_{i-1} + a_2y_{i-2} + \cdots + a_ny_{i-n}\notag</script><p>这和前面的例 2 非常相似，事实上，例 2 是给定参数的二阶特例。在第 1.4.4 节（<a href="#1.4.4%20高阶齐次解：特征根">1.4.4 高阶齐次解：特征根</a>）中，我们只算出了例 2 的齐次解，还没有得到方程的通解。遵循第 1.4.3 节（<a href="#1.4.3%20解差分方程的通用步骤">1.4.3 解差分方程的通用步骤</a>）的通用步骤，我们对方程 $y<em>t = 0.2 y</em>{t-1} + 0.35 y_{t-2}$ 的求解还需要找到特解。通过下面对 $n$ 阶情况的讨论，我们应该能够为例 2 的求解画上圆满的句号。</p>
<p>由于我们正在找的是特解，所以我们不用顾及任何“大而全”的普适性，只需要找最特殊的就足够了。直觉告诉我们，$y$ 取相同值（即 $y<em>i=y</em>{i-1}=\cdots=c$）应该是目标差分方程最特殊的解了。虽然我们在这里也不可避免的“显然易得”了，但相较于例 1 的“显然”，这里的直觉容易得多。将常解 $y_i=c$ 代入得到 $c=a_0+a_1c+a_2c+\cdots+a_nc$，因而 </p>
<script type="math/tex; mode=display">
c =\dfrac{a_0}{1-a_1-a_2-\cdots-a_n}\notag</script><p>由于分式的分母不能为 0，我们分类讨论：</p>
<p>只要 $(1-a_1-a_2-\cdots-a_n)$ 不等于零，$c$ 值就是差分方程的解。因此，差分方程的特解就为 $y^p_i=\dfrac{a_0}{1-a_1-a_2-\cdots-a_n}$。 </p>
<p>如果 $1-a_1-a_2-\cdots-a_n=0$，$c$ 值是待定的，必须寻找解的其他形式。课本的讨论为我们提供了下一步的方向：我们应该考虑尝试 $y^p_i=ct$ 作为解，如果还不成立，就继续尝试 $y^p_i=c \cdot t^2$、$y^p_i=c \cdot t^3$…… 总有一个会是特解的。</p>
<p>接下来，我们兑现前面的承诺，对例 2 的特解进行讨论。</p>
<blockquote>
<p>[!Note] 【例 2】 的特解</p>
<p>对于方程：$y<em>t = 0.2 y</em>{t-1} + 0.35 y_{t-2}$，我们取常解 $y_i=c$ 的特殊情况。代入得：</p>
<script type="math/tex; mode=display">
c =\dfrac{a_0}{1-a_1-a_2}\notag</script><p>其中，$a_0=0$，$a_1=0.2$，$a_2=0.35$。我们得到差分方程的特解 $c$，发现就等于 0。更正式一点的写法是：</p>
<script type="math/tex; mode=display">
y^p_i =\dfrac{a_0}{1-a_1-a_2}= 0 \notag</script><p>有了特解 $y^p_i=0$ 和齐次解 $y_t = A_1 (0.7)^t + A_2 (-0.5)^t$，我们就可以得到该差分方程的通解了。</p>
</blockquote>
<h4 id="1-4-5-2-待定系数法"><a href="#1-4-5-2-待定系数法" class="headerlink" title="1.4.5.2 待定系数法"></a>1.4.5.2 待定系数法</h4><p>那么，如果特解比较随机，怎么处理？</p>
<p>当序列 ${y_t}$ 含有随机成分时，有两种求特解的方法。我们先讨论待定系数法。</p>
<p>待定系数法的关键在于，线性方程具有线性解。因此，一个线性差分方程的特解必定是线性的。此外，求得的解仅依赖于时间、常数和推动过程的元素。因此，即使解的系数未知，仍有可能求得解的准确形式。这种方法涉及一个假设的解，可称这个假设的解为 <strong>挑战解</strong>(challenge solution)，它是实际方程中应当出现的所有项的线性函数。这样，问题就转化成了寻找所有满足差分方程解的待定系数的值。</p>
<h5 id="1-4-5-2-1-含有确定性成分的情况"><a href="#1-4-5-2-1-含有确定性成分的情况" class="headerlink" title="1.4.5.2.1 含有确定性成分的情况"></a>1.4.5.2.1 含有确定性成分的情况</h5><p>我们首先看两个含有确定性成分的情况：</p>
<ul>
<li><strong>情况 1：含指数的例子</strong>。</li>
</ul>
<p>在这种情况下，我们令 $x_t$ 取指数形式 $b \cdot (d)^{rt}$，其中，b、d、r 都为常数。由于 r 通常被解释为增长率，我们在有关增长的研究中更可能碰到它。我们运用一阶差分方程阐述求解过程： </p>
<script type="math/tex; mode=display">
y_{i} = a_0 + a_1y_{i-1} +b \cdot (d)^{rt} \notag</script><p>特别地，当 $b=0$ 的时候，差分方程退化为 $x_t=0$ 的差分方程。事实上，我们可以把 $(d)^{rt}$ 看作 ${(d^{r})^t}$，即把 $d^{r}$ 看作整体。</p>
<p>我们可以 <strong>假设特解的形式</strong> 为：（即挑战解为）</p>
<script type="math/tex; mode=display">
y_{t}^{p}= c_0+c_1({d^{r})}^t \notag</script><p>其中，$c_0$ 和 $c_1$ 都是常数。如果该方程确实是一个解，可以将其代入递推公式得到一个恒等式。通过恰当的代换，得到</p>
<script type="math/tex; mode=display">
c_0+c_1{d^r}^t = a_0+a_1 [c_0+c_1 {d^r}^{(t-1)}]+b{d^r}^t \notag</script><p>整理这个公式，如果这个公式成立，有 $c_0$ 和 $c_1$ 满足</p>
<script type="math/tex; mode=display">
c_0 =\frac{a_0}{1-a_1}, c_1 =\frac{bd^r}{d^r-a_1} \notag</script><p>因此，特解就为</p>
<script type="math/tex; mode=display">
y^p_t =\frac{a_0}{1-a_1}+\frac{bd^r}{d^r-a_1} \cdot {d^r}^t  \notag</script><p>这个解的特点就是：$y^p_t$ 等于常数 $\dfrac{a_0}{1-a_1}$ 加上一个增速为 $r$ 的表达式。</p>
<p>注意，对于 $|d^r|&lt;1$，特解会收敛为 $\dfrac{a_0}{1-a_1}$。</p>
<p>同样地，在 $a_1=1$ 或 $a_1=d^r$ 的时候，必须寻找解的其他形式。这时的技巧是：当 $a_1 =1$ 时，尝试使用 $c_0=ct$ 作为解；而当 $a_1=d^r$ 时，尝试使用 $c_1=tb$ 作为解。其中所用的方法完全适用于高阶方程。</p>
<ul>
<li><strong>情况 2：确定性时间趋势</strong>。<br>这时，序列 ${x_t}$ 可表示为关系式 $x_t= bt^d$，其中 b 为常数，d 为正整数。<script type="math/tex; mode=display">
y_t = a_0 + \sum_{i = 1}^{t} a_i y_{t-i} + d \cdot t^d \notag</script>由于 $y<em>t$ 依赖于 $t^d$，则 $y</em>{t-1}$ 依赖于 $(t-1)^d$，$y_{t-2}$ 依赖于 $(t-2)^d$，等等。这样，特解的形式为：<script type="math/tex; mode=display">
y_t^p = c_0 + c_1 t + c_2 t^2 + \cdots + c_d t^d \notag</script>为找到 $c_i$ 的取值，可将特解代入，从 $c_i$ 的恒等式中得到每个 $c_i$ 的取值。</li>
</ul>
<p><strong>【发现】</strong>：这个特解的假设和情况 2 正好形成对照：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tx">[**特解的情况**]<br>|         $x_t$ 形式          |         假设的特解（一阶差分）          |<br>| :-----------------------: | :--------------------------: |<br>| 令$x_t$取指数形式$b \cdot d^t$  | $y_&#123;t&#125;^&#123;p&#125;= c_0+c_1 d^t$ |<br>| 令 $x_t$ 取幂函数形式 $b \cdot t^d$ |   $y_t^p = c_0 + c_1 t^d$    |<br></code></pre></td></tr></table></figure><br>尽管 $d$ 可以取多个值，但在经济应用中，模型中通常含有一个线性时间趋势 ($d=1$)。 举个例子，请考察 2 阶差分方程 $y<em>t = a_0 + a_1 y</em>{t-1} + a<em>2 y</em>{t-2} + bt$。假设解为：</p>
<script type="math/tex; mode=display">
y_t^p = c_0 + c_1 t \notag</script><p>其中，$c_0$ 和 $c_1$ 都是待定系数，试着将这个“挑战解”代入该 2 阶差分方程，得到 </p>
<script type="math/tex; mode=display">
c_0 + c_1 t = a_0 + a_1 [c_0 + c_1 (t - 1)] + a_2 [c_0 + c_1 (t - 2)] + bt \notag</script><p>现在选择 $c_0$ 和 $c_1$ 的值，使得对 $t$ 的所有可能取值都为恒等式。如果合并所有常数项和包括 $t$ 在内的所有项，则所要求的 $c_0$ 和 $c_1$ 的取值就为 </p>
<script type="math/tex; mode=display">
\begin{cases}
c_1 = \dfrac{b}{1 - a_1 - a_2} \\
\\
c_0 = \dfrac{a_0 - (2a_2 + a_1)c_1}{1 - a_1 - a_2} =\dfrac{a_0}{1 - a_1 - a_2} - \dfrac{b \cdot (2a_2 + a_1) }{(1 - a_1 - a_2)^2}
\end{cases}\notag</script><h5 id="1-4-5-2-2-一般化"><a href="#1-4-5-2-2-一般化" class="headerlink" title="1.4.5.2.2 一般化"></a>1.4.5.2.2 一般化</h5><p>我们已经考虑了含有确定性成分的情况，现在我们外推到一般化的情况。也就是说，我们考虑包含 $\varepsilon_t$ 的 ${x_t}$。这时，我们应该如何使用待定系数法？</p>
<ul>
<li><strong>一阶方程</strong>：$y<em>t = a_0 + a_1 y</em>{t-1} + \varepsilon_t$。</li>
</ul>
<p>序列 ${y_t}$ 的特点是特征解仅依赖于常数项、时间 $t$ 和序列 ${\varepsilon_t}$。因此，我们设定的挑战解应该包括常数项、时间趋势项和关于 $\varepsilon$ 的项。</p>
<p>考虑到 $\varepsilon$ 是白噪声（零均值、无自相关），其特解需体现历史扰动的累积效应，即：过去每一期误差项 $\varepsilon$ 各自对当前值 $y<em>t$ 的影响求和。由于各期对现在的影响不尽相同（越接近现在的权重应该更高，这在第 1.3.2 节中曾阐释过），因此对于每个误差项都应该配有对应的权重参数（记为 $\alpha$，$0&lt;\alpha&lt;1$）。由此，特解中应该包含 $\sum</em>{i=0}^{\infty} \alpha<em>i \varepsilon</em>{t-i}$。</p>
<p>综上，我们设定的挑战解为：</p>
<script type="math/tex; mode=display">
y_t = b_0 + b_1 t + \sum_{i = 0}^{\infty} \alpha_i \varepsilon_{t-i}  \notag</script><p>代入求解得，$b_1=0$，$b_0 = \frac{a_0}{1 - a_1}$。</p>
<ul>
<li><strong>二阶方程</strong>：$y<em>t = a_0 + a_1 y</em>{t-1} + a<em>2 y</em>{t-2} + \varepsilon_t$<ul>
<li><strong>挑战解</strong>：$y<em>t = b_0 + b_1 t + b_2 t^2 + \sum</em>{i=0}^\infty \alpha<em>i \varepsilon</em>{t-i}$。</li>
<li><strong>代入求解</strong>：通过比较系数确定 $b_0, b_1, b_2$ 及 $\alpha_i$​。</li>
</ul>
</li>
</ul>
<p>首先，考虑当 $a_1 + a_2 \neq 1$ 时的情况，由于 $(1 - a_1 - a_2)$ 不为零，那么，$b_2$ 的取值必须等于 0。在 $b_2 = 0$ 的情况下，又因为 $t$ 的系数必须等于零，所以，$b_1$ 也应为 0。在给定 $b_1 = b_2 = 0$ 时，必得 $b_0 = \dfrac{a_0}{1 - a_1 - a_2}$。</p>
<p>相反，如果 $a_1 + a_2 = 1$，则 $b_t$ 的解的取值取决于 $a_0, a_1$ 和 $a_2$ 的特定取值。</p>
<p>关键在于齐次方程的稳定性条件就是特解的收敛条件。如果齐次方程的任意特征根都等于 1，那么，多项式时间趋势就将出现在特解中。多项式的阶数就是单位特征根的个数，这一结论也可推广到高阶方程。</p>
<h4 id="1-4-5-3-滞后算子"><a href="#1-4-5-3-滞后算子" class="headerlink" title="1.4.5.3 滞后算子"></a>1.4.5.3 滞后算子</h4><p>如果不需要知道特解中的系数的实际值，则运用滞后算子（lag operator）的方法通常比待定系数法更为方便。</p>
<ul>
<li><p><strong>定义</strong>：滞后算子 $L$ 被定义为线性算子，因而对 $y_t$ 取任意值，均有：</p>
<script type="math/tex; mode=display">
L^i y_t = y_{t-i} \notag</script><p><strong>滞后算子 $L$</strong> 仅意味着将序列 $y<em>t$ 向后移动一期，即 $L{y_t} = y</em>{t-1}$。请问，$L^2_{y_t}=?$</p>
</li>
<li><p><strong>性质</strong>:</p>
<ol>
<li>常数的滞后值为常数： $L_c = c$。</li>
<li>分配律：$L(y<em>1 + y_2) = Ly_1 + Ly_2 = y</em>{t-1,1} + y_{t-1,2}$。</li>
<li>结合律： $L^iLy<em>j = L^{i+j}y = y</em>{t-i-j}$，注意 $L^iy<em>t = y</em>{t-i}$。</li>
<li>取负次方： 实际上为超前算子: $L^{-1}y<em>t = y</em>{t+1}$。为了便于解释，可定义 $j = -i$，并设 $L^jy<em>t = y</em>{t+j}$。</li>
<li>无限求和：<ul>
<li>对于 $|\alpha| &lt; 1$，有 $(1 + a L + a^2 L^2 + \cdots)L^n y_t = \dfrac{y_t}{1 - a L}$。</li>
<li>对于 $|\alpha| &gt; 1$，有 $[1 + (aL)^{-1} + (aL)^{-2} + (aL)^{-3} + \cdots]y_t = \dfrac{-aL{y_t}}{1 - aL}$。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>滞后算子的应用</strong>：</p>
</li>
</ul>
<ol>
<li>滞后算子为书写差分方程提供了一种简洁的记号。运用滞后算子，可以将 p 阶方程 $y<em>t = a_0 + a_1 y</em>{t-1} + \cdots + a<em>p y</em>{t-p} + \varepsilon_t$ 写为：</li>
</ol>
<script type="math/tex; mode=display">
(1 - a_1 L - a_2 L^2 - \cdots - a_p L^p) y_t = A(L) y_t = a_0 + \varepsilon_t \notag</script><p>其中，$A(L)$ 为多项式 $(1 - a_1 L - a_2 L^2 - \cdots - a_p L^p)$。它的成立是基于此前的 $y$ 对于现在而言都是参数。</p>
<ol>
<li>由于 $A(L)$ 可被视为滞后算子的多项式，因此记号 $A(1)$ 可用于表示所有系数之和：</li>
</ol>
<script type="math/tex; mode=display">
A(1) = 1 - a_1 - a_2 - \cdots - a_p \notag</script><ul>
<li><strong>用滞后算子解线性差分方程</strong>：<br>  再次考虑一阶方程 $y<em>{t}=a_0+a_1y</em>{t-1}+\varepsilon_{t}$，式中，$\mid a_1 \mid &lt;1$。根据 L 的定义，构造</li>
</ul>
<script type="math/tex; mode=display">
y_t = a_0+a_1Ly_t+\varepsilon_t \notag</script><p>解 $y_t$，我们得到：</p>
<script type="math/tex; mode=display">
y_{t}=\frac{a_0+\varepsilon _{t}}{1-a_1L} \notag</script><p>根据性质(1)，可知 $La_0=a_0$，因而 $\dfrac{a_0}{1-a_1L}=a_0+a_1a_0+a_1^{2}a_0+\cdots =\dfrac{a_0}{1-a_1}$。</p>
<p>根据性质(5)，可知 $\dfrac{\varepsilon<em>{t}}{1-a_1L}=\varepsilon</em>{t}+a<em>1\varepsilon</em>{t-1}+a<em>1^{2}\varepsilon</em>{t-2}+\cdots$，合并解的两个部分，便得到迭代法得到的特解。</p>
<ul>
<li>【<strong>一般化</strong>】滞后算子可以把方程表示为：</li>
</ul>
<script type="math/tex; mode=display">
y_t = a_0 + a_1 y_{t-1} + \cdots + a_p y_{t-p} + \varepsilon_t + \beta_1 \varepsilon_{t-1} + \cdots + \beta_q \varepsilon_{t-q} \Rightarrow A(L) y_t = a_0 + B(L) \varepsilon_t \notag</script><p>其中，$A(L)$ 和 $B(L)$ 分别为 p 阶和 q 阶的多项式。该模型的特解为：</p>
<script type="math/tex; mode=display">
y_t = \frac{a_0}{A(L)} + \frac{B(L)\varepsilon_t}{A(L)}\notag</script><p>如果想了解序列的实际系数，最好采用待定系数法，滞后算子的魅力在于能够简洁地标记特解。</p>
<h2 id="1-5-自回归（AR）模型"><a href="#1-5-自回归（AR）模型" class="headerlink" title="1.5 自回归（AR）模型"></a>1.5 自回归（AR）模型</h2><p>不知道你是否有注意到，在 1.4 节中，我们对差分方程的讨论主要围绕着的是 1.3.2 节提出的“一种特殊类型的差分方程”。现在，我们正式认识下这个“威名赫赫”的重要模型——<strong>自回归模型</strong>（Auto-regression Model），简称 AR($p$)。值得注意的是，这一节的内容大多数都已经在前面讲过，如果说前面的讲法更偏数学，这一节的讲法则是更统计学的。</p>
<h3 id="1-5-1-自回归模型"><a href="#1-5-1-自回归模型" class="headerlink" title="1.5.1 自回归模型"></a>1.5.1 自回归模型</h3><blockquote>
<p>[!Note] 定义（自回归模型）<br>如果时间序列 ${y_t}$ 能用如下形式表示：</p>
<script type="math/tex; mode=display">
\begin{split}
y_t &= a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \cdots + a_p y_{t-p} + \varepsilon_t \\
&= a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + \varepsilon_t \notag
\end{split}</script><p>则称 ${y<em>t}$ 服从 $p$ 阶自回归模型，记为 AR($p$)，其中，p 为模型的阶数， $\varepsilon_t$ 是均值为 0、标准差为 $\sigma</em>\varepsilon$ 的白噪声序列。</p>
<p>AR($p$) 模型表示：给定过去的数据时，过去的 $p$ 个值 $y_{t-i}(i=1,2,\ldots,p)$ 联合决定 $y_t$ 的条件期望。</p>
<h3 id="1-5-2-AR-1-模型"><a href="#1-5-2-AR-1-模型" class="headerlink" title="1.5.2 AR(1)模型"></a>1.5.2 AR(1)模型</h3></blockquote>
<ul>
<li>当阶数 $p = 1$ 时，AR($p$)模型简化为 AR(1)模型，即<script type="math/tex; mode=display">y_t = a_0 + a_1 y_{t-1} + \varepsilon_t, \quad \varepsilon_t \sim i.i.d. N(0, \sigma_\varepsilon^2) \notag</script></li>
<li><p>AR(1)模型刻画了一个随机过程或时间序列：${r_t, t \in Z}$；</p>
</li>
<li><p>根据 AR(1)模型定义有：</p>
<ul>
<li>条件期望：$E(y<em>t | y</em>{t-1}) = a<em>0 + a_1 y</em>{t-1}$</li>
<li>条件方差：$Var(y<em>t | y</em>{t-1}) = \sigma_\varepsilon^2$</li>
</ul>
</li>
</ul>
<h4 id="1-5-2-1-AR-1-的线性特征"><a href="#1-5-2-1-AR-1-的线性特征" class="headerlink" title="1.5.2.1 AR(1)的线性特征"></a>1.5.2.1 AR(1)的线性特征</h4><p>正如我们在 <a href="#1.4.2.1%20迭代法">1.4.2.1 迭代法</a> 中所做的，将 AR(1)模型的递推可以得到</p>
<script type="math/tex; mode=display">
        y_t = a_0 \sum_{i = 0}^{t-1} a_1^i + a_1^t y_0 + \sum_{i = 0}^{t-1} a_1^i \varepsilon_{t-i} \notag</script><ul>
<li>当 $|a_1| &lt; 1 \quad t \rightarrow ∞$，第一项是几何级数，第二项趋于 0，有：<script type="math/tex; mode=display">
y_t = \frac{a_0}{1 - a_1} + \sum_{i = 0}^∞ a_1^i \varepsilon_{t-i}\notag</script></li>
<li><p>这是一个线性时间序列，被称为 MA($∞$) 形式。自然地，我们会问：什么是 MA？MA 是移动平均模型的简写，我们会在 <a href="#2.1.2%20移动平均模型（MA）">2.1.2 移动平均模型（MA）</a> 内容中更详细的介绍它。关于 AR 和 MA 的互推条件，我们也将在 <a href="#2.3.5.2%20可逆性">2.3.5.2 可逆性</a> 中进一步论述。</p>
<h4 id="1-5-2-2-AR-1-的平稳性"><a href="#1-5-2-2-AR-1-的平稳性" class="headerlink" title="1.5.2.2 AR(1)的平稳性"></a>1.5.2.2 AR(1)的平稳性</h4></li>
<li><p>AR(1)模型的平稳性指时间序列 ${y_t}$ 是否是一个平稳时间序列。直观理解，任意给定一个初始值 $y_0$，经过一段时间后，序列可以稳定下来，即围绕某个固定值以相同的幅度上下波动。</p>
</li>
<li><p>不是所有 AR(1)模型刻画的随机过程都是平稳时间序列：当 AR(1)模型刻画了一个平稳的时间序列，则称 AR(1)模型是平稳的；当 AR(1)模型刻画了一个非平稳的时间序列，则称 AR(1)模型是非平稳的。平稳的 AR(1) 模型才能用于预测。</p>
</li>
<li><p><strong>AR(1)模型平稳性的充要条件是：$|a_1| &lt; 1$</strong>。</p>
</li>
</ul>
<blockquote>
<p>[!Note] 证明：AR(1)模型平稳性的充要条件是：$|a_1| &lt; 1$。</p>
<p>首先，我们简单回顾 <a href="#1.2%20平稳性">1.2 平稳性</a> 节对平稳性的介绍：</p>
<ul>
<li><p>严平稳太过严格，我们通常考虑弱平稳序列。</p>
</li>
<li><p><strong>弱平稳的定义</strong>：当 $E(y<em>t)$ 是常数、$Cov(y_t, y</em>{t-l})$ 只依赖于 $l$ 时，时间序列 $y_t$ 是弱平稳的。</p>
</li>
</ul>
<p>然后，我们开始证明：</p>
<p>   <strong>1. 充分性：</strong><br>   （1）当 $|a_1| &lt; 1$，我们先考察 $E(y_t)$ 是否为常数：</p>
<script type="math/tex; mode=display">
   y_t = \dfrac{a_0}{1-a_1} + \sum_{i = 0}^{\infty} a_1^i \varepsilon_{t-i} \quad \Rightarrow \quad \mathbb{E}(y_t) = \dfrac{a_0}{1-a_1} \quad (\text{常数})</script><p>   （2）然后，我们考察 $|a_1| &lt; 1$ 时的协方差：</p>
<script type="math/tex; mode=display">
    \mathbb{Cov}(y_t, y_{t-l}) = \mathbb{Cov}\left(\sum_{i = 0}^{\infty} a_1^i \varepsilon_{t-i}, \sum_{j = 0}^{\infty} a_1^j \varepsilon_{t-l-j}\right)</script><p>   根据协方差的定义，我们可以将其展开为双重求和：</p>
<script type="math/tex; mode=display">
\mathbb{Cov}(y_t, y_{t-l}) = \mathbb{Cov}\left (\sum_{i = 0}^\infty a_1^i \varepsilon_{t-i}, \sum_{j = 0}^\infty a_1^j \varepsilon_{t-l-j}\right) = \sum_{i = 0}^\infty \sum_{j = 0}^\infty a_1^i a_1^j \mathbb{Cov}(\varepsilon_{t-i}, \varepsilon_{t-l-j})</script><p>由于 $\varepsilon$ 是一个方差为 $\sigma^2$ 的白噪声过程，不同时间的 $\varepsilon$ 不相关，则协方差项仅在时间点相等时非零（$=\sigma^2$），即当 $t - i = t - l - j$ 时，也就是 $i = l + j$。因此，双重求和中只有当 $i = l + j$ 时才有贡献。将 $i$ 替换为 $l + j$，我们得到单重求和：</p>
<script type="math/tex; mode=display">
\mathbb{Cov}(y_t, y_{t-l}) = \sum_{j = 0}^\infty a_1^{l+j} a_1^j \mathbb{Cov}(\varepsilon_{t-l-j}, \varepsilon_{t-l-j})= \sigma^2 \sum_{j = 0}^\infty a_1^{l+2j} = a_1^l \cdot \sigma^2 \sum_{j = 0}^\infty (a_1^2)^j = \frac{a_1^l \sigma^2 }{1-a_1^2}</script><p>这表明，协方差只依赖于 $l$，与 $t$ 无关。如果认为双重求和转化为单重求和太复杂，<a href="#2.3.3.1%20自相关函数（ACF）">2.3.3.1 自相关函数（ACF）</a> 还提供了另一种递推的方法。</p>
<p>综上，AR(1)模型在 $|a_1| &lt; 1$ 时满足弱平稳的定义。</p>
<p><strong>2. 必要性</strong><br>假设 ${y<em>t}$ 是平稳时间序列，对 AR(1)公式 $y_t = a_0 + a_1 y</em>{t-1} + \varepsilon_t$ 两边取期望得到：</p>
<script type="math/tex; mode=display">
\mathbb{E}(y_t) = a_0 + a_1 \mathbb{E}(y_{t-1}) \quad \Rightarrow \quad \mathbb{E}(y_t) = \frac{a_0}{1 - a_1}</script><p>两边取方差得到：</p>
<script type="math/tex; mode=display">
\mathbb{Var}(y_t) = \mathbb{Var}(a_0 + a_1 y_{t-1} + \varepsilon_t) = a_1^2 \mathbb{Var}(y_{t-1}) + \mathbb{Var}(\varepsilon_t) + a_1 \mathbb{Cov}(y_{t-1}, \varepsilon_t)</script><ul>
<li>根据 $y<em>t = \frac{a_0}{1 - a_1} + \sum</em>{i = 0}^∞ a<em>1^i \varepsilon</em>{t-i}$，$y<em>t$ 完全由 $t$ 期及以前的冲击决定，进而 $y</em>{t-1}$ 完全由 $t-1$ 期及以前的冲击决定，由于冲击之间的独立性，$\mathbb{Cov}(y_{t-1}, \varepsilon_t) = 0$；</li>
<li>【<font color="#245bdb"> 非常重要 </font>】<strong>基于 ${y<em>t}$ 平稳的假设，方差在时间上恒定，即 $\mathbb{Var}(y_t)=\mathbb{Var}(y</em>{t-1})$。</strong></li>
<li><p>由此可得到：<script type="math/tex">\mathbb{Var}(y_t) = \frac{\sigma_\varepsilon^2}{1 - a_1^2}</script></p>
<p>为了使  $\mathbb{E}(y_t) = \dfrac{a_0}{1 - a_1}$  存在且为常数，则要求 $a_1 \neq 1$ ；</p>
<p>为了使  $\mathbb{Var}(y_t) = \dfrac{\sigma_a^2}{1 - a_1^2}$  存在且为正常数，则要求 $|a_1| &lt; 1$ 。<br>即  ${y_t}$  为平稳序列要求 $|a_1| &lt; 1$。</p>
</li>
</ul>
</blockquote>
<h4 id="1-5-2-3-AR-1-的统计特征"><a href="#1-5-2-3-AR-1-的统计特征" class="headerlink" title="1.5.2.3 AR(1)的统计特征"></a>1.5.2.3 AR(1)的统计特征</h4><p>在上一节中我们得到：对于平稳 AR(1)序列 $y<em>t = a_0 + a_1 y</em>{t-1} + \varepsilon<em>t$ ，有：$\mathbb{E}(y_t) = \dfrac{a_0}{1 - a_1}$ ，$\mathbb{Var}(y_t) = \dfrac{\sigma</em>\varepsilon^2}{1 - a_1^2}$。其中 $a_0$ 是截距项，$a_1$ 是滞后项系数。</p>
<ul>
<li><p>当 $a_0 = 0$ 时，$\mathbb{E}(y_t) = 0$，这表明没有截距项的 AR(1)模型，时间序列的均值为 0。</p>
</li>
<li><p>当 $a_1 = 0$ 时，此时时间序列 ${y_t}$ 变为白噪声序列，方差最小；当 $a_1 ≠ 0$ 时，序列 ${y_t}$ 的方差变大，这说明时间序列 ${y_t}$ 自相关系数越大，时间序列的方差越大，波动越剧烈。</p>
</li>
<li><p>下面，我们考察 AR(1)模型的自相关系数。根据方程，由于 <script type="math/tex">\mathbb{Cov}(y_t, y_{t-l}) = \frac{a_1^l}{1 - a_1^2} \sigma_\varepsilon^2,</script> 因此自相关系数（如果忘记了自相关系数，请参阅 <a href="#1.2%20平稳性">1.2 平稳性</a>）为： <script type="math/tex">\rho = \dfrac{\mathbb{Cov}(y_t, y_{t-l})}{\mathbb{Var}(y_t)} = \dfrac{\dfrac{a_1^l}{1 - a_1^2} \sigma_\varepsilon^2}{\dfrac{1}{1 - a_1^2} \sigma_\varepsilon^2} = a_1^l.</script> 这说明：当 $∣a_1​∣&lt;1$ 时，弱平稳 AR(1) 序列的自相关函数随滞后阶数 $l$ 增大而指数衰减。</p>
<h3 id="1-5-3-AR-2-模型"><a href="#1-5-3-AR-2-模型" class="headerlink" title="1.5.3 AR(2)模型"></a>1.5.3 AR(2)模型</h3></li>
</ul>
<p>当阶数 $p = 2$ 时，AR(p) 模型简化为 AR(2) 模型，形式如下：  </p>
<script type="math/tex; mode=display">y_t = a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \varepsilon_t, \quad \varepsilon_t \text{ 是白噪声过程}</script><ul>
<li><p><strong>1. AR(2)模型的线性性质</strong>： 首先，将 AR(2) 转换为 VAR(1) 形式： </p>
<script type="math/tex; mode=display">\begin{pmatrix}  
y_t \\  
y_{t-1} \end{pmatrix}  
= \begin{pmatrix}  
a_0 \\  
0 \end{pmatrix}  + \begin{pmatrix}  
a_1 & a_2 \\  
1 & 0  \end{pmatrix} \begin{pmatrix}  
y_{t-1} \\  
y_{t-2} \end{pmatrix}  + \begin{pmatrix}  
\varepsilon_t \\  
0 \end{pmatrix}</script><p>设 $\mathbf{Y}<em>t = (y_t, y</em>{t-1})^\top$，$\mathbf{u}<em>t = (\varepsilon_t, 0)^\top$，则方程可改写为：  $$ \mathbf{Y}_t = \mathbf{A}_0 + \mathbf{A}_1 \mathbf{Y}</em>{t-1} + \mathbf{u}_t $$<br>向前递推得到：  </p>
<script type="math/tex; mode=display">
\mathbf{Y}_t = \mathbf{A}_0 + \mathbf{A}_1 \mathbf{A}_0 + \mathbf{A}_1^2 \mathbf{Y}_{t-2} + \mathbf{A}_1 \mathbf{u}_{t-1} + \mathbf{u}_t = \cdots 
= (1 - \mathbf{A}_1)^{-1} \mathbf{A}_0 + \mathbf{A}_1^\infty \mathbf{Y}_{t-\infty} + \sum_{i = 0}^\infty \mathbf{A}_1^i \mathbf{u}_{t-i}</script><p>当矩阵 $\mathbf{A}<em>1$ 的特征值都位于单位圆内时，$\mathbf{A}_1^\infty = 0$，方程可简化为：$$ \mathbf{Y}_t = (1 - \mathbf{A}_1)^{-1} \mathbf{A}_0 + \sum</em>{i=0}^\infty \mathbf{A}<em>1^i \mathbf{u}</em>{t-i} $$ 进一步得到 $y_t$ 的表达式：  </p>
<script type="math/tex; mode=display">y_t = (1, 0)(1 - \mathbf{A}_1)^{-1} \mathbf{A}_0 + \sum_{i=0}^\infty b_i \varepsilon_{t-i}</script><p>其中 $b_i = (1, 0)\mathbf{A}_1^i(1, 0)^\top$，即 $\mathbf{A}_1^i$ 的第 $(1, 1)$ 个元素。 $\mu = (1, 0)(1 - \mathbf{A}_1)^{-1} \mathbf{A}_0$  。</p>
</li>
<li><p><strong>2. AR(2)模型平稳条件</strong></p>
</li>
</ul>
<p>利用 1.4.5.3 节讲到的滞后算子改写：$y<em>t = a_0 + a_1 y</em>{t-1} + a<em>2 y</em>{t-2} + \varepsilon_t$ ，得到：$$<br>\begin{align<em>}<br>\Big(1 - a_1 L - a_2 L^2\Big) y_t = A(L) y_t = a_0 + \varepsilon_t<br>\end{align</em>}  </p>
<script type="math/tex; mode=display">其中：$A(L)$ 称为 AR(2)模型的**特征多项式**。根据特征多项式得到 AR(2)模型的~~**特征方程**~~：</script><p>\begin{align<em>}<br>A(x) = 1 - a_1 x - a_2 x^2 = 0<br>\end{align</em>}  </p>
<script type="math/tex; mode=display">
<center> <b><span style="background:#fff88f">AR (2) 模型平稳的充要条件是：上述特征方程的根全在单位圆外。</span></b> </center>

- 不对啊！这和我们前面 1.4.4 节讲的不一样！在 1.4.4 节中，我们要求特征根在单位圆内！
   - 这里用词很讲究：“特征方程的根”而不是“特征根”！
   - 1.4.4 节中，特征根对应的特征方程和这个不一样！当时我们的特征方程是：$\lambda^2 - p\lambda - q = 0$。这里的特征方程可以看作是 $x=\dfrac{1}{\lambda}$ 的改写。所以，这里的特征方程应该被叫做 **"逆特征方程"**。
   - 本质上讲，在这里，滞后算子 $L$ 的影响相当于整体除以 $y_t$。而在 1.4.4 节，我们的整体除以 $y_{t-2}$！（对于 AR(p)，1.4.4 节的方法是整体除以 $y_{t-p}$）。

- **AR(2)平稳的充要条件为： AR(2)模型的特征根均在单位圆内**。
- 【或者】：**AR(2)模型平稳的充要条件是：AR(2)模型的逆特征方程的根全在单位圆外。**

>[!Excercise]
>考虑四组 $\{a_1, a_2\}$ 组合下的 AR(2) 过程平稳性：
>1. $a_1 = 0.4, a_2 = 0.5$
>2. $a_1 = -0.6, a_2 = 0.5$
>3. $a_1 = 0.7, a_2 = -0.1$
>4. $a_1 = 1.2, a_2 = -0.8$

### 1.5.4 AR(p)模型

我们先写出 AR(p) 模型的形式，然后分析它的线性特征和平稳性特征： 
$$\begin{split}
y_t &= a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \cdots + a_p y_{t-p} + \varepsilon_t \\
 &= a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + \varepsilon_t \notag
\end{split}</script><ol>
<li><p><strong>线性特征</strong>：类似于 AR(2)，最后递推得到：</p>
<script type="math/tex; mode=display">
y_t = \mathbf{A}_0 (I_p - \mathbf{A}_1)^{-1} + \mathbf{A}_1^\infty y_{t-\infty} + \sum_{i = 0}^\infty \mathbf{A}_1^i \boldsymbol{u}_{t-i}</script><ul>
<li>当特征根均在单位圆内时，为线性时间序列。</li>
</ul>
</li>
<li><p><strong>平稳性</strong>：</p>
<ul>
<li><strong>AR(p) 模型的特征多项式</strong>：<script type="math/tex; mode=display">
A(L) = 1 - a_1 L - a_2 L^2 - \cdots - a_p L^p</script></li>
<li><strong>AR(p) 模型对应的逆特征方程</strong>：<script type="math/tex; mode=display">A(L) = 1 - a_1 L - a_2 L^2 - \cdots - a_p L^p = 0</script></li>
<li><strong>AR(p) 模型平稳的充要条件</strong>：  <script type="math/tex; mode=display">
1 - a_1 L - a_2 L^2 - \cdots - a_p L^p = 0</script>逆特征方程的所有根均位于 <strong>单位圆外</strong>（模长 &gt; 1）。<br>或通过变量替换 $x = 1/L$，方程改写为  <script type="math/tex; mode=display">
x^p - a_1 x^{p-1} - \cdots - a_p = 0</script>要求所有特征根均位于 <strong>单位圆内</strong>（模长 &lt; 1）。</li>
</ul>
</li>
</ol>
<h1 id="Chapter-2-平稳时间序列模型"><a href="#Chapter-2-平稳时间序列模型" class="headerlink" title="Chapter 2: 平稳时间序列模型"></a>Chapter 2: 平稳时间序列模型</h1><blockquote>
<p>[!IMPORTANT] 本章学习目标</p>
<ol>
<li><p>阐述随机线性差分方程理论。</p>
</li>
<li><p>拓展在估计 ARMA 模型中使用的工具。</p>
</li>
<li><p>考察平稳和非平稳模型的时间序列性质。</p>
</li>
<li><p>考察多种统计检验方法来检验模型的充分性。文中举了几个例子，详细地分析了估计出的 AR-MA 模型，并说明如何运用恰当的已估模型进行预测。</p>
</li>
<li><p>推导不同 ARMA 过程的理论自相关函数。</p>
</li>
<li><p>推导不同 ARMA 过程的理论偏自相关函数。</p>
</li>
<li><p>阐述 Box-Jenkins 方法在模型选择过程中是怎样依赖于自相关和偏自相关的，</p>
</li>
<li><p>扩展 Box-Jenkins 模型选择工具的完备集。</p>
</li>
<li><p>检验时间序列预测的性质。</p>
</li>
<li><p>以利率期限结构模型为例证明 Box-Jenkins 方法。</p>
</li>
<li><p>阐述模型序列如何包含季节因素。</p>
</li>
<li><p>扩展模型精确度的诊断性检验。</p>
</li>
<li><p>阐述组合预测为何明显优于单个模型的预测。</p>
</li>
</ol>
</blockquote>
<h2 id="2-1-随机差分方程模型"><a href="#2-1-随机差分方程模型" class="headerlink" title="2.1 随机差分方程模型"></a>2.1 随机差分方程模型</h2><p>目标：模拟动态经济过程</p>
<h3 id="2-1-1-白噪声过程"><a href="#2-1-1-白噪声过程" class="headerlink" title="2.1.1 白噪声过程"></a>2.1.1 白噪声过程</h3><p>白噪声（white-noise）过程是一种特殊的时间序列模型，对应的是纯随机序列。</p>
<blockquote>
<p>[!Note] 定义：白噪声<br>若序列中每个元素均值都为零，同时具有同方差，且与所有其他的实现值之间不存在自相关，则序列 ${\varepsilon_t}$ 为白噪声过程。</p>
<p><strong><font color="#c00000"> 白噪声过程的统计特征：零均值，同方差，无自相关（协方差为 0）</font></strong>。对于正态分布而言，不相关即可推出独立，所以如果该白噪声如果服从正态分布，则其还将互相独立。</p>
</blockquote>
<p>根据 <strong>白噪声过程的统计特征</strong>，我们可以得到：如果序列 ${\varepsilon_t}$ 为白噪声过程，有：</p>
<p><strong>【零均值】</strong>：若符号 $E(x)$ 代表 $x$ 的理论均值，对每个时期 $t$，有：<script type="math/tex">E(\varepsilon_t)=E(\varepsilon_{t-1})=\cdots=0</script> <strong>【同方差】</strong>：用 $Var(x)$ 代表 $x$ 的方差，对每个时期 $t$，有：<script type="math/tex">\operatorname{Var}(\varepsilon_t)=\operatorname{Var}(\varepsilon_{t-1})=\cdots=\sigma^2</script> 或者，由于 $Var(x)= E(x^2)- [E(x)]^2$ ，结合零均值特征  $E(x)≡0$，有：</p>
<script type="math/tex; mode=display">E(\varepsilon_t^2)=E(\varepsilon_{t-1}^2)=\cdots=\sigma^2</script><p><strong>【无自相关（协方差为 0）】</strong> 对所有的 $j$ 和 $s$，有：<script type="math/tex">\operatorname{Cov}(\varepsilon_t,\varepsilon_{t-j})=\operatorname{Cov}(\varepsilon_{t-j},\varepsilon_{t-j-s})=0</script>  或者，由于 $Cov(x，y)=E(xy)-E(x)E(y)$，结合零均值特征  $E(x)=E(y)=0$，有：</p>
<script type="math/tex; mode=display">E(\varepsilon_t\varepsilon_{t-j})=E(\varepsilon_{t-1}\varepsilon_{t-j-s})=0</script><blockquote>
<p>[!Tip]  思考：<strong>白噪声</strong> 是平稳过程吗？<br>（提示：结合 <a href="#1.2%20平稳性">1.2 平稳性</a> 对于时间序列弱平稳的讨论）  </p>
<ol>
<li><strong>均值恒定</strong>：$E(y_t) = \mu$（各时期数学期望恒定）  </li>
<li><strong>方差恒定</strong>：$\text{Var}(y_t) = \sigma^2$（各时期方差恒定） </li>
<li><strong>协方差仅依赖时间间隔（而不随时间变化）</strong>：$\text{Cov}(y<em>i, y_j) = \gamma</em>{|i-j|}$（任意两时期的协方差仅与时间间隔绝对值有关）</li>
</ol>
<p><strong><font color="#c00000"> 我们发现，白噪声符合以上三个要求，白噪声是平稳过程。</font></strong></p>
<p>事实上，白噪声序列一定是平稳序列, 而且是最简单的平稳序列。若给定时间序列是白噪声序列，则无需预测。</p>
</blockquote>
<h3 id="2-1-2-移动平均模型（MA）"><a href="#2-1-2-移动平均模型（MA）" class="headerlink" title="2.1.2 移动平均模型（MA）"></a>2.1.2 移动平均模型（MA）</h3><p>现在，我们用白噪声过程来构造移动平均模型（MA 模型）。MA 模型基于白噪声序列的假设，描述的是当前时间点的数据与过去噪声的关系。</p>
<h4 id="2-1-2-1-移动平均模型是什么？"><a href="#2-1-2-1-移动平均模型是什么？" class="headerlink" title="2.1.2.1 移动平均模型是什么？"></a>2.1.2.1 移动平均模型是什么？</h4><p>移动平均模型（MA）的 <strong>核心思想</strong> 是：我们可以把一个时间序列看作是过去若干期噪声的加权平均，即当前的观察值是由过去的白噪声通过一定的线性组合得到的。</p>
<p>即，MA(q)模型可以写成：</p>
<script type="math/tex; mode=display">
x_t = \beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} + \cdots +\beta_q \varepsilon_{t-q} = \sum_{i = 0}^{q} \beta_i \varepsilon_{t-i} \notag</script><p>对任意时期 $t$，对 $\varepsilon<em>t$，$\varepsilon</em>{t-1}$，…，$\varepsilon_{t-q}$ 依次取值并乘以对应的 $\beta_i$ 即可计算出 $x_t$，我们把这样的序列称为 $q$ 阶移动平均（moving average），用 MA $(q)$ 表示。</p>
<ul>
<li>$x_t$ 是我们感兴趣的时间序列在时间点 $t$ 的观察值。</li>
<li>$\varepsilon<em>t, \varepsilon</em>{t-1}, \varepsilon<em>{t-2}, \dots, \varepsilon</em>{t-q}$：这些是白噪声项，每个时间点的值都是独立同分布的，通常假设为正态分布。这些项的均值为 $0$，方差为 $\sigma^2$（常数）。$\varepsilon<em>t$ 是当前时刻的白噪声，$\varepsilon</em>{t-1}$ 是上一时刻的白噪声，依此类推，$\varepsilon_{t-q}$ 是 $q$ 个时刻前的白噪声。  </li>
<li>$\beta_1, \beta_2, \dots, \beta_q$：这些是 MA 模型的参数，每个参数 $\beta$ 都对应一个白噪声项。它们衡量的是对应的白噪声对当前时间点的影响程度。 </li>
<li>$q$ 是阶数，表示有多少个过去的白噪声项被纳入模型，指的是在模型中包含的过去白噪声项的数量。例如，如果 $q=2$，那么模型就包含了 $\varepsilon<em>{t-1}$ 和 $\varepsilon</em>{t-2}$ 两个白噪声项。</li>
</ul>
<blockquote>
<p>[!Excercise] 练一练：请写出 MA($∞$)</p>
</blockquote>
<p><strong>【补充】</strong>：在一些版本的 MA 模型中，模型被写作 <script type="math/tex">x_t = \mu + \varepsilon_t + \beta_1 \varepsilon_{t-1} + \cdots +\beta_q \varepsilon_{t-q} \notag</script> 它较上面模型有两处改变：（1）多包括时间序列的均值或期望值 $\mu$ ，$\mu$ 对所有的时间点都是相同的。不加 $\mu$ 的时间序列可以被视为 <strong>已经通过差分或去趋势转换为均值为零</strong> 的序列。（2）为方便采用标准化，使 $\beta_0$ 恒等于 1。</p>
<blockquote>
<p>[!Tip] 为什么叫做【移动平均模型】？<br>移动平均模型（MA）认为：大部分时候时间序列应当是相对稳定的。在稳定的基础上，每个时间点上的值受过去一段时间内、不可预料的各种偶然事件影响而波动。</p>
<p>即在一段时间内，<strong>时间序列应该是围绕着某个均值上下波动的序列</strong>，时间点上的值会围绕着某个均值移动，因此模型才被称为“移动平均模型“。<strong>它的预测值是过去白噪声的加权平均</strong>。</p>
<p>[!Note] MA 模型的前提假设<br>移动平均模型（MA）的基本假设可以从以下几个方面来理解：</p>
<ol>
<li><p><strong>平稳性</strong>：MA 模型假设时间序列是平稳的。这意味着序列的主要统计属性，如均值和方差，不随时间变化。这个假设强调了序列在长期内保持稳定的行为，而在短期内可能会受到随机因素的影响。</p>
</li>
<li><p><strong>白噪声</strong>：MA 模型假设存在一个白噪声序列。白噪声是随机误差项，它的均值为 0，方差为常数，且各个时间点上的值是相互独立的。这个假设强调了在一段较短的时间内，时间序列的波动可能受到不可预测的随机因素的影响。</p>
</li>
<li><p><strong>线性</strong>：MA 模型假设时间序列可以被过去的白噪声项的线性组合表示。这就是模型被称为“移动平均”模型的原因，因为它的预测值是过去白噪声的加权平均。</p>
</li>
<li><p><strong>有限历史影响</strong>：MA 模型假设只有过去的 q 个白噪声才对当前时间点的值有影响，其中 q 是模型的阶数。换言之，<span style="color: blue">过去更久的白噪声对当前值没有直接影响</span>（如 $cov(x<em>t,x</em>{t-q-1})=0$）。</p>
</li>
<li><p><strong>值的关联性与白噪声的独立性</strong>：MA 模型假设不同时间点的值之间是关联的，这反映了历史影响时间序列的长期趋势。而偶然事件在不同时间点上产生的影响（即白噪声）是相互独立的，这反映了在短期内，时间序列的波动可能受到不可预测的随机因素的影响。</p>
</li>
</ol>
</blockquote>
<p><strong>【举个例子】</strong>：影响明日会不会下雨的真正因素并不是“今天”或“昨天”这些时间概念本身，而是风、云、日照等更加客观和科学的因素（这些其实就是 MA 模型认为的“偶然因素”）。不过也能够理解，随着季节的变化、时间自有自己的周期，因此天气也会存在季节性的周期，因此从长期来看时间序列的趋势是恒定的。</p>
<h4 id="2-1-2-2-MA-q-的平稳性"><a href="#2-1-2-2-MA-q-的平稳性" class="headerlink" title="2.1.2.2 MA(q) 的平稳性"></a>2.1.2.2 MA(q) 的平稳性</h4><p>我们先展示结论：</p>
<blockquote>
<p>[!Note] MA(q) 的平稳性：</p>
<ul>
<li><strong>当 $q$ 为有限值时，MA(q) 一定是平稳过程。</strong></li>
<li><strong>当 $q \to \infty$（无穷阶 MA），若对任意 $s$ 有 $\beta<em>0 + \beta_1 \beta</em>{s+1} + \beta<em>2 \beta</em>{s+2} + \cdots$ 收敛，则 MA($\infty$) 也是平稳过程。</strong>  </li>
</ul>
</blockquote>
<p>下面我们为上述结论给出证据。我们的逻辑是：先针对 MA(1)、MA(2) 的情况讨论，然后外推。</p>
<p><span style="background:#fff88f">【MA(1) 的平稳性】</span>：<strong>考虑 MA(1)：$x<em>t = \beta_0 \varepsilon_t + \beta_1 \varepsilon</em>{t-1}$</strong></p>
<p>为体现一般性，我们考虑未经过【去趋势 $\mu=0$ 】和【标准化校准 $\beta_0=1$ 】 的 MA(1)。 </p>
<script type="math/tex; mode=display">x_t = \mu + \beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} \notag</script><p>结合 <a href="#1.2%20平稳性">1.2 平稳性</a> 对于时间序列弱平稳的讨论，我们要说明 MA(1) 平稳，就要证明其满足：  </p>
<ol>
<li><strong>均值恒定</strong>：$E(x_t) = \mu$（各时期数学期望恒定）  </li>
<li><strong>方差恒定</strong>：$\text{Var}(x_t) = \sigma^2$（各时期方差恒定） </li>
<li><strong>协方差仅依赖时间间隔（而不随时间变化）</strong>：$\text{Cov}(x<em>i, x_j) = \gamma</em>{|i-j|}$（任意两时期的协方差仅与时间间隔绝对值有关）</li>
</ol>
<font color="#c00000">（1）均值恒定 </font>
通过对 MA(1) 左右两边同时取期望，我们得到： $E(x_t) = \mu + \beta_0 E(\varepsilon_t)+ \beta_1 E(\varepsilon_{t-1})$ 。回忆 [2.1.1 白噪声过程](#2.1.1%20白噪声过程) 中白噪声的统计特征，$E(\varepsilon_t)=E(\varepsilon_{t-1})≡0$，因此有： $E(x_t) = \mu$ 为常数。

<font color="#c00000">（2）方差恒定 </font>
然后，我们考虑方差是否恒定。我们得到：$Var(x_t) = \beta_0^2Var(\varepsilon_t) + \beta_1^2 Var(\varepsilon_{t-1})$ 。回忆 [2.1.1 白噪声过程](#2.1.1%20白噪声过程) 中白噪声的统计特征 $Var(\varepsilon_t)=Var(\varepsilon_{t-1})=\sigma^2$，因此得到： $Var(x_t) = (\beta_0^2+\beta_1^2)\sigma^2$ 为常数。

<font color="#c00000">（3）协方差不随时间变化 </font>
**自协方差函数**  $\gamma_l = Cov(x_t, x_{t-l}) = Cov(\mu+\beta_0 \varepsilon_t+\beta_1\varepsilon_{t-1}, \mu + \beta_0 \varepsilon_{t-l} + \beta_1\varepsilon_{t-l-1})$
- 当 $l=0$ 时，实际上就讨论了方差是否恒定：
$$ \gamma_0 = Var(x_t) = \beta_0^2Var(\varepsilon_t) + \beta_1^2 Var(\varepsilon_{t-1}) = (\beta_0^2+\beta_1^2)\sigma^2 \quad (\text{存在且为常数}) $$
- 当 $l=1$ 时，由 [2.1.1 白噪声过程](#2.1.1%20白噪声过程) 中白噪声的统计特征，$Cov(\varepsilon_t,\varepsilon_{t-l})=0$ ，有：
   $$\begin{split}
  \gamma_1 = Cov(x_t, x_{t-1}) &= Cov(\beta_0 \varepsilon_t+\beta_1\varepsilon_{t-1}, \beta_0 \varepsilon_{t-1}+\beta_1\varepsilon_{t-2}) \\
  &=\beta_0^2 Cov(\varepsilon_t,\varepsilon_{t-1})+ \beta_0 \beta_1 Var(\varepsilon_{t-1})+\beta_0 \beta_1 Cov(\varepsilon_t,\varepsilon_{t-2}) + \beta_1^2 Cov(\varepsilon_{t-1},\varepsilon_{t-2})\\
   &= \beta_0 \beta_1 \sigma^2  \quad (\text{存在且为常数})
   \end{split}$$
- 当 $l \geq 2$ 时，这时 $l > q$。基于 MA 模型的有限历史影响，过去更久的白噪声对当前值没有直接影响，$\gamma_l = Cov(x_t, x_{t-l}) = 0 \quad (\text{存在且为常数})$

<span style="background:#fff88f">【MA (2) 的平稳性】</span>：设 MA (2) 过程为：  
$$x_t = \mu + \beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} + \beta_2 \varepsilon_{t-2}$$
其中 $\varepsilon_t$ 是白噪声过程，满足 $E(\varepsilon_t)=0$, $Var(\varepsilon_t)=\sigma^2$, $Cov(\varepsilon_t,\varepsilon_{t-l})=0$。

<font color="#c00000">（1）均值恒定  </font>
    对 MA (2) 两边取期望：$E(x_t) = E(\mu) + \beta_0 E(\varepsilon_t) + \beta_1 E(\varepsilon_{t-1}) + \beta_2 E(\varepsilon_{t-2}) = \mu  \quad (\text{常数})$

<font color="#c00000">（2）方差恒定  </font>
    计算方差： $Var(x_t) = \beta_0^2 Var(\varepsilon_t) + \beta_1^2 Var(\varepsilon_{t-1}) + \beta_2^2 Var(\varepsilon_{t-2}) = (\beta_0^2 + \beta_1^2 + \beta_2^2)\sigma^2 \quad (\text{常数})$

<font color="#c00000">（3）协方差不随时间变化 </font>
    考虑自协方差函数，滞后阶数 $l$ ：
- $l=0$ 时，实际上就讨论了方差是否恒定：  $\gamma_0 = Var(x_t) = (\beta_0^2 + \beta_1^2 + \beta_2^2)\sigma^2 \quad (\text{常数})$
- $l=1$ 时，由 [2.1.1 白噪声过程](#2.1.1%20白噪声过程) 中白噪声的统计特征，$Cov(\varepsilon_t,\varepsilon_{t-l})=0$ ，有：
$$\begin{aligned}
\gamma_1 &= Cov(x_t, x_{t-1}) = Cov(\beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} + \beta_2 \varepsilon_{t-2}, \beta_0 \varepsilon_{t-1} + \beta_1 \varepsilon_{t-2} + \beta_2 \varepsilon_{t-3}) \\
&= \beta_0\beta_1 Var(\varepsilon_{t-1}) + \beta_1\beta_2 Var(\varepsilon_{t-2}) \\
&= (\beta_0\beta_1 + \beta_1\beta_2)\sigma^2 \quad (\text{常数})
\end{aligned}$$
- $l=2$ 时： $\gamma_2$ 为常数：$$\gamma_2 = Cov(x_t, x_{t-2}) = Cov(\beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} + \beta_2 \varepsilon_{t-2}, \beta_0 \varepsilon_{t-2} + \beta_1 \varepsilon_{t-3} + \beta_2 \varepsilon_{t-4}) = \beta_0\beta_2\sigma^2$$
- $l≥3$ 时，这时 $l > q$。基于 MA 模型的有限历史影响，过去更久的白噪声对当前值没有直接影响，$\gamma_l = Cov(x_t, x_{t-l}) = 0$ ，存在且为常数。

> [!Note] 【外推：MA(q) 的平稳性】：
> **<font color="#c00000">【思考】</font> 请借助前面的 MA(1) 和 MA(2) 找规律，给出 MA(q) 的均值、方差、协方差。**
> 
> **MA (q) 模型的平稳性**  （有限阶移动平均过程）  
> $$x_t = \mu + \sum_{i=0}^q \beta_i \varepsilon_{t-i}$$
>     1. 均值：$E(x_t)=\mu$  
>     2. 方差：$Var(x_t)=\sigma^2 \sum_{i=0}^q \beta_i^2$  
>     3. 协方差：$Cov(x_t,x_{t-l})=\sigma^2 \sum_{i=l}^q \beta_i \beta_{i-l} \quad (l \leq q)$
> 
> **平稳性结论**  ：由于求和项为有限项，MA (q) 过程始终满足均值恒定、方差有限恒定、协方差仅依赖时间间隔，因此 **当 $q$ 为有限值时，MA (q) 总是平稳的**

那么，**当 $q \to \infty$（无穷阶 MA）** 呢？

> [!Tip] <font color="#245bdb">【外推：MA (∞) 的平稳性】</font>
> **无限 MA 过程**  （无穷阶移动平均过程）  
$$x_t = \mu +\sum_{i=0}^\infty \beta_i \varepsilon_{t-i}$$  
>     1. 均值：$E(x_t)=\mu$  
>     2. 方差：$Var(x_t)=\sigma^2 \sum_{i=0}^\infty \beta_i^2$  
>     3. 协方差：$Cov(x_t,x_{t-l})=\sigma^2 \sum_{i=l}^\infty \beta_i \beta_{i-l}$
> 
> **平稳性条件** ：当且仅当系数平方和与交叉项均收敛时，无限 MA 过程平稳。
> $$ \sum_{i=0}^\infty \beta_i^2 < \infty \qquad \sum_{i=l}^\infty \beta_i \beta_{i-l} < \infty $$  
> 通过 **柯西不等式**，若系数平方和收敛，则系数交叉项均收敛：
> $$ \left| \sum_{i=0}^\infty \beta_i \beta_{i-l} \right| \leq \sqrt{ \sum_{i=0}^\infty \beta_i^2 } \cdot \sqrt{ \sum_{i=0}^\infty \beta_{i-l}^2 } < \infty  $$
> 因此，**仅需系数平方和收敛（即：平方可加）即可保证平稳性**。
> 
> 为方便起见，通常使用比平方可加略强的条件：绝对可加（$\sum_{i=0}^\infty |\beta_i| < \infty$）。关于二者的关系，请参考《Time Series Analysis》(Hamilton, 1994) 英文版第 52 页。如果使用中国人民大学出版社出版的中文版，这部分内容在第 59-60 页。

你可能会疑惑：这里我们的总体思路与课本一致，但为什么结论似乎有所不同。在课本（中文版第 45 页）中，任意 MA 过程平稳的充分必要条件除了平方和收敛外，还有当 $q \to \infty$，若对任意 $l$ 有 $\beta_0 + \beta_1 \beta_{l+1} + \beta_2 \beta_{l+2} + \cdots +\beta_i \beta_{i+l} + \cdots$ 收敛。事实上，我们把 $i$ 视作 $i-l$ 即可。

#### 2.1.2.3 MA(q) 与 AR (p) 的比较

虽然在形式上，AR（自回归）模型和 MA（移动平均）模型看起来很相似，但是他们的关键区别在于他们对过去信息的处理方式。

- 对于自回归（AR）模型：当前值是过去值的函数。也就是说，我们是在使用过去的 "实际" 观察值来预测现在的值。AR 模型的基本思想是过去的观测值会对未来的观测值产生影响，即未来的观测值是过去观测值的加权和。
- 对于移动平均（MA）模型：当前值是过去噪声（或称之为误差或冲击）的函数。这里的“白噪声”实际上是模型无法解释的随机部分，是未能被模型捕获的信息。换句话说，MA 模型是在试图用过去的 "错误" 或 "冲击"（即预测值 $\hat{Y}$ 和真实值 $Y$ 之差，也就是残差 Residuals）来预测现在的值。
- 关于二者的互推问题，请参考 [1.5.2.1 AR(1)的线性特征](#1.5.2.1%20AR(1) 的线性特征) 和 [2.3.5.2 可逆性](#2.3.5.2%20可逆性) 的推导。
## 2.2 自回归移动平均模型（ARMA）

### 2.2.1  Wold 分解定理

**Wold 分解定理**：对于任意平稳序列，可以分解成过去序列值的线性组合和纯随机序列。即对于 $X_t$，存在如下分解：$$
X_t = \sum_{k = 1}^{\infty} a_k X_{t-k} + E_t
$$其中 $E_t$ 相互独立且不可预测。结合相关性假设，如果 $a_k$ 全为 $0$，那么 $X_t$ 就不存在相关性，是纯随机序列，那就不用研究了。

其中 **AR 模型** 是把随机部分简化，保留历史序列部分；那么对偶地，**MA 模型** 是将历史序列值简化，保留随机部分。

### 2.2.2 自回归移动平均模型是什么？
#### 2.2.2.1  ARMA 模型定义

将移动平均过程和线性差分方程合并，便可得到自回归移动平均（ARMA）模型。考察 p 阶差分方程
$$
y_t = a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + x_t
$$
现令 $\{x_t\}$ 表示 MA(q) 过程，则有 ARMA 模型：
$$
y_t = a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + \sum_{i = 0}^{q} \beta_i \varepsilon_{t-i} \tag{*}
$$
为了方便，我们采用标准化，使 $\beta_0$ 恒等于 1。

如果方程的特征根均在单位圆以内，称为 $y_t$ 的 **自回归移动平均(Autoregressive Moving-average，ARMA)模型**。

- ARMA 模型的 **自回归部分** 是齐次部分所给出的差分方程，**移动平均部分** 为序列 $\{x_t\}$。
- 如果差分方程的齐次部分滞后期为 p，并且 $\{x_t\}$ 的滞后期为 q，那么，我们把这个模型称为 **ARMA(p，q)** 模型。
- 若 q = 0，则把这个过程称为纯自回归过程，用 AR(p)表示；
- 若 p = 0，则这个过程被称为纯移动平均过程，用 MA(q)表示。
- 在 ARMA 模型中，完全允许 p 和(或)q 取无穷大。

本章中，我们只考察 **所有特征根都在单位圆内** 的情况。然而，如果有一个或多个特征根大于或等于 1，则称序列 $\{y_t\}$ 为积分（integrated）过程，这时的方程（$*$）称为 **自回归求积移动平均(ARIMA)模型** 。

#### 2.2.2.2 求解 ARMA(p, q)

把 ARMA 看作差分方程，意味着我们能够解出 $y_{t}$，它是用序列 $\{\varepsilon_{t}\}$ 表示的。我们把 ARMA(p, q)模型以序列 $\{\varepsilon_{t}\}$ 表示的解 $y_{t}$ 称为 $y_{t}$ 的 **移动平均表达式**(moving-average representation)，这个求解过程与 [1.4 差分方程的求解方法](#1.4%20差分方程的求解方法) 所讨论的类似。

对于 AR(1)模型 $y_{t}=a_0+a_1y_{t-1}+\varepsilon_{t}$，正如我们在 [1.4.2.1 迭代法](#1.4.2.1%20迭代法) 讨论的，它的移动平均表达式为 MA($∞$)：【请回忆，我们曾在 [2.1.2 移动平均模型（MA）](#2.1.2%20移动平均模型（MA）) 中练习过 MA($∞$) 】
$$
 y_{t}=\frac{a_0}{1-a_1}+\sum_{i = 0}^{\infty} a_i^i\varepsilon_{t-i}
$$
对于一般的 ARMA(p, q)模型，用滞后算子重写 $(*)$，变为  
$$
 \left( 1-\sum_{i = 1}^{p} a_iL^i\right)y_t = a_0+\sum_{i = 0}^{q} \beta_i\varepsilon_{t-i}
$$
所以，$y_{t}$ 的特解为  
$$
 y_{t}=\frac{a_0+\sum_{i = 0}^{q} \beta_{i} \varepsilon _{t-i}}{1-\sum_{i = 1}^{p} a_{i} L^{i}}
$$
幸运的是，我们不必使用待定系数法展开来求得序列 $\{\varepsilon_{t}\}$ 中每个元素的具体系数。但是我们必须认识到：这一展开式会生成 MA($\infty$)过程。

注：如果对本小节涉及的滞后算子计算不熟悉，还请回顾 [1.4.5.3 滞后算子](#1.4.5.3%20滞后算子)；如果对其中涉及的特征多项式、特征方程、特征根有疑问，可以回顾 [1.4.4 高阶齐次解：特征根](#1.4.4%20高阶齐次解：特征根) 。

#### 2.2.2.3 ARMA(p, q) 的平稳性

在上一节的讨论中，我们认识到：ARMA 模型只有在保持 AR (p) 和 MA (q) 都平稳的情况下才会平稳。关于平稳性的内容，还请回顾 [1.2 平稳性](#1.2%20平稳性)、[1.5.2.2 AR(1)的平稳性](#1.5.2.2%20AR(1) 的平稳性)、[1.5.3 AR(2)模型](#1.5.3%20AR(2) 模型) 和 [1.5.4 AR(p)模型](#1.5.4%20AR(p) 模型)。

- 正如我们在 [1.5.4 AR(p)模型](#1.5.4%20AR(p) 模型) 中看到的，AR (p) 平稳的条件是特征多项式 $(1-\sum_{i=1}^{p} a_iL^i)$ 的根在单位圆之外。（或者说，逆特征方程的根在单位圆之外，or 特征根在单位圆内。）
- 我们在 [2.1.2.2 MA(q) 的平稳性](#2.1.2.2%20MA(q)%20 的平稳性) 中也曾讨论过，MA(q) 在 $q$ 为有限值时一定是平稳过程，在 $q \to \infty$（无穷阶 MA）时，若平方可加，也是平稳过程。  

因此，**ARMA 过程的平稳性完全取决于自回归参数，而与移动平均参数无关**。ARMA (p, q) 的平稳性取决于 AR(p) 的平稳性，只要特征根在单位圆内，ARMA 过程就是平稳的。

## 2.3 时间序列模型的使用

### 2.3.1 使用时间序列模型的流程

现在，我们已经对 ARMA 模型有了一定的了解，那么接下来，我们就以比较直观的 GDP 序列来考虑 **如何使用时间序列模型**。比如，我们会问：我现在已经获得了 2000-2020 年的 GDP 数据，我怎么使用 ARMA 模型预测？

表面上看，这个问题好像很具体；但事实上，这个问题包含了很多时间序列分析的细节：在使用模型前我应该如何预处理？我应当选取哪种模型？模型应该使用多少期的滞后？如何估计模型的参数？我怎么知道自己预测的效果好不好呢？

这张时间序列分析流程图给予了我们一些启发。我们可以大致把问题分成下面几部分：
1. 时间序列的 <font color="#c00000"> 预处理 </font>。
2. 选择适当的模型进行识别。这包含两方面：
    - 只有数据的我们不知道模型是否适当，因此需要尝试并比较。
        - 一方面，模型能否使用？有没有分析的价值？——这涉及第 [3](#Chapter%204%20包含趋势的模型) 章的平稳性检验。
        - 另一方面，比较的标准是什么？——这就涉及到后面关于预测效果的问题。
    - 对于每一种尝试的模型，都需要 <font color="#c00000"> 定阶 </font>（也就是选取滞后期数）。比如，AR(p) 的 p 取多少合适？
3. 模型的 <font color="#c00000"> 参数估计方法 </font>。
4. 检验、比较各个模型的 <font color="#c00000"> 预测效果 </font>。这涉及了模型筛选和预测评价。

![时间序列分析流程](https://files.mdnice.com/user/77043/ed5f84a7-1e98-445c-aeff-8c2c8eb83c83.png)

更多内容请参考：[时间序列预处理](https://cloud.tencent.com/developer/article/2490062)

### 2.3.2 时间序列的预处理

流程图表明，在模型识别前，我们应当的输入需要是平稳的非白噪声的序列。这就需要我们进行预处理。本节展示预处理的常见方法。

1. **应对缺失值。** 面对缺失数据，我们应当基于前后数据补全，一种比较常见的方法是线性插值（linear interpolation）。公式是：假设 $i<j$，$t ∈ (t_i,t_j)$ ，则 $y = y_i + \dfrac{t - t_i}{t_j - t_i} \cdot (y_j - y_i)$。插值过程中也可以使用更复杂的方法进行拟合。

2. **处理时序数据噪声**。有时候，我们需要去除短时间内的数据扰动（short-term fluctuations）。一个办法是装箱（Binning），将时间序列按照一定间隔分组（如间隔 𝑘），使用均值代替原始的 𝑘 个值。

3. **时间序列的归一化、标准化**。
    - 这涉及时序数据在尺度（scale）上的变化，以及时序数据的平移（translation）变化。
    - 我们的目标是：对于任意尺度常数 $a$ 和平移常数 $b$，时间序列的线性变换 $ax+b$ 不影响其相似度的计算。
    - <font color="#c00000"> 归一化 </font>（Normalization）： 将时序数据取值限制在 $[0,1]$ 区间内。归一化的公式是：  $$y_t^{\prime} = \dfrac{y_t - y_{\text{min}}}{y_{\text{max}} - y_{\text{min}}}$$
    - <font color="#c00000"> 标准化 </font>（Standardization）：将时序数据的分布变换为均值为 0、标准差为 1 的形式。标准化的公式是： $$z_t = \dfrac{y_t - \mu}{\sigma}$$
    - <font color="#c00000"> 平均归一化 </font>（Mean Normalization）：$y_t^{\prime} = \dfrac{y_t - \mu}{y_{\text{max}} - y_{\text{min}}}$
4. 其他的时间序列预处理方法：
    - **时间序列的分解**：季节项 $S_t$ 刻画时间序列的周期性变换，趋势项 $T_t$ 刻画序列的整体变化趋势；剩余项记为 $R_t$。
        - 相加分解（additive decomposition） $𝑦_𝑡 = 𝑆_𝑡 + 𝑇_𝑡 + 𝑅_𝑡$
        - 相乘分解（multiplicative decomposition）  $𝑦_𝑡 = 𝑆_𝑡 × 𝑇_𝑡 × 𝑅_𝑡$
    - **对数变换**：针对变化程度建模，使高偏度的分布变得不那么偏斜。
    - **Box-Cox 变换**：用于分布“正态”程度的矫正（针对取值非负的序列）。
    - **Tukey Ladder of Powers**：用于将有偏的分布“矫正”，趋向于正态分布（辅助概率化建模）
### 2.3.3 Box-Jenkins 模型筛选：定阶

在完成预处理后，一个重要的步骤是 <b> <font color="#c22b24"> 平稳性检验 </font> </b>。与我们在 [2.2.2.3 ARMA(p, q) 的平稳性](#2.2.2.3%20ARMA(p,%20q)%20 的平稳性) 中的分析一致，若 $a_1$ 的估计值接近 1，则应该怀疑 AR (1) 模型的可靠性；而对于 ARMA(2, q) 模型，特征多项式的根应在单位圆之外。对于非平稳性序列，也有大量文献提出检验方法，因此，序列平稳性检验的讨论将被放在第 [3](#Chapter%204) 章进行。而目前，我们就先假设都使用平稳数据。

在检验数据平稳性之后，下一步要做的就是 **建模** 了。我们接下来介绍一种普及的、用于估计和预测单个时间序列的宏观步骤—— **Box-Jenkins 模型筛选方法**。

Box-Jenkins 方法是美国学者 Box 和英国学者 Jenkins 于 20 世纪 70 年代提出的关于时间序列、预测及控制的一整套方法，也称作传统的时间序列建模方法。它将时间序列建模分为三个阶段：识别阶段 (identifcation stage)、估计阶段 (estimation stage) 和诊断检验阶段 (diagnostic checking)。
+ 在 <font color="#c22b24"> 识别阶段 </font>，研究者实际上是检査时间序列的 <font color="#245bdb"> 散点图 </font>、<font color="#245bdb"> 自相关函数 </font>、<font color="#245bdb"> 偏自相关函数 </font>，从而初步为模型定阶。
+ 在 <font color="#c22b24"> 估计阶段 </font>，需要对每个试验模型进行拟合，并且对多个 $\alpha$ 和 $\beta$ 系数进行检验。选择一个能较好拟合的并且固定简约的模型是这一阶段的目标。
+ 在 <font color="#c22b24"> 诊断检验阶段 </font>，我们要检验确保估计模型的残差能够模拟白噪声过程。

我们首先来看第一阶段，也就是为模型初步 **定阶**。自然地，我们会问：什么是 "定阶"？很容易理解，"定阶" 就是确定阶数。关于模型的阶数，我们在 [1.5.4 AR(p)模型](#1.5.4%20AR(p) 模型) 和 [2.1.2.1 移动平均模型是什么？](#2.1.2.1%20移动平均模型是什么？) 中都有所提及。对于 AR(p) 模型，求解阶 p 的问题叫作 AR 模型的定阶；对于 MA (q) 模型，求解阶 q 的问题就叫作 MA 模型的定阶。

定阶的常用方法有两种：**偏自相关函数（PACF）** 和 **信息准则** 。我们接下来逐一介绍它们。

#### 2.3.3.1 自相关函数（ACF）

在介绍偏自相关函数（PACF）之前，我们先来认识自相关函数（ACF）。

让我们仔细关注一下 "自相关函数" 这个新术语。似乎不用过多解释，看上去好像就有点理解了。但这很可能是我们的错觉：我们自然而然地联想到的是 **自相关系数**，而不是 **自相关函数**。

> [!NOTE]  回顾：关于自相关系数
> 
> 在我们初识数理统计的时候，我们最先接触的是单变量的均值（衡量集中趋势）和方差（衡量离散程度），它们分别是一阶原点矩和二阶中心矩。矩是一种数学计算方式，矩的数学本质是期望，一个变量的 K 阶矩就是这个变量的 K 次方的均值。在此基础之上，可以扩展出原点矩，中心矩，绝对矩等。三阶中心距（偏度）衡量对称程度，四阶中心距（峰度）衡量尾部厚度。
> 
> 当我们在考虑两个变量的关系时，我们常常考虑的是 **协方差**。协方差是两个变量的二阶混合中心矩，测量两个变量之间的同步性，公式为： $\operatorname{cov}(X, Y)=E\left[\left(X-\mu_{x}\right)\left(Y-\mu_{y}\right)\right]=E(X Y)-\mu_{x} \mu_{y}$。可以发现，协方差的大小与两个变量的大小有关。为了无量纲化，我们对其进行标准化处理：由于协方差公式中已经隐含了减去均值的操作，只需要除以两个变量各自的标准差，就得到了 **相关系数**。相关系数具有尺度不变性，能准确度量两个变量之间线性关系的强度。
> 
> 在时间序列分析中，我们关心同一变量在不同时点之间的相关性，我们将不同时点的同一变量视为两个变量，计算出的相关系数就是自相关系数。自相关系数反映了序列内部的依赖关系，假设时间序列为 $\{Y_t\}$，滞后 $l$ 期的自相关系数 $\rho_l$ 定义为：
> $$
> \rho_l = \dfrac{\text{Cov}(Y_t, Y_{t-l})}{\sqrt{\text{Var}(Y_t) \cdot \text{Var}(Y_{t-l})}}
> $$
> 如果时间序列是平稳的（方差不变），公式可简化为：
> $$
> \rho_l = \frac{\text{Cov}(Y_t, Y_{t-l})}{\text{Var}(Y_t)}
> $$
> 由于平稳性检验的方法丰富，教材专门开辟了一个章节（第 [3](#Chapter%204%20包含趋势的模型) 章）来分析。我们简要剧透一下：平稳的时间序列和单位根非平稳时间序列是值得研究的，而其他不平稳时间序列不常见也不值得研究。在这里，我们只讨论平稳的时间序列。

那么，什么是自相关函数呢？自相关函数与自相关系数又是什么关系呢？

**自相关函数（ACF）的定义：**
    自相关函数描述了 <b> <font color="#245bdb"> 时间序列在不同滞后期数（Lag）下的相关性 </font> </b>，即序列与其自身滞后值之间的线性相关程度。它衡量了当前值与过去值之间的关系。

定义表明，自相关函数体现的是自相关系数 $\rho$ 和滞后期数 $l$ 之间的对应关系。就像微观经济学中需求函数对应需求曲线一样，自相关函数对应的是 **自相关图** (correlogram）。若序列平稳，自相关函数（或自相关图）应在几何意义上收敛于 0。很容易理解，序列平稳本身就意味着伴随时间推移趋于收敛，距离时间越久，相关性也相应越低，最后会趋于无影响。

![AR(1)模型 ACF 图](https://files.mdnice.com/user/77043/c14bc3b3-e948-4eba-b352-1abbc2c08b82.png)

为了进一步加深理解，我们接下来考察 AR (1) 过程的自相关函数。

> [!tip] AR (1) 过程的自相关函数 （ACF）
> 
> AR(1) 模型：$y_t = a_0 + a_1 y_{t-1} + \varepsilon_t$
> 
> 当其满足平稳的必要条件 $|a_1|<1$ 时（所以说，自相关系数是在平稳条件下求得的）：
> -  $y_t$ 和 $y_{t-l}$ 的方差是有限常数，$$\gamma_0 = Var(y_t) = a_1^2 Var(y_{t-l}) + \sigma^2 = \dfrac{\sigma^2}{1-a_1^2}$$
> -  $y_t$ 和 $y_{t-l}$ 的协方差记为 $\gamma_l$。我们在 [1.5.2.2 AR(1)的平稳性](#1.5.2.2%20AR(1) 的平稳性) 中曾推导过。如果认为双重求和转化为单重求和太复杂，下面还提供了另一种递推的方法。
> 
> $$\gamma_1 = Cov(y_t,y_{t-1}) = Cov(a_1 y_{t-1} + \varepsilon_t, y_{t-1}) = a_1 Cov(y_{t-1},y_{t-1}) + Cov(\varepsilon_t, y_{t-1})=a_1 \gamma_0$$
> 推导的过程中一定要注意，$Cov(y_{t-1},y_{t-1})=Var(y_{t-1}) = \gamma_0 \neq \sigma^2$ ， $Var(\varepsilon)$ 才等于 $\sigma^2$
> 
> 基于 AR(1) 模型，我们可以递推得到 $y_{t-1} = a_0 + a_1 y_{t-2} + \varepsilon_{t-1}$，得：
> $$\gamma_2 = Cov(y_t,y_{t-2}) = Cov(a_1 y_{t-1}, y_{t-2}) = a_1 Cov(y_{t-1},y_{t-2})= a_1 Cov(a_1 y_{t-2},y_{t-2}) =a_1^2 \gamma_0$$
> 继续递推，得到：
> $$\begin{split}\gamma_l = Cov(y_t, y_{t-l}) & = a_1 Cov(y_{t-1}, y_{t-l})= a_1^2 Cov(y_{t-2}, y_{t-l})= \cdots = a_1^l Cov(y_{t-l}, y_{t-l}) \\
> &= a_1^l \gamma_0 = \dfrac{a_1^l \sigma^2}{1-a_1^2}\end{split}$$  
>  
>  由 $\rho_l = \dfrac{\text{Cov}(Y_t, Y_{t-l})}{\text{Var}(Y_t)}$ ，ACF 有： $\rho_0 = 1, \quad \rho_1 = a_1, \quad \rho_2 = a_1^2, \quad \cdots, \quad \rho_l = a_1^l$
> 
> 由于 $\{\rho_i\}$ 的平稳条件为 $|a_1| <1$ ，所以 $0<a_1<1$ 则自相关系数直接收敛到 0，$-1<a_1<0$ 则自相关系数震荡收敛到 0。

#### 2.3.3.2 偏自相关函数 （PACF）

你可能发现了，在刚刚的推导中，尽管 $y_{t-2}$ 没有直接出现在 AR (1) 模型中，但是 $y_{t-2}$ 也是与 $y_t$ 相关的。根据我们的推导， $y_t$ 和 $y_{t-2}$ 的自相关系数 $\rho_2$ 等于 $y_t$ 和 $y_{t-1}$ 的自相关系数 $\rho_1$ 乘以 $y_{t-1}$ 和 $y_{t-2}$ 的自相关系数（仍为 $\rho_1$），所以 $\rho_2=(\rho_1)^2$。这并不是偶然，事实上，这样的间接相关出现在任何自回归过程的 ACF 中。

**在定阶问题中，这样的间接相关非常重要**。比如，我们考虑一个简单的定阶问题，我们意图在 AR(1) 模型和 AR (2) 模型中选一个来分析我们的时间序列。换言之，我们在纠结的是，要不要在我们的模型中加入 $y_{t-2}$ 这个滞后项。这时， **$y_{t-2}$ 的估计系数可以被视为在 AR(1) 模型上添加 $y_{t-2}$ 对的 $y_t$ 的贡献**，因此是我们做出决策的一个重要参考。

自然地，我们会问： $y_{t-2}$ 的估计系数是 $y_t$ 和 $y_{t-2}$ 的自相关系数 $\rho_2$ 吗？答案是否定的。因为我们没有剔除 $y_{t-1}$ 的影响。就类似于我们在多元线性回归模型中加入控制变量的思想一样，我们想要得到的是 "**在控制 $y_{t-1}$ 保持不变的情况下， $y_t$ 和 $y_{t-2}$ 的自相关系数**"。这就是 <b> <font color="#245bdb"> 偏自相关系数 </font> </b>。对应的，偏自相关系数 $\phi$ 和滞后期 $l$ 的对应关系就是 <b> <font color="#245bdb"> 偏自相关函数 （PACF）</font> </b>。

下面，我们给出偏自相关函数的正式定义：

> [!NOTE] 偏自相关函数（PACF）的定义
> 偏自相关函数（Partial Autocorrelation Function，PACF）用于度量时间序列中当前值 $Y_t$ 与滞后 $k$ 期的值 $Y_{t-k}$ 之间的纯粹相关性，排除了介于两者之间的所有中间滞后项（$Y_{t-1}, Y_{t-2}, \ldots, Y_{t-k+1}$）的干扰。

**偏自相关函数和自相关函数的关系**：
    偏自相关函数和自相关函数的关系就类似于偏导数和全导数的关系。<b> <font color="#245bdb"> 偏自相关函数是在排除了其他变量的影响之后，两个变量之间的自相关函数。</font> </b>

> [!Tip]  <font color="#245bdb"> 类比：</font> 偏导数
> 在数学中，一个多变量的函数的偏导数，就是 **它关于其中一个变量的导数而保持其他变量恒定**（相对于全导数，在其中所有变量都允许变化）。

现在，我们已经认识了偏自相关函数。那么，**请思考：在 AR (1) 过程中，$y_t$ 和 $y_{t-2}$ 间的偏自相关系数是多少？** 答案是：偏自相关系数为 0。怎么得到的？这就涉及了 <b> <font color="#245bdb"> 偏自相关系数的求解 </font> </b>。

求偏自相关系数最直接的方法如下：

1. 首先，对每一观察值减去序列的均值 $\mu$，得到 $y_i^* =y_i-\mu$，形成新的序列 ${y_i^*}$，
2. 接着，构造 1 阶自回归方程 $$y_{i}^{*}=\phi_{11}y_{i-1}^{*}+e_{i}$$ 式中，$e_i$ 为误差项。这里之所以采用符号 ${ e_i }$，是因为误差项 $e_i$ 不一定是白噪声过程（因为 $e_i$ 含有均值 $\mu$）。**因为没有插入值，则 $\phi_{11}$ 就同时为 $y_t$ 和 $y_{t-1}$ 的自相关和偏自相关系数。**

3. 现在构造 2 阶自回归方程：$$
 y_t^* = \phi_{21}y_{t-1}^* + \phi_{22}y_{t-2}^* + e_t
    $$ 式中，$\phi_{22}$ 是 $y_t$ 和 $y_{t-2}$ 的偏自相关系数。换言之，**$\phi_{22}$ 是 $y_t$ 与 $y_{t-2}$ 的剔除 $y_{t-1}$ 干扰影响后的相关系数。**

4. 对其他的所有滞后期 $s$，可重复这个过程，进而生成偏自相关函数(PACF)。实践中，如果样本容量为 $T$，那么仅有 $\dfrac{T}{4}$ 的滞后项可以用来计算样本 PACF。

#### 2.3.3.3 常见模型的 ACF 与 PACF

在前面两节中，我们已经借助 AR (1) 模型认识了自相关函数 ACF 与偏自相关函数 PACF。我们也得到，**AR(1) 模型的 ACF 是 $\rho_0 = 1, \quad \rho_1 = a_1, \quad \rho_2 = a_1^2, \quad \cdots, \quad \rho_l = a_1^l$、PACF 是 0。** 现在，我们来看看其他常用模型的自相关函数 ACF 与偏自相关函数 PACF。

<b><span style="background:#fff88f">【AR(2) 模型的自相关函数】 </span></b>
我们从更复杂的 AR (2) 过程开始。AR (2) 过程的模型是：$$y_t = a_1 y_{t-1} + a_2 y_{t-2} + \varepsilon_t$$ 由于截距项 $a_0$ 对 ACF 没有影响，所以在此省略。

要使 AR (2) 过程平稳，必须限制特征多项式 $1 - a_1 L - a_2 L^2$ 的根在单位圆外。接下来，我们 <b> <font color="#245bdb"> 使用 Yule-Walker 方程来推导自协方差、自相关系数 </font> </b>。
1. 协方差函数 $$\gamma_l = Cov(y_t, y_{t-l})= a_1 Cov(y_{t-1}, y_{t-l}) + a_2 Cov(y_{t-2}, y_{t-l}) + Cov(\varepsilon_t,y_{t-l}) $$
2. 由于 $\varepsilon_t$ 与过去的 $y_{t-1}, y_{t-2}$ 独立，即当 $l>0$， $E(\varepsilon_t y_{t-l}) = 0$。当 $l=0$，有 $$Cov(\varepsilon_t,y_t) = a_1 Cov(\varepsilon_t,y_{t-1}) + a_2 Cov(\varepsilon_t,y_{t-2})+Var(\varepsilon_t) = 0+0+\sigma^2=\sigma^2$$ 因此，$l=0$ 是特殊的，此时 $\gamma_0 = Var (y_t)$ ，包含 $\sigma^2$ 项；其他情况不包含 $\sigma^2$ 项。
3. 我们先考虑 $l=0$ 的特殊情况：代入 $l=0$， $$\gamma_0 = Var (y_t) =a_1 Cov(y_{t-1},y_t)+ a_2 Cov(y_{t-2},y_t)+\sigma^2$$ 由平稳性，无论时间点 $t$ ，间隔为 $l$ 的自协方差均为 $\gamma_l$。因此，上式可以表示成： $$\gamma_0 = a_1 \gamma_1+ a_2 \gamma_2 +\sigma^2$$ 对应地，自相关系数 $\rho_0=\dfrac{\gamma_0}{\gamma_0}=1$
4. 然后我们考虑 $l=1$ 的情况，代入协方差函数： $$\gamma_1 = Cov (y_t, y_{t-1})= a_1 Cov (y_{t-1}, y_{t-1}) + a_2 Cov (y_{t-2}, y_{t-1}) + Cov (\varepsilon_t, y_{t-1}) $$
    - 由于 $\varepsilon_t$ 与过去的 $y_{t-1}, y_{t-2}$ 独立，有 $Cov (\varepsilon_t, y_{t-1}) = 0$；
    - $Cov (y_{t-1}, y_{t-1})=Var (y_{t-1})=\gamma_0$；
    - 由平稳性，无论时间点 $t$ ，间隔为 $l$ 的自协方差均为 $\gamma_l$。因此 $Cov (y_{t-2}, y_{t-1})=\gamma_1$。
    - 因此：<font color="#245bdb"> 自协方差 </font> $\gamma_1=a_1 \gamma_0 +a_2 \gamma_1$ ，解出 $\gamma_1=\dfrac{a_1}{1-a_2}\gamma_0$ 。
    - <font color="#245bdb"> 自相关系数 </font> $\rho_1=\dfrac{\gamma_1}{\gamma_0}=\dfrac{a_1}{1-a_2}$
5. 请自行完成 $l=2$ 情况的推导。我们最终得到，$\rho_2=\dfrac{\gamma_2}{\gamma_0}=\dfrac{a_1^2}{1-a_2}+a_2$
6. **【一般化】**：由平稳性，无论时间点 $t$ ，间隔为 $l$ 的自协方差均为 $\gamma_l$。我们现在考虑一般化的协方差函数：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tx">[**一般化的协方差函数：对应**]<br>| $Cov (y_t, y_&#123;t-l&#125;)$ | $=a_1\cdot$ | $Cov (y_&#123;t-1&#125;, y_&#123;t-l&#125;)$ | $+a_2 \cdot$ | $Cov (y_&#123;t-2&#125;, y_&#123;t-l&#125;)$ | $+ Cov(\varepsilon_t,y_&#123;t-l&#125;)$ |<br>| :------------------: | :---------: | :----------------------: | :----------: | :----------------------: | :----------------------------: |<br>|      $\gamma_l$      | $=a_1\cdot$ |      $\gamma_&#123;l-1&#125;$      | $+a_2 \cdot$ |      $\gamma_&#123;l-2&#125;$      |              $+0$              |<br></code></pre></td></tr></table></figure>
由此，得到自协方差：$\gamma_l=a_1 \gamma_{l-1} +a_2 \gamma_{l-2}$，自相关系数：$\rho_l=\dfrac{\gamma_l}{\gamma_0}=a_1 \rho_{l-1}+a_2 \rho_{l-2}$。

<b><span style="background:#fff88f">【AR (2) 模型的偏自相关函数】 </span></b>
- 对 AR (2) 模型，序列依赖仅存在于 $y_{t-1}$ 和 $y_{t-2}$，当分析 $k > 2$ 的滞后项时，$y_t$ 与 $y_{t-k}$ 的直接相关性被模型结构截断，因此 $\phi_{k, k} = 0$。  
- 而 $k=2$ 时，模型中直接包含 $y_{t-2}$ 的系数 $a_2$，即 $\phi_{2,2} = a_2$。  
- 由 $\rho_1=\dfrac{\gamma_1}{\gamma_0}=\dfrac{a_1}{1-a_2}$，得到 $a_1=\rho_1 (1-a_2)$；代入 $\rho_2=\dfrac{\gamma_2}{\gamma_0}=\dfrac{a_1^2}{1-a_2}+a_2$，得到 $\rho_2 =\rho_1^2-a_2\rho_1^2+a_2$，从而 $\phi_{2,2} = a_2=\dfrac{\rho_2 - \rho_1^2}{1 - \rho_1^2}$。

对应地，AR (2) 自相关函数如左图，偏自相关函数如右图。
![AR(2)的 ACF 和 PACF](https://files.mdnice.com/user/77043/755cfa11-f6e4-4639-9fcf-c624a65063bb.png)

<b><span style="background:#fff88f">【进一步推广：AR (p) 模型】</span></b>

> [!Note] 思考：AR (p)模型的自相关函数 ACF 与偏自相关函数 PACF ？
$$
\begin{split}
y_t &= a_0 + a_1 y_{t-1} + a_2 y_{t-2} + \cdots + a_p y_{t-p} + \varepsilon_t \\
 &= a_0 + \sum_{i = 1}^{p} a_i y_{t-i} + \varepsilon_t \notag
\end{split}
$$

> [!Tip] 【补充】Yule-Walker 方程的定义
> 所以，到底什么是 Yule-Walker 方程？Yule-Walker 方程是 AR 模型的正则方程。
>   
> **定理 （Yule-Walker 方程）** AR(p) 序列的自协方差函数满足 $$\begin{align*}
> \gamma_k &= a_1 \gamma_{k-1} + a_2 \gamma_{k-2} + \cdots + a_p \gamma_{k-p},\quad \ k \geq 1  \\ 
> \gamma_0 &= a_1 \gamma_1 + a_2 \gamma_2 + \cdots + a_p \gamma_p + \sigma^2 \end{align*}$$
> Yule-Walker 方程系统地刻画了 AR (p) 模型中 p 阶范围内 **自相关系数之间的关系**，以及自相关系数与模型结构的关系。

对于 AR(p) 模型，偏自相关系数满足 $\phi_{11} = \rho_1$，$\phi_{22} = \dfrac{\rho_2 - \rho_1^2}{1 - \rho_1^2}$，向后递推：
$$
\phi_{ss} = \frac{\rho_{s} - \sum_{j = 1}^{s-1} \phi_{s-1, j}\rho_{s-j}}{1 - \sum_{j = 1}^{s-1} \phi_{s-1, j}\rho_{j}} \quad s = 3,4,5,\cdots
$$
式中，$\phi_{sj} = \phi_{s-1,j} - \phi_{ss}\phi_{s-1,s-j}, j = 1, 2, 3, \cdots, s-1$。

对于 AR (p) 过程，当 s > p 时，$y_t$ 和 $y_{t-s}$ 之间不存在直接相关。因此，**当 s > p 时，所有 $\phi_{ss}$ 都等于 0**。这表明：<b> <font color="#245bdb"> 对于 AR (p) 过程，它的 PACF 在滞后期大于 p 时，均应该截尾为 0 </font> </b> 。这是 PACF 一个重要的特征，它可用于辅助识别 AR (p) 模型。
**<center> <b> AR(p)模型偏自相关函数是 p 步截尾的。我们可以以此来确定 AR(p)模型的阶数 p。</b> </center>

<b><span style="background:#fff88f">【MA 模型】 </span></b>
1. **MA(1)模型的 ACF：**
    - 依旧省略常数项，MA (1)模型为：$y_{t} = \varepsilon_{t} + \beta \varepsilon_{t-1}$ 
    - 由于 $y_{t}$ 是由白噪声序列中的项组成，所以不需平稳条件就可求得 $\rho$ 的形式如下：
        - $\rho_{0} = 1$
        - $\rho_{1} = \beta / (1 + \beta^{2})$ 
        - $\rho_{s} = 0, (s > 1)$
    - 因此，MA(1) 的 ACF 是 1 步截尾。

> [!Note] 思考：如何推导？
> $\gamma_0=Cov(y_t,y_t)=Var(\varepsilon_{t} + \beta \varepsilon_{t-1})=(1+\beta^2)\cdot \sigma^2$ $\quad \Rightarrow \quad \rho_0=\dfrac{\gamma_0}{\gamma_0}=1$
> 
> $\gamma_1=Cov(y_t,y_{t-1})=Cov(\varepsilon_{t} + \beta \varepsilon_{t-1},\varepsilon_{t-1} + \beta \varepsilon_{t-2})= 0+\beta \sigma^2+0+0=\beta \sigma^2$ 
> 
> $\quad \Rightarrow \quad \rho_1=\dfrac{\gamma_1}{\gamma_0}=\dfrac{\beta \sigma^2}{(1+\beta^2)\cdot \sigma^2}=\dfrac{\beta }{1 + \beta^{2}}$
> 
> 当 s > 1， $\gamma_s=Cov(y_t,y_{t-s})=Cov(\varepsilon_{t} + \beta \varepsilon_{t-1},\varepsilon_{t-s} + \beta \varepsilon_{t-1-s})= 0+0+0+0=0$ 

2. **MA(2)模型的 ACF：**
    请回顾 [2.1.2.2 MA(q) 的平稳性](#2.1.2.2%20MA(q)%20 的平稳性) 对 MA(2) 自协方差的推导，讨论在不同滞后期下的 $\rho$ 分布。我们可以发现，MA (2) 的 ACF 是 2 步截尾。

3. **MA(q)模型的 ACF：**
     MA (q) 模型为： $$x_t = \beta_0 \varepsilon_t + \beta_1 \varepsilon_{t-1} + \cdots +\beta_q \varepsilon_{t-q} = \sum_{i = 0}^{q} \beta_i \varepsilon_{t-i} \notag$$ 同样地，我们也可以讨论在不同滞后期下的 $\rho$ 分布。我们可以从 MA(1) 和 MA(2) 过程外推得到：对于 MA (q) 模型， $\rho_{q+1}$ 开始之后都为 0。即：<b> <font color="#245bdb"> q 阶之后突然截断变为 0 </font> </b>。

4. **MA (q) 模型的 PACF：**
    使用滞后算子，结合级数展开，只要 $\beta \neq -1$，MA(1)模型可以写为：$$y_t= (1 + \beta L) \varepsilon_t$$ 可以把 $\varepsilon_t$ 表述为无限阶自回归表达式 $y_t - \beta y_{t-1} + \beta^2 y_{t-2} - \beta^3 y_{t-3} + \cdots = \varepsilon_t$。
    - 由于 $y_t$ 同自身的所有滞后项相关，所以， **MA (q) 模型的 PACF 不会截尾到 0**。
    - 相反，**PACF 系数表现出衰减形式（即具有拖尾特征）**。若 $\beta < 0$，PACF 的系数直接衰减；若 $\beta > 0$，PACF 的系数振荡衰减。

<b><span style="background:#fff88f">【ARMA 模型的 ACF 推导】 </span></b>
在得到 AR(p) 、MA(q) 模型的 ACF、PACF 后，我们现在来讨论 ARMA(p, q) 的 ACF 和 PACF。我们还是从特例 ARMA(1,1) 过程开始。ARMA(1,1) 模型为：  
$$y_t = a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}, \quad \varepsilon_t \sim WN(0, \sigma^2)$$
1. 无需计算 $\gamma_0$，就有自相关系数 $\rho_0=\dfrac{\gamma_0}{\gamma_0}=1$。我们还可以推导 $\gamma_0$ 和 $\gamma_1$ 关系： $$\begin{split}
\gamma_0 &= Var(y_t) = Cov(y_t, a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}) \\
&= a_1 Cov(y_t, y_{t-1})+Cov(y_t,\varepsilon_t)+\beta_1 Cov(y_t,\varepsilon_{t-1}) \\
&= a_1 \gamma_1 +Cov(a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1},\varepsilon_t)+\beta_1 Cov(a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1},\varepsilon_{t-1}) \\
&= a_1 \gamma_1 +(0+ \sigma^2 +0)+\beta_1 [a_1 Cov(a_1 y_{t-2} + \varepsilon_{t-1} + \beta_1 \varepsilon_{t-2},\varepsilon_{t-1})+0+\beta_1\sigma^2] \\
&= a_1 \gamma_1 +\sigma^2+ a_1\beta_1\cdot(0+\sigma^2+0)+\beta_1^2\sigma^2 \\
&= a_1 \gamma_1 +(1+a_1\beta_1+\beta_1^2)\sigma^2
\end{split}$$ 如果想求得 $\gamma_0$，可以把下面 $\gamma_1$ 代入，解出 $\gamma_0 =\dfrac{1+2a_1\beta_1+\beta_1^2}{1-a_1^2}\sigma^2$。
2. 计算 $\gamma_1$：$$\begin{align*}
\gamma_1 &= Cov(y_t, y_{t-1}) = Cov(a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}, y_{t-1})\\
&= a_1 Var(y_{t-1}) + Cov(\varepsilon_t, y_{t-1})+ \beta_1 Cov(\varepsilon_{t-1}, y_{t-1}) \\
&= a_1 \gamma_0 + 0+ \beta_1 Cov(a_1 y_{t-2} + \varepsilon_{t-1} + \beta_1 \varepsilon_{t-2},\varepsilon_{t-1}) \\
&= a_1 \gamma_0 + \beta_1 \sigma^2
\end{align*}$$ 这时，$\rho_1 =\dfrac{\gamma_1}{\gamma_0}= a_1+\dfrac{\beta_1 \sigma^2}{\gamma_0}$。
3. 计算 $\gamma_2$：$$\begin{align*}
\gamma_2 &= Cov(y_t, y_{t-2}) = Cov(a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}, y_{t-2})\\
&= a_1 Cov(y_{t-1}, y_{t-2}) + Cov(\varepsilon_t, y_{t-2})+ \beta_1 Cov(\varepsilon_{t-1}, y_{t-2}) \\
&= a_1 \gamma_1 \end{align*}$$  这时，$\rho_2 =\dfrac{\gamma_2}{\gamma_0}= a_1 \rho_1$。
4. 考虑 $\gamma_k$ （$k>1$）的情况：$$\begin{align*}
    \gamma_k &= Cov(y_t, y_{t-k}) = Cov(a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}, y_{t-k})\\
    &= a_1 Cov(y_{t-1}, y_{t-k}) + Cov(\varepsilon_t, y_{t-k})+ \beta_1 Cov(\varepsilon_{t-1}, y_{t-k}) \\
    &= a_1 \gamma_{k-1} \end{align*}$$ 这时，$\rho_k =\dfrac{\gamma_k}{\gamma_0}= a_1 \rho_{k-1}$，呈现指数衰减（拖尾）。
    这个式子也表明 $k=0$ 和 $k=1$ 的特殊性：
    - 当 $k=0$，$Cov (\varepsilon_t, y_{t-k})$ 和 $Cov (\varepsilon_{t-1}, y_{t-k})$ 均不为 0；
    - 当 $k=1$，$Cov (\varepsilon_t, y_{t-k})$ 为 0，但 $Cov (\varepsilon_{t-1}, y_{t-k})$ 不为 0；
    - 只有在 $k>1$ 时，二者均为 0。

> [!Excercise] 练习：请推导 ARMA(2,1) 、ARMA (1,2)的 ACF，并推广至 ARMA(p, q) 的情形。
> ARMA(2,1) 的 ACF 满足：  
> - **计算 $\gamma_0$**：$\gamma_0 = a_1 \gamma_1 + a_2 \gamma_2 + \sigma^2 (1+a_1\beta_1 + \beta_1^2)$，$\rho_0=1$
> - **计算 $\gamma_1$**：$\gamma_1 = a_1 \gamma_0 + a_2 \gamma_1 + \beta_1 \sigma^2$，$\rho_1 = \dfrac{\gamma_1}{\gamma_0}=\dfrac{a_1}{1 - a_2}\rho_0+\dfrac{\beta_1 \sigma^2}{(1 - a_2)\gamma_0}$
> - **计算 $\gamma_2$**：$\gamma_2 = a_1 \gamma_1 + a_2 \gamma_0$，$\rho_2 =\dfrac{\gamma_2}{\gamma_0}= a_1 \rho_1 + a_2$  
> - <span style="background:#fff88f">**高阶递推**：当 $k>1$ 时，$\rho_k = a_1 \rho_{k-1} + a_2 \rho_{k-2}$</span>
> 
> ARMA (1,2) 的 ACF 满足：
> - **计算 $\gamma_0$**： $\gamma_0 = a_1 \gamma_1 + \sigma^2(1 + \beta_1^2 + \beta_2^2 + 2a_1\beta_1 + 2a_1\beta_2)$，$\rho_0 = 1$。  
> - **计算 $\gamma_1$**：    $\gamma_1 = a_1 \gamma_0 + \sigma^2(\beta_1 + \beta_2a_1)$， $\rho_1 = \dfrac{\gamma_1}{\gamma_0} = a_1 + \dfrac{\sigma^2(\beta_1 + \beta_2 a_1)}{\gamma_0}$。  
> - **计算 $\gamma_2$**：  $\gamma_2 = a_1 \gamma_1 + \sigma^2\beta_2$，  $\rho_2 = \dfrac{\gamma_2}{\gamma_0} = a_1 \rho_1 + \dfrac{\sigma^2\beta_2}{\gamma_0}$。 
> - **计算 $\gamma_3$**：   $\gamma_3 = a_1 \gamma_2$，  $\rho_3 = \dfrac{\gamma_3}{\gamma_0} = a_1 \rho_2$。  
> - <span style="background:#fff88f">**高阶递推**：   当 $k>2$ 时，$\rho_k = a_1 \rho_{k-1}$。</span>
> 
> <b> <font color="#245bdb"> 对比于 ARMA (1,1)，有什么发现？推广到 ARMA (p, q) 的 ACF 呢？</font> </b>
> 1. ARMA(p, q) 中，p 增加，递推公式的项数增加；q 增加则不符合递推的项数增加。
> 2. 递推从 q+1 项开始，递推的公式是 $\rho_k=a_1 \rho_{k-1}+a_2 \rho_{k-2}+\cdots+a_p \rho_{k-p}$（递推公式的项数为当期向前推 p 项）。
> 3. 因此，<span style="background:#fff88f">ARMA(p, q) 的高阶递推可以表示为：当 $k>q$ 时，$\rho_k =\sum_{i=1}^p a_i \rho_{k-i}$。</span>
> 4. 由于我们考虑的是平稳的时间序列，特征根在单位圆内。因此自相关系数在递推中不断衰减，<b> <font color="#c00000"> 呈现拖尾特征 </font> </b>。

 <span style="background:#fff88f"><b>【ARMA (p, q) 模型的 PACF 推导】</b></span> 
偏自相关系数（PACF）的本质是条件协方差，无截尾性，呈拖尾特征。我们还是从 ARMA (1, 1)情况开始分析。ARMA (1,1) 模型为：
$$y_t = a_1 y_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}, \quad \varepsilon_t \sim WN(0, \sigma^2)$$
当 $k = 1$ 时，在前面 ACF 的推导中，我们已经得到：$\gamma_1=a_1 \gamma_0 + \beta_1 \sigma^2$。$$\phi_{11}=\dfrac{\gamma_1}{\gamma_0}=\dfrac{a_1 \gamma_0+\beta_1 \sigma^2}{\gamma_0}=a_1+\dfrac{\beta_1\sigma^2}{\gamma_0}$$ 事实上，我们发现，ARMA (1,1) 模型的 **PACF 等于 ACF**，即 $\phi_{11} = \rho_1$ 。  

接着，我们考虑 $k = 2$ 的情况。在前面 ACF 的推导中，我们已经得到：$\gamma_2=a_1 \gamma_1$。我们可以进一步结合 $\gamma_1=a_1 \gamma_0 + \beta_1 \sigma^2$，得到：$\gamma_2=a_1^2 \gamma_0 + a_1 \beta_1 \sigma^2$。此外，还有 $\gamma_0=\frac{1+2a_1\beta_1+\beta_1^2}{1-a_1^2}\sigma^2$ 。根据偏自相关函数与自协方差函数的关系，有：$$\gamma_2=Cov(y_t,y_{t-2})=Cov(\phi_{21}y_{t-1}+\phi_{22}y_{t-2}+\varepsilon_t,y_{t-2})=\phi_{21}\gamma_1+\phi_{22}\gamma_0$$ 结合 $k=1$ 的情况： 
$$
\begin{cases}\gamma_1 =\phi_{11}\gamma_0\\\gamma_2 =\phi_{21}\gamma_1+\phi_{22}\gamma_0\end{cases} \quad \Rightarrow \quad \gamma_2 =(\phi_{21}\phi_{11}+\phi_{22}) \gamma_0
$$

我们希望得到的目标是 $\phi_{22}$，上面已经求解过了 $\phi_{11}$，我们现在就考虑消去 $\phi_{21}$。但是我们看到 $\phi_{21}$ 和 $\phi_{22}$ 两个参数只有一个方程，因此需要再找到一个方程以求解。我们考虑： 

$$
\gamma_1 = Cov(y_t, y_{t-1})= Cov(\phi_{21}y_{t-1}+\phi_{22}y_{t-2}+\varepsilon_t, y_{t-1})=\phi_{21}\gamma_0+\phi_{22}\gamma_1
$$

因此，我们得到：$\phi_{21} = \dfrac{\gamma_1 (1 - \phi_{22})}{\gamma_0}=\dfrac{\gamma_1}{\gamma_0}-\dfrac{\gamma_1}{\gamma_0}\phi_{22}=\rho_{1}-\rho_{1}\phi_{22}$，从而：

$$
\dfrac{\gamma_2}{\gamma_0}=\rho_2 =\phi_{21}\phi_{11}+\phi_{22}=(\rho_1 - \rho_1 \phi_{22})\phi_{11}+\phi_{22}=\phi_{11}\rho_1+(1-\phi_{11}\rho_1)\phi_{22}
$$

因此得到 $\phi_{22}=\dfrac{\rho_2-\phi_{11}\rho_1}{1-\phi_{11}\rho_1}$。又有 $\phi_{11}=\rho_1$，得到 $\phi_{22}=\dfrac{\rho_2-\rho_1^2}{1-\rho_1^2}$。

ARMA (1,1) 模型 PACF 的推导可以借助 **Levinson 递推公式**：
$$
\begin{cases} \phi_{11} = \rho_1, \\ \\ \phi_{ss} = \dfrac{\rho_s - \sum_{j = 1}^{s-1} \phi_{s-1, j} \ \rho_{s-j}}{1 - \sum_{j = 1}^{s-1} \phi_{s-1, j} \ \rho_j}, \quad s \geq 2, \\ \\ \phi_{sj} = \phi_{s-1, j} - \phi_{ss} \phi_{s-1, s-j}, \quad j = 1,2,\dots, s-1.\end{cases}
$$

对 $s \geq 2$，可以将已求得的 ACF($\rho_k$) 代入递推公式计算。
因 ARMA (p, q) 包含 MA 部分，PACF 不满足截尾，而是随阶数增加逐渐衰减（拖尾），具体数值需逐阶递推。

![ACF 和 PACF 对比](https://files.mdnice.com/user/77043/34c14748-2964-4e07-a770-c1d376a28aab.png)

可以看出，使用 PACF 为 ARMA(p, q) 模型定阶是非常困难的。有什么好办法吗？
【补充】ARMA(p, q)模型阶数方法 1：<b> <font color="#c22b24"> EACF 函数 </font> </b>。
- **使用方法**：将 ACF 汇总于表格中。用“o”表示零，“x”表示非零。“o”形成的三角形的左上角的点对应的 p 和 q 就是模型应对的 p 和 q。
- **例子**：左上角的“o”点坐标为（1，1），故为 ARMA(1,1)。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tx">[表: ARMA(1,1)模型EACF理论表]<br>| AR \ MA | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | <br>|---------|---|---|---|---|---|---|---|---| <br>| 0 | x | x | x | x | x | x | x | x | <br>| 1 | x | o | o | o | o | o | o | o | <br>| 2 | x | x | o | o | o | o | o | o | <br>| 3 | x | x | x | o | o | o | o | o | <br>| 4 | x | x | x | x | o | o | o | o | <br>| 5 | x | x | x | x | x | o | o | o |<br></code></pre></td></tr></table></figure>

EACF 函数方法是 ARMA 模型基于 ACF 、PACF 的定阶方法。另一种方法是使用信息准则，设定 $P_{max}$ 和 $Q_{max}$ 后逐个回归，通过信息准则筛选最小信息准则的阶数。下面我们就来介绍两种主流的信息准则。

#### 2.3.3.4 信息准则

对估计出的模型，人们自然会问：模型对数据的拟合程度如何? 增加额外的滞后期必然会使估计残差的平方和减小。然而，**增加这些滞后项必然要求估计额外的系数，相应地减少了自由度。** 甚至，**包含了无关紧要的系数还会降低拟合模型的预测效果。**

当今的多种模型筛选准则都倾向于以放弃减少残差平方和为代价，而选择一个更加简练的模型。最常使用的模型筛选准则是 **赤池信息准则** (Akaike Information Criterion，<font color="#c00000"> AIC </font>) 和施瓦茨准则 (Schwartz Bayesian Criterion，<font color="#c00000"> SBC </font>，也常被称为 BIC)。在课本中计算式为：
$$
\begin{split} AIC &= T \ln S+2 n \\
\\
SBC &= T \ln S+n \ln (T) \end{split}
$$
- 其中 $n$ 为待估参数个数（p+q+或有的常数项）；$T$ 为可用观测值个数；S 为残差平方和。
- 或者，更经常地，我们把它们表示为标准化的：
$$
\begin{split} 
AIC^* &=\frac{AIC}{T}= –2 \frac{\ln (L)}{T} + 2 \frac{n}{T}  \\
\\
SBC^* &=\frac{SBC}{T}= –2 \frac{\ln (L)}{T} + \frac{n \ln (T)}{T} \end{split}
$$

其中， n 和 T 如上所述定义，L 是似然函数。
- 在教材中给出的 $T\ln S$ 和常用的 $-2\ln(L)$ 是近似的，对于模型比选没有差异。这涉及了对数似然函数的最大值，我们将在 [2.3.4 参数的估计策略](#2.3.4%20Box-Jenkins%20模型筛选：估计) 更详细地讨论极大似然估计，并证明两种表示方法为什么对于模型比选没有差异。

> [!tip] 惩罚
> 在统计学和机器学习中，**惩罚** 是一种通过引入额外项来约束模型复杂度的策略。
> - 信息准则是通过对拟合优度的要求加上对参数个数的惩罚指定一个准则来定阶的。
> - 惩罚项的作用是：当模型参数过多时，虽然似然函数 L 可能增大（拟合更好），但惩罚项 2n 会显著增加，导致 AIC 整体上升。<font color="#c22b24"> 这迫使模型在 “过度拟合数据” 和 “保持简洁性” 之间寻找最优解 </font>。

**注意：**
1. **当用滞后变量估计模型时，会损失部分观测值。为了充分比较备选模型，T 应保持不变，否则，我们将依据不同的样本期来比较模型的效果。**  T 的减少会直接降低 AIC 和 SBC 的效果，而我们的目的显然不是选择一个可用观测值最少的模型。例如，有 100 个数据点时，只用后 98 个观测值分别估计 AR (1) 和 AR (2) 模型，再用 T = 98 比较两个模型的效果。
2. **理论上，AIC 和 SBC 要尽可能地小 (注意，二者皆可为负)。当模型的拟合优度上升时，AIC 和 SBC 的值会趋于负无穷。** 我们可以用这些准则来辅助选出最合适的模型。若模型 A 的 AIC (或 SBC) 小于模型 B，则称模型 A 优于模型 B。在运用准则比较各种备选模型时，我们必须基于相同的样本期来估计，这样二者才可以比较。
3. 对于每个模型，解释变量的增加会导致 n 的增加，但残差平方和 (SSR) 会减少。因此，**若某个解释变量对模型没有解释力，则在模型中引入它只会导致 AIC、SBC 同时变大**。

> [!Note] SBC 与 AIC 的比较：
> 
> 1.  **<font color="#c00000"> SBC 总是比 AIC 选择出的模型更简练 </font>** 。这时因为， $\ln(T)$ 大于 2，所以，SBC 增加解释变量的边际成本总是比 AIC 大。
> 
> 2. <font color="#245bdb"> **<font color="#c00000"> </font> SBC 具有更优的大样本特性。</font> </font>** 假定数据生成过程的真实阶数为 $(p^*，q^*)$，并且假设用 AIC 和 SBC 估计所有阶数为 $(p, q)$ 的 ARMA 模型，其中 $p≥p^*$，$q>q^*$。当样本容量趋于无限时，AIC 和 SBC 选出的模型的阶数都会大于等于 $(p^*，q^*)$。但是，SBC 趋向于一致，而 **<font color="#245bdb"> AIC 则倾向于选择参数过多的模型 </font>** 。**<font color="#245bdb"> 在小样本下，AIC 选择模型的效果要优于 SBC </font>**。

- 如果 AIC 和 SBC 都选择了相同的模型，那么，我们有理由相信这个模型是个恰当的模型。
- 但是，若 AIC 和 SBC 筛选出的模型不同，那么，为了谨慎起见，我们仍然要继续研究。
    - 因为 SBC 选出的模型更加简练，所以，应该检验 **残差是否表现为白噪声过程**（以证明模型确实对数据有解释力度）。
    - 因为 AIC 选择的模型含有过多的参数，那么，所有系数的 $t$ 统计量应该显著（以证明这些参数的加入是必要的）。


### 2.3.4 Box-Jenkins 模型筛选：估计

在大多数情况下，我们通过回归方法分析时间序列。回归对样本有独立性假设，时间序列分析
利用数据相关性（惯性） 分析预测，二者在某些方面有一定的相似。因此，我们有时候 **使用最小二乘方法来估计时间序列的参数**。比如我们之前 [1.5 自回归（AR）模型](#1.5%20自回归（AR）模型) 学到的自回归 AR 模型，以及 [2.1.2 移动平均模型（MA）](#2.1.2%20移动平均模型（MA）) 学习的移动平均 MA 模型。在 [2.3.3.2 偏自相关函数 （PACF）](#2.3.3.2%20偏自相关函数%20（PACF）) 讨论定阶时，我们对于 "是否加入 $y_{t-2}$ 滞后项" 的讨论就是基于多元线性回归框架的，因此使用的是最小二乘估计。

当然，在最小二乘估计之外，还有很多其他估计方法。比如矩估计 (MME)，极大似然估计 (MLE)，条件最小二乘 (CLS)等。在 [2.3.3.1 自相关函数（ACF）](#2.3.3.1%20自相关函数（ACF）) 中我们用到的 Yule-Walker 估计一种对参数的矩估计。最小二乘估计与 Yule-Walker 估计渐近相同，在样本量较小时，Yule-Walker 方法在估计系数方面表现较好，最小二乘估计方法在预测方差方面表现较好。样本量大时二者没有明显差别。相较于其他估计方法，矩估计更容易计算，但这也使得矩估计存在精度不高的可能性。而最大似然估计一般精度较高。相较于 OLS 估计，我们对似然估计相对陌生。因此，本节以 AR (p) 模型为例，重点介绍似然函数（MLE）的计算。

 1. 我们假设似然函数是联合正态分布密度函数，给定 AR(p)模型： 
$$
r_t = \phi_0 + \phi_1r_{t - 1} + \cdots + \phi_pr_{t - p} + a_t, \quad t = p + 1,\cdots, T
$$
将联合似然函数表示为条件似然的乘积，似然函数为 
$$
\begin{align *} L &= f(r_1, r_2,\cdots, r_T)\\ &= f(r_1)f(r_2|r_1)f(r_3|r_1, r_2)\cdots f(r_T|r_1,\cdots, r_{T - 1}) \end{align*} 
$$

 2. 当 $t \geq 2$ 时，则可以计算 $r_t$ 的条件分布。由于 

$$
r_2|r_1 = \phi_0 + \phi_1r_1 + a_2 \sim N(\mu_2,\sigma_a^2)
$$

其中：$\mu_2 = \phi_0 + \phi_1r_1$。因此正态分布的概率密度函数为：

$$
f(r_2|r_1) = \frac{1}{\sqrt{2\pi}\sigma_a}\exp\left\{ - \frac{(r_2 - \mu_2)^2}{2\sigma_a^2} \right\}
$$

同理 

$$
r_3|r_1, r_2 = \phi_0 + \phi_1r_2 + \phi_2r_1 + a_3 \sim N(\mu_3,\sigma_a^2)
$$

其中：$\mu_3 = \phi_0 + \phi_1r_2 + \phi_2r_1$。因此 

$$
f(r_3|r_1, r_2) = \frac{1}{\sqrt{2\pi}\sigma_a}\exp\left\{ - \frac{(r_3 - \mu_3)^2}{2\sigma_a^2} \right\}
$$

依此类推。因此， 
$$
L = f(r_1) \frac{1}{(2\pi)^{\frac{T - 1}{2}}\sigma_a^{T - 1}}\exp\left\{ - \frac{1}{2\sigma_a^2} \sum_{t = 2}^T(r_t - \mu_t)^2 \right\}
$$

注：同底数幂相乘，底数不变指数相加因而出现求和；以及不要遗漏 $f(r_1)$。
 3. 取对数，得到对数似然函数： 
$$
\ln{L} = \ln f(r_1) - \frac{T - 1}{2} \left [\ln(2\pi)+2\ln\sigma_a\right] - \frac{1}{2\sigma_a^2} \sum_{t = 2}^T(r_t - \mu_t)^2
$$
得到似然函数后就可以通过最大化对数似然函数估计模型参数。

> [!NOTE] （填坑）不同 AIC、SBC 表示的比较
> 现在，我们可以返回来考虑 [2.3.3.4 信息准则](#2.3.3.4%20信息准则) 中那个比较了。这也可以作为极大似然估计的一个练习。
> 
> 对于时间序列 $\{r_t\}$，有极大似然估计 $$\ln{L} = \ln f(r_1) - \dfrac{T - 1}{2} \left[\ln(2\pi)+2\ln\sigma\right] - \dfrac{1}{2\sigma^2} \sum_{t = 2}^T(r_t - \mu_t)^2$$ 我们需要最大化似然函数 $\ln L$ 。但为了计算方便，我们不立刻这样处理，而是先根据正态分布的性质化简一下。
>  
> 对于正态分布，概率密度函数（PDF）为 $$f (x)=\dfrac{1}{\sqrt{2\pi\sigma^{2}}}\exp\left (-\dfrac{(x - \mu)^{2}}{2\sigma^{2}}\right)$$ 那么， $$\ln(f(x))=\ln(\dfrac{1}{\sqrt{2\pi\sigma^{2}}})+(-\dfrac{(x - \mu)^{2}}{2\sigma^{2}})=-\frac{1}{2}\ln(2\pi\sigma^2)-\dfrac{(x - \mu)^{2}}{2\sigma^{2}}$$ 代入得：$$ \begin{split} –2 \ln (L) &= -2\ln(f(r_1)) +(T - 1)\left[\ln(2\pi)+2\ln\sigma\right] + \dfrac{1}{\sigma^2} \sum_{t = 2}^T(r_t - \mu_t)^2 \\ &=\ln(2\pi\sigma^2)+\dfrac{(r_1 - \mu)^{2}}{\sigma^2} +(T-1)\ln(2\pi\sigma^2)+\dfrac{1}{\sigma^2} \sum_{t = 2}^T(r_t - \mu_t)^2 \\ &= T\ln (2πσ^2) + \dfrac{(r_1 - \mu)^{2}}{\sigma^2}+\dfrac{1}{\sigma^2} \sum_{t = 2}^T(r_t - \mu_t)^2 \\&= T\ln (2π) +T\ln(σ^2)+\dfrac{1}{\sigma^2} \sum_{t = 1}^T(r_t - \mu_t)^2 \end{split}$$ 其中 $\sum_{t = 1}^T(r_t - \mu_t)^2$ 是残差平方和，为简便我们可以把它记为 S。
> 
> 现在，我们可以最大化似然函数 $\ln L$ 了。这与我们在最小二乘估计时的方法类似，我们可以对 $σ^2$ 求导并令导数为零。我们可以得到：$$\frac{\partial}{\partial \sigma^2} \left[ T \ln(2\pi) +T\ln(\sigma^2)+ \dfrac{S}{\sigma^2} \right] = \frac{T}{\sigma^2} - \dfrac{S}{\sigma^4} = 0$$ 进而得到一个美妙的关系式： $\sigma^2 = \dfrac{S}{T}$  。因此，我们就可以把原式 $\sigma^2$ 替换，得到 $$ \begin{split} –2 \ln (L) &=  T\ln (2π) + T\ln(σ^2)+\dfrac{1}{\sigma^2} \sum_{t = 1}^T(r_t - \mu_t)^2 \\&=T\ln(2\pi)+T\ln(\dfrac{S}{T})+\dfrac{T}{S}\cdot S\\&=T\ln(2\pi)+T\ln(S)-T\ln(T)+T \end{split}$$
> 
> 由于 $T$ 为可用观测值个数，$T\ln(2\pi)-T\ln(T)+T$ 本质上是常数项。这表明二者在本质上是一致的。由于模型筛选的本质是 **相对比较**，比较时常数项会相互抵消，最终决策仅依赖核心项（残差平方和 S 、参数数量 n）。因此，是否保留常数项不影响使用。  

在极大似然估计之外，我们再介绍一下 **条件最小二乘估计**（CLS）。条件最小二乘在估计时考虑了模型的条件结构，即在给定过去值的情况下，当前值的预测误差最小化。下面我们介绍其做法：
- 从第 $p + 1$ 个观测值开始估计。给定前 $p$ 个观测值，对于 $t = p + 1,\cdots,T$，我们有： $$r_t = \phi_0 + \phi_1r_{t - 1} + \cdots + \phi_pr_{t - p} + a_t$$ 设估计结果为：$\hat{r}_t = \hat{\phi}_0 + \hat{\phi}_1r_{t - 1} + \cdots + \hat{\phi}_pr_{t - p}$ 
- 残差序列 $\{\hat{a}_t\}$ 为：$\hat{a}_t = r_t - \hat{r}_t$ 
- $\sigma_a$ 的估计值： $$\hat{\sigma}_a^2 = \frac{\sum_{t = p + 1}^T\hat{a}_t^2}{T - 2p - 1}$$
- 自然地，我们会疑惑：“条件”在哪里了？事实上，我们只是考察了 p+1 时刻之后的噪声项，这就是“条件”。

### 2.3.5 Box-Jenkins 模型筛选：评价

完成 Box-Jenkins 模型筛选方法的识别、估计阶段之后，我们进入 <font color="#c22b24"> 诊断检验阶段 </font>。也就是说，我们要对初步确定的模型进行评价和比较。估计恰当的模型应满足以下条件：
1. 简练；
2. 其系数表现为平稳且可逆；
3. 拟合数据较好；
4. 残差接近白噪声过程；
5. 系数不随样本期改变而改变；
6. 有较好的样本区间外预测。
这些内容分布在课本 2.7-2.13 节，出于知识衔接的考虑，我们先介绍白噪声检验（对应于第 4 条原则），然后介绍可逆性（第 2 条）和简练原则（第 1 条），最后讨论样本区间外预测（第 6 条）、系数不随样本期改变而改变（第 5 条）以及更优拟合效果（第 3 条）的内容。
#### 2.3.5.1 白噪声检验

在诊断检验阶段，确定模型恰当的一个非常重要的条件是：**确保估计模型的残差能够模拟白噪声过程**。此外，我们也曾在 [2.3.3.4](#2.3.3.4%20信息准则) 节最后指出：使用施瓦茨信息准则（SBC）应该检验残差是否表现为无分析价值的白噪声过程。那么，如何进行这一检验呢？

Box-Jenkins (1976) 用样本自相关系数构造了 **Q 统计量**，计算公式为 Box-Pierce 形式：     $$Q_{BP} = T \sum_{k=1}^s r_k^2$$ 在所有的 r 值等于 0 的原假设下，Q 近似地服从自由度为 s 的卡方分布。
- **用途**：检测时间序列是否存在显著的自相关（即当前值与历史值是否相关）。
    - 使用这个统计量，明显可以发现较高的样本自相关系数将导致较大的 Q 值。
    - 白噪声过程 (在这个过程中，所有自相关系数应该为 0) 的 Q 值为 0。
- **假设检验**： 
    - **原假设**（H₀）：序列无自相关（即纯随机性/白噪声）。 
    - **判断标准**：若计算出的 Q 统计量超过卡方分布的临界值（或 p 值 < 0.05），则拒绝原假设，认为存在自相关。
-  **不足**：Box-Pierce 形式的 Q 统计量适用于大样本，但在相对较小的样本中效果不佳。即使是适度大的样本，其效果也较差。

基于此，Ljung-Box（1978）提出了更优、对小样本同样适用的修正 Q 统计量，公式为： $$Q_{LB} =  \frac{T(T+2) \sum_{k=1}^s r_k^2}{T-k}$$ 它与 $Q_{BP}$ 的差别与关联是：$$Q_{LB} =  \frac{T(T+2) \sum_{k=1}^s r_k^2}{n-k}=\frac{T+2}{T-k}Q_{BP}$$ 其中，$T$ 为样本量，$m$ 为最大滞后阶数，$r_k$ 为 k 阶自相关系数。

Box-Pierce 和 Ljung-Box 的 Q 统计量同样可以用于检验被估的 ARMA (p, q) 模型的残差是否为白噪声过程，然而，若从被估的 ARMA (p, q) 模型中得到了 s 个自相关系数，则自由度会随待估系数的增加而减少。因此，若使用 ARMA (p, q) 模型的残差，Q 统计量服从自由度为 s-p-q 的卡方分布 (若模型包含了一个常数，则自由度为 s-p-q-1)。
#### 2.3.5.2 可逆性

在诊断检验阶段，确定模型恰当的另一个非常重要的条件是平稳可逆。正如我们在 [2.3.3 Box-Jenkins 模型筛选：定阶](#2.3.3%20Box-Jenkins%20模型筛选：定阶) 一开始就提到的，我们在本章仅讨论平稳的时间序列，因此，这一节我们讨论的重点是可逆性（invertible）。我们将围绕三个问题展开本小节：
1. 什么是可逆性？
2. 可逆性的作用？
3. 怎么满足可逆性？

我们先从第一个问题开始。课本给出的定义如下：
> [!NOTE] 什么是可逆性？
> **<font color="#c22b24"> 可逆性的定义 </font>**：若 $\{y_t\}$ 能被一个有限阶或收敛的自回归过程表示，则序列可逆。

看上去有些晦涩。我们以 MA (1) 为例来说明可逆性及其作用。考虑简单的 MA (1) 模型：$$x_t = \varepsilon_t - \beta_1 \varepsilon_{t-1} = (1 - \beta_1 L) \varepsilon_t \quad \Rightarrow \quad \varepsilon_t=\dfrac{x_t}{1 - \beta_1 L}$$ 其中 L 是 [1.4.5.3 ](#1.4.5.3%20滞后算子) 节中我们学过的滞后算子。我们可以使用 Taylor 展开，有：
$$
\frac{1}{1 - \beta_1 L} = 1 + \beta_1 L + \beta_1^2 L^2 + \beta_1^3 L^3 + \cdots
$$
从而，$$\begin{split}
\varepsilon_t = \frac{x_t}{1 - \beta_1 L} &= x_t + \beta_1 L x_t + \beta_1^2 L^2 x_t + \beta_1^3 L^3 x_t + \cdots \\&= x_t+\beta_1 x_{t-1} + \beta_1^2 x_{t-2} + \beta_1^3 x_{t-3} + \cdots
\end{split}$$得到： $$
x_t =-\beta_1 x_{t-1} -\beta_1^2 x_{t-2} - \beta_1^3 x_{t-3} + \cdots +\varepsilon_t
$$形式上，我们将 MA(1) 转化成 AR(∞) 的形式。**该级数收敛的充要条件是 $|\beta_1|< 1$ 。**

类似地，我们可以推导得到 q 阶 MA 模型，用滞后算子得到：$$\varepsilon_t= \frac{x_t}{1 - (\beta_1 L + \beta_2 L^2+\cdots+\beta_q L^q)}=[1 - (\beta_1 L + \beta_2 L^2+\cdots+\beta_q L^q)]^{-1}x_t$$ 其可以转换为 AR(∞) 模型。因此，我们可以说：<b> <font color="#c22b24"> MA (q) 可以转换为有约束的 AR (∞) 模型 </font> </b>。

尽管模型 MA(q)对任意 $|\beta_1|<∞$ 都是平稳的，但模型却不一定能转换为合理的有约束 AR(∞)模型，而是需要满足一定条件，这被称为 **可逆性条件**。对于具有收敛 AR 表达式的 ARMA 模型，特征多项式的根应在单位圆之外。

**对于 MA (2) 模型，可逆要求： $|\beta_2| < 1$，$\beta_2+\beta_1 < 1$，$\beta_2 - \beta_1 < 1$ 均成立。**

最后，作为一个补充拓展，请思考：为什么这被叫做“可逆性”？
> [!TIP]  【回顾】AR (1) 转化为 MA ($\infty$)
>  对于平稳的 AR (1) 模型：  
>   $$ y_t = a_0 + a_1 y_{t-1} + \varepsilon_t, \quad \varepsilon_t \sim \text{i.i.d. } N(0, \sigma^2), $$  
>  **向前递推**：AR (1) 模型可表示为： 
>    $$\begin{split}y_t &= a_0 + a_1 y_{t-1} + \varepsilon_t  \\&= a_0 + a_1(a_0 + a_1 y_{t-2} + \varepsilon_t) + \varepsilon_t  \\&= \cdots  \\&= a_0(1 + a_1 + a_1^2 + \cdots) + \varepsilon_t + a_1 \varepsilon_{t-1} + a_1^2 \varepsilon_{t-2} + \cdots \\  &= \dfrac{a_0}{1 - a_1} + \varepsilon_t + a_1 \varepsilon_{t-1} + a_1^2 \varepsilon_{t-2} + \cdots \\&= \dfrac{a_0}{1 - a_1} + \sum_{i=0}^\infty a_1^i \varepsilon_{t-i}\end{split}$$ 
>   这表明当前观测值 $y_t$ 是历史扰动项 $\varepsilon_{t-i}$ 的加权和，权重为 $a_1^i$。因此，AR (1) 可以转化为 MA ($\infty$) 。这个知识点在 [1.5.2.1 AR(1)的线性特征](#1.5.2.1%20AR(1) 的线性特征) 已介绍过（但没有证明）。
>   因此，我们知道：AR 可以推得 MA，现在我们证明了 MA 在一定条件下也可以证得 AR。这就是被称为“可逆性”的原因。
#### 2.3.5.3 简练原则

在探讨完可逆性之后，我们进一步对 Box - Jenkins 方法进行探讨。Box - Jenkins 方法的基本思想是 **简练原则**。

正如在 [2.3.3.4 信息准则](#2.3.3.4%20信息准则) 节中我们提到的，增加新的参数固然会提高拟合优度（即判定系数 $R^{2}$ 会增加），但同时也减少了自由度。Box 和 Jenkins 证明：简练模型要比参数过多模型的预测效果更好，一个简练模型能较好地拟合数据且不需要增加无关的参数。尽管我们也希望充分地得到未来的估计参数，但是我们的目的是接近真实的数据生成过程，而不是绝对准确地刻画出这个过程（过拟合）。

> [!TIP] 过拟合
> - **过拟合是机器学习中的一个概念，指的是模型对训练数据的过度学习**。
> - 当模型过拟合时，它在训练数据上表现得非常好，但在新数据上表现不佳。这是因为模型学习了训练数据中的噪音和离群值，这些信息在新数据上无法很好地泛化。
> - 过拟合就像是背诵了一组问题的答案，而不是理解其背后的原理。虽然模型可能会正确回答已知问题，但在面对新问题或已知问题的变体时却会陷入困境。

在选择最恰当模型的过程中，计量经济学家会意识到：**不同的模型可能有相似的特征**。
- 作为一个极端的例子，AR (1) 模型 $y_{t}=0.5 y_{t - 1}+\varepsilon_{t}$ 有等价的无限阶移动平均表达式 $y_{t}=\varepsilon_{t}+0.5\varepsilon_{t - 1}+0.25\varepsilon_{t - 2}+0.125\varepsilon_{t - 3}+0.0625\varepsilon_{t - 4}+\cdots$。在大样本的情况下，将 MA ($\infty$) 过程近似地确定为 MA (2) 或 MA (3) 过程，可以得到一个较好的拟合优度。然而，**AR (1) 模型更简练，所以更优。**
- 同时，也要注意公因式（common factor）问题。假设我们想拟合 ARMA (2,3) 模型： $$ (1 - a_1L - a_{2}L^{2}) y_{t}=(1+\beta_1L+\beta_{2}L^{2}+\beta_{3}L^{3})\varepsilon_{t} $$ 假设 $(1 - a_1L - a_{2}L^{2})$ 和 $(1+\beta_1L+\beta_{2}L^{2}+\beta_{3}L^{3})$ 分别可被因式分解为 $(1 + cL)(1 + aL)$ 和 $(1 + cL)(1 + b_{1}L + b_{2}L^{2})$。因为 $(1 + cL)$ 为公因式，所以有等价但更为简练的形式： $$ (1 + aL) y_{t}=(1 + b_{1}L + b_{2}L^{2})\varepsilon_{t} $$ 当我们揭开了前面的谜题后，就应该明白 $(1 - 0.25 L^{2}) y_{t}=(1 + 0.5 L)\varepsilon_{t}$ 等价于 $(1 + 0.5 L)(1 - 0.5 L) y_{t}=(1 + 0.5 L)\varepsilon_{t}$。因此，$y_{t}=0.5 y_{t - 1}+\varepsilon_{t}$。

实践中，多项式也许不能完全进行因式分解，然而，若因式近似，应尝试使用更为简练的形式。为了确保模型简练，每个参数 $a_{i}$ 和 $\beta_{i}$ 的 $t$ 统计量都应该大于等于 2.0（这样才能够保证在 5%显著水平下的每个系数显著地异于零）。

此外，因为具有高度多重共线性的系数是不稳定的，所以，要求系数不能彼此相关，因此，通常可从模型中删去 1 个到多个系数，同时又不会影响模型的预测效果。
#### 2.3.5.4 样本区间外预测

ARMA 模型最重要的用途是用于预测序列的未来值，较好的样本区间外预测也能够为模型的选择提供参考。
- 首先，我们先明确基本概念：站在 $t$ 时点预测 $r_{t + k}$，其中 $k∈Z^+$，称时间点 $t$ 为 **预测原点**，正整数 $k$ 为 **预测步长**。定义 $\hat{r}_t(k)$ 为 $r_t$ 从预测原点 $t$ **向前 $k$ 步预测值**。
- 其次，我们认为：恰当的模型具有较好的样本区间外预测。自然地，我们要问：我怎么知道这个模型预测的效果好不好？这就涉及到了 **损失函数**（Loss Function） 的概念。

> [!Note] 损失函数
> - 我们使用 **损失函数** 评估预测的优劣。
> - 损失函数通过数学表达式刻画模型预测值 $\hat{y}$ 与真实值 $y$ 的偏差。
> - 单个样本的损失 $L(y, \hat{y})$ 反映 **预测误差**，多个样本则计算平均损失。
> - 常用的损失函数：
>     1. 均方误差（Mean Square Error，简称 MSE），定义为： $$MSE(\hat{r}_t(k)) = \mathbb{E}\left(r_{t + k} - \hat{r}_t(k)\right)^2$$
>     2. 根均方误差（Root Mean Square Error，简称 RMSE），定义为： $$RMSE(\hat{r}_t(k)) = \sqrt{\mathbb{E}\left(r_{t + k} - \hat{r}_t(k)\right)^2}$$
>     3. 平均绝对误差（Mean Absolute Error，简称 MAE），定义为： $$ MAE(\hat{r}_t(k)) = \mathbb{E}|r_{t + k} - \hat{r}_t(k)| $$

- 在本小节中，我们使用均方误差（MSE）作为预测优劣的评判标准。
- 均方误差越小，我们就可以认为模型拟合效果越好。由此，我们希望得到的模型应该是最小均方误差的，即：**选择合适的模型，使得其预测 $\hat{r}_t(k)$ 满足 $\mathbb{E}\left([r_{t+k} - \hat{r}_t(k)]^2 |\Omega_t \right)$ 最小。** 其中：$\Omega_t$ 表示 $t$ 时刻所得到的所有信息。
- 使得均方误差最小的预测就是给定 $\Omega_t$ 条件下的 $r_{t+k}$ 的期望值，即：$$\hat{r}_t(k) = E\left( r_{t+k} \big| \Omega_t \right)$$
现在，我们考虑几个常用模型的预测。
##### 2.3.5.4.1 AR 模型的向前 k 步预测
1. **AR(p)模型的向前一步预测：**
$$r_{t+1} = a_0 + a_1 r_t + \cdots + a_p r_{t+1-p} + \varepsilon_{t+1} \qquad \Omega_t=\{r_t, r_{t-1},...\}$$
 **向前一期 $r_{t+1}$ 的点预测**：
$$\hat{r}_t (1) = E(r_{t+1}|\Omega_t) =a_0 +a_1r_t+\cdots+a_pr_{t+1-p}= a_0 + \sum_{i=1}^p a_i r_{t+1-i}$$
**预测误差及其方差**：
$$e_t (1) = r_{t+1} - \hat{r}_t (1) = \varepsilon_{t+1} \quad \Rightarrow \quad {Var}(e_t (1)) ={Var}(\varepsilon_{t+1})= \sigma^2 $$
**如果 $\varepsilon_t$ 服从正态分布，则 $r_{t+1}$ 的 95%置信区间**： $$\left[ \hat{r}_t (1) - 1.96\sigma,\ \hat{r}_t (1) + 1.96\sigma \right]$$
2. **AR(p)模型的向前两步预测：**
$$ r_{t+2} = a_0 + a_1r_{t+1} +a_2 r_t+ \cdots + a_p r_{t+2-p}+\varepsilon_{t+2} \qquad \Omega_t=\{r_t, r_{t-1},...\}$$
**向前两期 $r_{t+2}$ 的点预测**：  
$$ \hat{r}_t(2) = {E}(r_{t+2}|\Omega_t) = a_0 + a_1 \hat{r}_t (1) +a_2 r_t + \cdots + a_p r_{t+2-p} $$
**预测误差及其方差**：（注：大多数项都被差分消去，保留的是 $e_t(1)$ 和最后的误差项。 ）  
$$\begin{split} e_t(2) & = r_{t+2} - \hat{r}_t(2) =a_1e_t(1)+\varepsilon_{t+2}= a_1 \varepsilon_{t+1}+\varepsilon_{t+2} \\ {Var}(e_t(2)) &= {Var}(a_1 \varepsilon_{t+1}+\varepsilon_{t+2}) = (1 + a_1^2) \sigma^2\end{split}$$
**如果 $\varepsilon_t$ 服从正态分布，则 $r_{t+2}$ 的 95% 置信区间**：  
$$ \left[ \hat{r}_t(2) - 1.96 \sqrt{(1 + a_1^2) \sigma^2},\ \hat{r}_t(2) + 1.96 \sqrt{(1 + a_1^2) \sigma^2} \right] $$
3. 请思考：对于 **AR(p) 模型的向前三步预测**，点预测和预测误差分别是什么。对于预测误差的推导非常重要，与后面 k 步预测、脉冲反应函数相关。$$\begin{split} e_t(3)=r_{t+3}-\hat{r}_t(3)&=a_1r_{t+2}+a_2r_{t+1}-a_1\hat{r}_t(2)-a_2\hat{r}_t(1)+\varepsilon_{t+3} \\&=a_1e_t(2)+a_2e_t(1)+\varepsilon_{t+3}\\&=a_1\cdot[a_1e_t(1)+\varepsilon_{t+2}]+a_2e_t(1)+\varepsilon_{t+3}\\&=(a_1^2+a_2)e_t(1)+a_1\varepsilon_{t+2}+\varepsilon_{t+3}\\&=(a_1^2+a_2)\varepsilon_{t+1}+a_1\varepsilon_{t+2}+\varepsilon_{t+3}\end{split}$$
4. **AR (p) 模型的向前 k 步预测：**
    $$ r_{t+k} = a_0 + a_1r_{t+k-1} + \cdots + a_p r_{t+k-p}+\varepsilon_{t+k} \qquad \Omega_t=\{r_t, r_{t-1},...\}$$
    **向前 k 期 $r_{t+k}$ 的点预测**：  
    - 当 $k<p$ 时，模型包含 k 个预测项和（p-k）个已有信息。$$\begin{split} \hat{r}_t(k) = {E}(r_{t+k}|\Omega_t) &= a_0 + a_1 \hat{r}_t(k-1) +a_2 \hat{r}_t(k-2)+ \cdots +a_{k-1} \hat{r}_t(1) \\& + a_k r_t +a_{k+1} r_{t-1} \cdots + a_p r_{t+k-p} \end{split}$$
    - 当 $k≥p$ 时，模型只包含 p 个预测项。$$\hat{r}_t(k) = {E}(r_{t+k}|\Omega_t) = a_0 + a_1 \hat{r}_t(k-1) +a_2 \hat{r}_t(k-2)+ \cdots +a_{p} \hat{r}_t(k-p) $$
> [!NOTE] 【思考】当 $k\rightarrow \infty$ 时的点预测
> 当 $k\rightarrow \infty$ 时， $$\begin{split}&\hat{r}_t(\infty)= a_0 + a_1 \hat{r}_t(\infty) + \cdots +a_{p} \hat{r}_t(\infty) \\ \\ \Rightarrow & \quad \hat{r}_t(\infty)= \dfrac{a_0}{1-(a_1+\cdots+a_p)}=\dfrac{a_0}{\sum_{i=1}^p a_i}\end{split}$$ 这是什么？$E(r_t)=a_0+\sum_{i=1}^p a_iE(r_{t-i})\quad \Rightarrow \quad E(r_t)=\dfrac{a_0}{\sum_{i=1}^p a_i}$，即：$$\hat{r}_t(\infty)=E(r_t)$$ 这就是 <font color="#c22b24">“均值回转”</font>：长期的点预测趋于无条件均值。

**向前 k 期的预测误差及其方差**：$$ e_t(k) = r_{t+k} - \hat{r}_t(k) = \sum_{j=0}^{k-1} \psi_j \varepsilon_{t+k-j} \quad \Rightarrow \quad \text{Var}(e_t(k)) = \sigma^2 \sum_{j=0}^{k-1} \psi_j^2 $$ **如果 $\varepsilon_t$ 服从正态分布，则 95%置信区间**： $$ \left[ \hat{r}_t(k) - 1.96 \sqrt{\text{Var}(e_t(k))},\ \hat{r}_t(k) + 1.96 \sqrt{\text{Var}(e_t(k))} \right]. $$   其中 $\psi_j$ 为 AR 模型的 <b> <font color="#c22b24"> 脉冲响应函数 </font> </b>。

> [!TIP] 什么是脉冲响应函数？
> **含义**：脉冲是指某一时刻的随机扰动项发生一个单位的瞬时变化。脉冲反应函数就是描述这一冲击对后续观测值 $y_{t+k}$ 的影响程度。
> **公式**：$$IRF(k)=\dfrac{\partial y_{t+k}}{\partial \varepsilon_t} \quad (k=0,1,2,\cdots)$$
> 
> 对于 AR(1) 模型，将 AR 模型转换为无限阶移动平均形式，对 t+k 期的预测就是 $$y_{t+k} = \frac{a_0}{1 - a_1} + \sum_{i=0}^\infty a_1^i \varepsilon_{t+k-i}$$ 那么，$t$ 期冲击 $\varepsilon_t$ 对  $y_{t+k}$ 的贡献（即，脉冲反应函数）就是 $y_{t+k}$ 对 $\varepsilon_t$ 的偏导数。因此，我们需要先找到 $\varepsilon_{t}$ 的项：<font color="#c22b24"> 当 $i = k$ 时，$\varepsilon_{t+k-i} = \varepsilon_{t}$，因此 $\varepsilon_t$ 对应的项为 $a_1^k \varepsilon_t$ </font> 。 $y_{t+k}$ 对 $\varepsilon_t$ 的偏导数仅保留含 $\varepsilon_t$ 的项：  
   $$IRF(k)= \dfrac{\partial y_{t+k}}{\partial \varepsilon_t} = \frac{\partial}{\partial \varepsilon_t} \left( \cdots + a_1^k \varepsilon_t + \cdots \right) = a_1^k$$ 
>   
>   AR(p) 与之类似，但较 AR(1) 复杂地多。每个滞后项的系数共同决定了冲击的传播路径，脉冲反应函数需通过递推公式计算。$$\text{IRF}(k) = \psi_k = \begin{cases} 1 & k=0, \\\sum_{i=1}^{\min(k,p)} a_i \psi_{k-i} & k \geq 1\end{cases}$$ 比如，AR(2) 模型的脉冲响应： $$\psi_0 = 1, \quad \psi_1 = a_1, \quad \psi_2 = a_1^2 + a_2, \quad \ldots$$ 你是否有联想到 AR(p) 向前三步预测的误差 ？$e_t(3)=(a_1^2+a_2)\varepsilon_{t+1}+a_1\varepsilon_{t+2}+\varepsilon_{t+3}$ 
>   这些 $\psi$ 对应了各个 $\varepsilon$ 的系数！$e_t(3)=\psi_0\varepsilon_{t+3}+\psi_1\varepsilon_{t+2}+\psi_2\varepsilon_{t+1}$ 
>   那么，可以推断得：$$e_t(k)=\psi_0\varepsilon_{t+k}+\psi_1\varepsilon_{t+k-1}+\psi_2\varepsilon_{t+k-2}+\cdots+\psi_i\varepsilon_{t+k-i}+\cdots+\psi_{k-1}\varepsilon_{t+1}= \sum_{j=0}^{k-1} \psi_j \varepsilon_{t+k-j}$$ 请注意，到第 k-1 项为止。因为从第 k 项开始就不再是预测值，不存在预测误差了。
>   这也解释了为什么向前预测的时候所有非 $\hat{r}$ 项都会被差分消去。
##### 2.3.5.4.2 MA 模型的向前 k 步预测
1. MA(q) 模型形式：
$$ r_{t} = c_0 + \varepsilon_{t} + \beta_1 \varepsilon_{t-1} + \cdots + \beta_q \varepsilon_{t-q} $$
2. **MA 模型向前一步预测：**
对于 MA (q) 模型，向前一步为：
$$ r_{t+1} = c_0 + \varepsilon_{t+1} + \beta_1 \varepsilon_t + \cdots + \beta_q \varepsilon_{t+1-q} $$
给定 $\Omega_t = \{r_t, r_{t-1}, \ldots\}$ 的条件下，$r_{t+1}$ 的点预测为：
$$ \hat{r}_t (1) = E (r_{t+1}|\Omega_t) = c_0 +  \beta_1 \varepsilon_t + \cdots + \beta_q \varepsilon_{t+1-q} $$
预测误差为：
$$ e_t (1) = r_{t+1} - \hat{r}_t (1) = \varepsilon_{t+1} $$
向前 1 步预测误差的方差为：
$$ \text{Var}(e_t (1)) = \text{Var}(\varepsilon_{t+1}) = \sigma^2 $$
如果 $\varepsilon_t$ 服从正态分布，则 95%置信水平下向前 1 步区间预测为： $$[\hat{r}_t (1) - 1.96\sigma, \hat{r}_t (1) + 1.96\sigma]$$ 
3. **MA 模型向前 2 步预测：**
对于 MA (q) 模型，向前两步为：
$$r_{t+2} = c_0 +  \varepsilon_{t+2} + \beta_1 \varepsilon_{t+1} + \beta_2 \varepsilon_{t} + \cdots + \beta_q \varepsilon_{t+2-q}$$
给定 $\Omega_t = \{r_t, r_{t-1}, \cdots\}$ 的条件下，$r_{t+2}$ 的点预测为：  
$$\hat{r}_t(2) = {E}(r_{t+2}|\Omega_t) = c_0 + \beta_2 \varepsilon_t + \cdots + \beta_q \varepsilon_{t+2-q}$$
预测误差为：  
$$e_t(2) = r_{t+2} - \hat{r}_t(2) = \varepsilon_{t+2} + \beta_1 \varepsilon_{t+1}$$
向前 2 步预测误差的方差为：  
$$\text{Var}(e_t(2)) = \text{Var}(\beta_1 \varepsilon_{t+1} + \varepsilon_{t+2}) = (1+\beta_1^2)\sigma^2$$
如果 $\varepsilon_t$ 服从正态分布，则 95%置信水平下向前 2 步区间预测为 $$[\hat{r}_t(2)-1.96\sqrt{1+\beta_1^2}\sigma,\hat{r}_t(2)+1.96\sqrt{1+\beta_1^2}\sigma]$$ 
4. **MA 模型向前 k 步预测：**
$$
r_{t+k} = c_0 + \varepsilon_{t+k} + \beta_1 \varepsilon_{t+k-1} + \cdots + \beta_q \varepsilon_{t+k-q}
$$
给定信息集 $\Omega_t = \{r_t, r_{t-1}, \ldots\}$ 时：
$$
\hat{r}_t(k) = {E}(r_{t+k}|\Omega_t)
$$
- **短期预测（$k \leq q$）**：
$$
\hat{r}_t(k) = c_0 + \beta_k \varepsilon_t + \beta_{k+1} \varepsilon_{t-1} + \cdots + \beta_q \varepsilon_{t+1-q}
$$
- **长期预测（$k > q$）**：
$$
\hat{r}_t(k) = c_0 \quad (\text{等于模型均值})
$$
##### 2.3.5.4.3 ARMA 模型的向前 k 步预测
1. **ARMA 向前一步预测**
$$r_{t+1} = a_0 + a_1 r_t + \cdots + a_p r_{t+1-p} + \varepsilon_{t+1} + \beta_1 \varepsilon_t + \cdots + \beta_q \varepsilon_{t+1-q}$$
给定 $\Omega_t = \{r_t, r_{t-1}, \cdots\}$ 的条件下，$r_{t+1}$ 的点预测为：
$$\hat{r}_t(1) = a_0 + a_1 r_t + \cdots + a_p r_{t+1-p} + \beta_1 \varepsilon_t + \cdots + \beta_q \varepsilon_{t+1-q}$$
预测误差的方差为：
$$\text{var}(e_t(1)) = \text{var}(\varepsilon_{t+1}) = \sigma^2$$
如果 $\varepsilon_t$ 服从正态分布，则 95%置信水平下 $r_{t+1}$ 向前 1 步区间预测为：
$$[\hat{r}_t(1) - 1.96\sigma, \hat{r}_t(1) + 1.96\sigma]$$
2. **ARMA 向前 k 步预测**
$$
r_{t+k} = a_0 + a_1 r_{t+k-1} + \cdots + a_p r_{t+k-p} + \varepsilon_{t+k} + \beta_1 \varepsilon_{t+k-1} + \cdots + \beta_q \varepsilon_{t+k-q}
$$
给定信息集 $\Omega_t = \{r_t, r_{t-1}, \cdots\}$ 时，点预测：
$$
\hat{r}_t(k) = {E}(r_{t+k}|\Omega_t)
$$
当 $k > \max(p,q)$ 时，简化为：
$$
\hat{r}_t(k) = a_0 + a_1 \hat{r}_t(k-1) + \cdots + a_p \hat{r}_t(k-p)
$$
当 $k \to \infty$ 时，$$  \hat{r}_t (\infty) = a_0 + a_1 \hat{r}_t (\infty) + a_2 \hat{r}_t (\infty) + \cdots + a_p \hat{r}_t (\infty)
 = \frac{a_0}{1 - a_1 - a_2 - \cdots - a_p} = \mathbb{E}(r_t)
  $$预测误差为：$$ e_t (k) = a_1 e_t (k-1) + a_2 e_t (k-2) + \cdots + a_p e_t (k-p) + \varepsilon_{t+k} + \beta_1 \varepsilon_{t+k-1} + \cdots + \beta_q \varepsilon_{t+k-q}$$
  **小结：任何 ARMA(p, q) 过程的预测最终都将满足 p 阶差分方程。这个差分方程由模型的齐次部分构成。多步提前预测将会收敛于序列长期均值。**

  > [!note] 【拓展】ARMA(1,1)模型的脉冲反应
  > 此前我们在 [2.3.5.4.1 AR 模型的向前 k 步预测](#2.3.5.4.1%20AR模型的向前%20k%20步预测) 中介绍了脉冲响应函数。
  > 对于 AR(1) 模型，通过将 AR 模型转换为无限阶移动平均形式，得到对 t+k 期的预测 
  > $$r_{t+k} = \frac{a_0}{1 - a_1} + \sum_{i=0}^\infty a_1^i \varepsilon_{t+k-i}$$ 
  > 那么，如果是 ARMA(1,1)模型呢？
  > $$r_t = a_0 + a_1 r_{t-1} + \varepsilon_t + \beta_1 \varepsilon_{t-1}, \quad \varepsilon_t \sim i.i.d. N(0, \sigma^2)$$
  > - **1 阶递推：** $r_{t-1} = a_0 + a_1 r_{t-2} + \varepsilon_{t-1} + \beta_1 \varepsilon_{t-2}$
  > $$\begin{split} r_t &= a_0 + a_1(a_0 + a_1 r_{t-2} + \varepsilon_{t-1} + \beta_1 \varepsilon_{t-2}) + \varepsilon_{t} + \beta_1 \varepsilon_{t-1} \\ &= a_0 (1 + a_1) + a_1^2 r_{t-2} + \varepsilon_t + (\beta_1 + a_1) \varepsilon_{t-1} + a_1 \beta_1 \varepsilon_{t-2}\end{split}$$
  > - **2 阶递推：** $$r_t = a_0 (1 + a_1 + a_1^2) + a_1^3 r_{t-3} + \varepsilon_t + (\beta_1 + a_1) \varepsilon_{t-1} + (\beta_1 + a_1) a_1 \varepsilon_{t-2} + \beta_1 \varepsilon_{t-3}$$
  > - **无限阶 MA 表示：** $$r_t = \frac{a_0}{1 - a_1} + \varepsilon_t + \sum_{j=1}^{\infty} (\beta_1 + a_1) a_1^{j-1} \varepsilon_{t-j}$$
  > $$r_{t+k} = \frac{a_0}{1 - a_1} + \varepsilon_{t+k} + \sum_{j=1}^{\infty} (\beta_1 + a_1) a_1^{j-1} \varepsilon_{t+k-j}$$
  > 因此，$t$ 期冲击 $\varepsilon_t$ 对 $t + k$ 期收益率 $r_{t+k}$ 的贡献为
  > $$ \frac{\partial r_{t+k}}{\partial a_t} =  \begin{cases} 1, & k=0 \\ (a_1 + \beta_1) a_1^{k-1}, & k \geq 1 \end{cases} $$
  > 对于 ARMA(p, q)模型，也可类似计算脉冲反应，但更为复杂。
##### 2.3.5.4.4 样本区间外预测评价
一般来讲，我们有多个看似合理的模型可供选择用于预测。千万不要认为拟合优度最高的模型预测效果就最好。我们关注的问题是：**如何确定多个合理的模型中的哪个模型的预测效果最好？**

**方法一：对备选模型进行直接检验。**
做法：
1. 从估计过程中保留部分观测值，在缩短的数据跨度上估计替代模型。
2. 使用这些估计值预测保留期的观测值。
3. 比较两个模型预测误差的特性。 
示例：若 $y_t$ 共含 150 个观测值，需要确定 AR (1) 和 MA (1) 中哪个模型能最好地描述序列的趋势。
- 使用前 100 个观测值估计 AR (1) 和 MA (1) 模型，并分别预测 $y_{101}$ 的值。构建 AR (1) 和 MA (1) 模型获得的预测误差。
- 使用前 101 个观测值重新估计 AR (1) 和 MA (1) 模型，再构建两个预测误差。
- 持续该过程，最终获得两个各含 50 个观测值的一步向前预测误差序列。

**方法二：基于回归的预测评估方法。**
- 利用 AR (1) 模型产生的 50 个预测值，估计形如 $y_{100+t} = a_0 + a_1 f_{1t} + v_{1t}$ 的方程。若预测结果无偏，F 检验应能支持约束条件 $a_0 = 0$ 且 $a_1 = 1$。
- 对 MA (1) 模型的预测结果重复此过程：使用 MA (1) 产生的 50 个预测值估计 $y_{100+t} = b_0 + b_1 f_{2t} + v_{2t}$，同样进行 F 检验。
- 若两个 F 检验的显著性水平相近，则可选择残差方差较小的模型。

**方法三：最小化均方预测误差 (MSPE) 方法（损失函数极大似然估计）。**
- 若包含 H 个观测值，AR (1) 模型的 MSPE 可通过以下公式计算：$$MSPE = \frac{1}{H} \sum_{i=1}^{H} e_{1i}^2$$
- 选择标准是：比较两个模型的 MSPE 数值，优先选用预测误差较小的模型。通常建议使用 F 统计量确定 MSPE 在统计上是否异于零，其公式就是两个 MSPE 的比值。
- 显然，若两模型的预测误差相同，则 F 值等于 1。较大的 F 值意味着分子代表模型的预测误差明显大于分母代表的模型。
- **然而**，在相同预测效果的原假设下，MSPE 服从标准 F 分布还需要满足三个前提：
     1. 预测误差服从均值为零的正态分布；
     2. 预测误差序列不相关；
     3. 预测误差彼此不相关。
- 实现这些假设并不容易：**Granger-Newbold 检验** 和 **Diebold-Mariano 检验**
    - Granger 和 Newbold(1976) 在假设 1 和假设 2 成立的条件下放宽了预测误差同时相关要求（假设 3）：若从每个模型中得到 H 个提前 1 步预测，则可用两个预测误差的序列生成【和序列】和【差序列】。若【和序列】和【差序列】的相关系数 r 在统计上异于零，那么，当 r 为正时，分子代表模型的 MSPE 更大; 当 r 为负时，分母代表模型的 MSPE 更大。
    - **【掌握：DM 检验】** Diebold-Mariano(1995)扩展了放宽假设 1-3 的检验，请注意：**这种检验要求目标函数不是平方项。**
> [!tip] **DM 检验的做法**：
> - 在典型的误差平方均值的例子中，常把损失定义为 $e_i^2$。为一般化，DM 检验用 $g(e_i)$ 表示第 $i$ 期的因预测误差造成的损失。于是，损失均值为：$$\begin{aligned} \overline{d}&=\frac{1}{H}\sum_{i=1}^{H}[g(e_{1i})-g(e_{2i})] \end{aligned}$$
> - 当序列 ${d_i}$ 满足：（1）方差为 $\gamma_0$；（2）序列不相关（白噪声特性）。则：
>     - 方差估计值：$$\widehat{\text{var}}(\bar{d}) = \frac{\gamma_0}{H-1}$$
>     - 统计量分布：$$\frac{\bar{d}}{\sqrt{\dfrac{\gamma_0}{H-1}}} \sim t(H-1)$$
> - 在存在序列相关时，Diebold 和 Mariano 用 $\gamma_i$ 表示 $i$ 阶 $d_i$ 序列的自协方差。这时，假设前 q 个值不为 0，建议构造 Diebold-Mariano(DM)统计量： $$DM = \frac{\overline{d}}{\sqrt{\dfrac{\gamma_0 + 2\gamma_1 + \cdots + 2\gamma_q}{H - 1}}} $$
#### 2.3.5.5 系数不随样本期改变（结构性变化）
Box-Jenkins 方法论的一个重要的假设是：数据生成过程的结构是不变化的（或者，就是系数不随样本期改变）。但是，我们有时怀疑数据生成过程中存在结构突变。例如，2008 年金融危机对于系数可能有显著影响。
**怎么排除这样的担忧？**—— <b> <font color="#245bdb"> 邹检验（Chow 检验）</font> </b>
- Chow 检验的本质：用突变前数据和突变后数据来拟合同一个模型。如果这两个模型的差异不是很大，则说明在数据生成过程中没有出现任何的结构性突变。
- Chow 检验并不局限于时间序列。它是主流的 **组间系数差异检验方法** 之一。[ref](https://zhuanlan.zhihu.com/p/629123531)
- T 个观测值分成两个子样本，Shock 之前的观测值作为第一个子样本; Shock 之后的观测值为第二个子样本。分别使用两个子样本估计 ARMA 模型。两个模型的残差平方和分别记为 $SSR_1$ 和 $SSR_2$。
- Chow 检验的原假设：所有的系数都对应相等。使用 F 检验，并构建 F 统计量：$$ F = \dfrac{\dfrac{\text{SSR} - \text{SSR}_1 - \text{SSR}_2}{n}}{\dfrac{\text{SSR}_1 + \text{SSR}_2}{T-2n}}$$
- 式中，n 为待估参数的个数（如果包含截距项，则 n = p+q+1，否则 n = p+q）；
- 分子和分母的自由度分别为 n 和 (T−2n)。
- 如果原假设成立，系数均相等，则  $SSR_1+SSR_2$ 等于整个样本估计的残差平方和，这时 F 统计量的值等于 0。
- Chow 检验的拓展：
    - Chow 检验研究的是 **已知的某个固定突变时间**。
    - 如果研究者事先不知道这个突变日期，那么称为 <font color="#245bdb"> 内生性突变 </font>(endogenous break)。
    - 为了确定样本中是否存在突变，那么，就应该对每个潜在的突变时间进行邹氏检验。为了确保子样本中都具有恰当数量的观测值。实际研究中，通常采用整理值 10%，使得每个子样本至少存在 10%的观测值。

进一步拓展：使用 **递归估计** 识别时间段的突变
- **Chow 检验可以识别某个时间点发生的突变，但是有些突变的出现不是瞬时的，而是时间段的。** 例如：计算机的应用。
- 我们难以识别突变出现的精确时间，即使选用某个时间点，但是突变带来的整体影响却不会马上表现出来。
- 最简单的方法是 **递归估计** 这个模型。例如，如果有 150 个观测值，那么，我们可以只使用最初的 10 个观测值来估计模型。估算单独系数的值，并且运用最初的 11 个观测值重新估计模型。重复进行这样的过程，直到使用完全部 150 个观测值。
- 如果系数值在某个时期突然出现了变化，那么可以怀疑在那一个时期出现了结构性突变。
- 但是，系数的突变或许是模型设定误差导致的偏误（而不是真实的突变）。对这个问题的改良就是在给每一个系数取值时都使用估计系数的置信区间。
- 构造置信区间需要用到提前 1 步预测误差。如果模型非常好地拟合了数据，那么这个预测将是无偏的，这样，**预测误差的和应该不会偏离 0“特别远”**。
- Brown、Durbin 和 Evans (1975) 构造了 CUSUM 统计量，来检验预测误差的和是否在统计上显著不为 0。
$$CUSUM_N=\dfrac{\Sigma^N_{i=n} e_i(1)}{\sigma_e}$$
- n——构建第一个预测误差的时期；  
- T——数据集中最后一个观测值的时期；
- $\sigma_e$——估计的预测误差的标准差。
- 在 5%显著水平下，CUSUM 取值约在 $±0.948[(T-n)^{0.5}+2(N-n)(T-n)^{-0.5}]$ 区域内。
#### 2.3.5.6 充分拟合数据
不同的模型可能会捕获到不同的信息，尤其是，当这些模型都能够合理地解释、但各自互不包含的时候。这时，我们难道只能武断地丢弃其他模型、仅运用“最佳的”模型进行预测吗？毫无疑问，这样做没能做到“充分拟合数据”。那怎么办呢？

我们可以构建 <b> <font color="#245bdb">【复合预测值】</font> </b>——<font color="#c22b24"> 运用所有合理模型进行预测并取所有预测值的均值。</font>

<ol>
<li>复合预测值的构造：给定 $n$ 个模型的提前一步预测值序列 ${f<em>{i1}, f</em>{i2}, \ldots, f<em>{in}}$，构造复合预测值为：$$f</em>{ci} = w<em>1 f</em>{i1} + w<em>2 f</em>{i2} + \cdots + w<em>n f</em>{ni}, \quad \text{其中} \sum_{i=1}^n w_i = 1$$ </li>
</ol>
<ul>
<li><ol>
<li>复合预测值是否合理？<ul>
<li>（1）复合预测中，点估计的 <strong>无偏性</strong>：<br> 若每个模型预测值无偏（$E<em>{t-1}(f</em>{it}) = y<em>t$），则复合预测值也是无偏的：  $$ E</em>{t-1}(f_{ci}) = y_t$$</li>
<li>（2）<strong>复合预测误差及其方差</strong><br> 以两个模型的复合为例，定义模型 1 和模型 2 的预测误差分别为 $e<em>{t1} = y_t - f</em>{t1}$ 和 $e<em>{t2} = y_t - f</em>{t2}$，则复合预测误差为：<script type="math/tex">e_{ct} = w_1 e_{t1} + (1 - w_1) e_{t2}</script> 复合预测误差的方差：<script type="math/tex">\text{Var}(e_{ct}) = w_1^2 \text{Var}(e_{t1}) + (1 - w_1)^2 \text{Var}(e_{t2}) + 2w_1(1 - w_1) \text{Cov}(e_{t1}, e_{t2}).</script> 假设两模型的预测误差满足：$\text{Var}(e<em>{t1}) = \text{Var}(e</em>{t2}) = \sigma^2$， $\text{Cov}(e<em>{t1}, e</em>{t2}) = 0$，权重 $w<em>1 = 0.5$（简单平均）。则复合预测误差的方差为：$$ \text{Var}(e</em>{ct}) = 0.25\sigma^2 + 0.25\sigma^2 = 0.5\sigma^2 $$ <strong>发现</strong>：<font color="#245bdb"> 组合预测的方差为单一模型方差的一半，显著降低了预测不确定性。</font></li>
</ul>
</li>
</ol>
</li>
<li><ol>
<li><strong>最优权重</strong><ul>
<li>尽管简单平均能减少预测误差方差，但寻找最优权重使预测误差方差最小化仍十分必要。</li>
<li>最优权重为：<script type="math/tex">w_1^* = \dfrac{\text{var}(e_{2i}) - \text{cov}(e_{1i} e_{2i})}{\text{var}(e_{1i}) + \text{var}(e_{2i}) - 2 \text{cov}(e_{1i} e_{2i})}</script></li>
<li>不包含协方差项的最优权重：<script type="math/tex">w_n^* = \frac{\operatorname{var}(e_{1i})^{-1}}{\operatorname{var}(e_{1i})^{-1} + \operatorname{var}(e_{2i})^{-1} + \cdots + \operatorname{var}(e_{ni})^{-1}}</script> </li>
<li>Granger 和 Ramanathan(1989)使用回归模型提出了一个构造权重的等效方法： <script type="math/tex">Y_t = \alpha_0 + \alpha_1 f_{1 t} + \alpha_2 f_{2 t} + \cdots + \alpha_n f_{nt} + v_t</script> 可令 $\alpha_0=0$, $\alpha_1+\alpha_2+\cdots+\alpha_n=1$。在这些条件下, $\alpha_i$ 直接解释最优权重,  $w_i^*$ 应设置等于 $\alpha_i$。</li>
<li>运用 SBC 作为权重因素：令 $SBC<em>i$ 表示模型 i 中的 SBC，令 $SBC^<em>$ 表示最适模型中的 SBC。可得 $\alpha_i = \exp\left[\dfrac{(SBC^</em> - SBC_i)}{2}\right]$ 并构造权重： $$w_i^* = \frac{\alpha_i}{\sum</em>{i=1}^{n} \alpha_i}$$ 最适模型权重为 $\dfrac{1}{\sum \alpha_i}$。由于 $\alpha_i$ 随 $SBC_i$ 的值减少，不太适合的模型在 SBC 值较大时具有更小的权重。<h3 id="2-3-6-季节性模型"><a href="#2-3-6-季节性模型" class="headerlink" title="2.3.6 季节性模型"></a>2.3.6 季节性模型</h3></li>
</ul>
</li>
</ol>
</li>
<li>时间序列中的季节性是在 S 个时间段内重复的常规变化模式。例如，月度数据存在季节性，高值往往总是出现在某些特定月份，而低值往往总是出现在其他特定月份。</li>
<li>季节性通常会导致序列不稳定，因为季节性跨度内某些特定时间（例如，月份）的平均值可能与其他时间的平均值不同。例如，我们的冷却风扇在夏季的销量将始终较高。</li>
<li><font color="#245bdb"> 季节性模型通常是乘法模型，而不是加法模型。</font> 乘法模型包括一个或多个非季节性参数与一个或多个季节性参数的乘积。</li>
<li>具有季节性时间序列的 ARMA 模型（季节性自回归移动平均，又叫 SARMA 模型）：<script type="math/tex; mode=display">Y_t = \theta_0 + \phi_1 Y_{t-1} + \phi_{12} Y_{t-12} - \theta_1 \varepsilon_{t-1} - \theta_{12} \varepsilon_{t-12} + \varepsilon_t</script>其中季节性成分捕捉长期模式，非季节性成分调整了对短期变化的预测。</li>
<li>$\theta_0$ 是截距参数。</li>
<li>$\phi_1$ 是非季节性一阶自回归参数。</li>
<li>$\phi_{12}$ 是季节性自回归参数。</li>
<li>$\theta_1$ 是非季节性一阶移动平均参数。</li>
<li>$\theta_{12}$ 是季节性移动平均参数。</li>
<li>$\varepsilon_t$ 是白噪声误差项。<br>在实践中，使用更多的是 SARIMA 模型。这就涉及了 ARIMA 模型，我们不妨将这部分内容留待 <a href="#Chapter%204">Chapter 7</a> 讨论。</li>
</ul>
<h2 id="第二章练习"><a href="#第二章练习" class="headerlink" title="第二章练习"></a>第二章练习</h2><h5 id="例-1：【信息准则】"><a href="#例-1：【信息准则】" class="headerlink" title="例 1：【信息准则】"></a>例 1：【信息准则】</h5><p><strong>判断：</strong> 根据下表，利用 AIC 和 BIC 准则评判两个模型的相对优劣， AR (1) 模型优于 MA (2) 模型吗？（    ）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tx">| 模型   | AIC      | SBC      |<br>| ----- | -------- | -------- |<br>| MA(2) | 536.4556 | 543.2011 |<br>| AR(1) | 535.7896 | 540.2866 |<br></code></pre></td></tr></table></figure><br>Ans： True.</p>
<h5 id="例-2：【白噪声检验】"><a href="#例-2：【白噪声检验】" class="headerlink" title="例 2：【白噪声检验】"></a>例 2：【白噪声检验】</h5><p>时间序列模型建立后，将要对模型进行显著性检验，检验的对象为（    ），检验的假设为？<br>Ans： 残差序列，原假设: 残差序列为白噪声序列<br>Note：模型的显著性检验主要是模型的有效性。一个模型是否显著有效主要看提取的信息是否充分。一个好的拟合模型应该能够提取观察值序列中几乎所有的样本相关信息，即残差序列应该为白噪声序列。这样的模型称为显著有效模型。反之，<strong>如果残差序列为非白噪声序列，那就意味着序列中还残留着相关信息未被提取，这就说明拟合模型不够有效</strong>，通常需要选择其他模型，重新拟合。因此，模型的显著性检验就是残差序列的白噪声检验。</p>
<h5 id="例-3：【AR-模型与-Yule-Walker-方程】"><a href="#例-3：【AR-模型与-Yule-Walker-方程】" class="headerlink" title="例 3：【AR 模型与 Yule - Walker 方程】"></a>例 3：【AR 模型与 Yule - Walker 方程】</h5><ol>
<li><p><strong>求解 AR(2) 模型的未知参数：</strong> <script type="math/tex">x_t=\phi_1x_{t - 1}+\phi_2x_{t - 2}+\varepsilon_t \qquad \varepsilon_t\sim WN(0,\sigma_{\varepsilon}^2)</script> 其中，$\rho_1 = 0.5$，$\rho_2 = 0.3$<br> Ans：$\phi_1$ = 7/15，$\phi_2$ = 1/15</p>
</li>
<li><p>AR(2)模型 $y<em>t=0.4y</em>{t-1}-0.5y<em>{t-2}+e_t$,，其中 $Var(e</em>{t})=0.64$，则 $E(Y_te_t)=$？<br> A.0  B.0.64   C.0.16   D.0.2<br> Ans：B</p>
</li>
<li><p><strong>AR 模型与 Yule - Walker 方程：</strong><br> $X<em>t=\phi_1X</em>{t - 1}+\phi<em>2X</em>{t - 2}+\varepsilon_t$，模型所满足的 Yule - Walker 方程是？<br> 当 $\phi_1 = 0.5$，$\phi_2 = 0.2$ ，模型所满足的 Yule - Walker 方程是？<br> Ans：$\begin{cases} \rho_1=\phi_1\rho_0+\phi_2\rho_1\ \rho_2=\phi_1\rho_1+\phi_2\rho_0 \end{cases}$， $\begin{cases} \rho_1=\phi_1\rho_0+\phi_2\rho_1 = 0.5 + 0.2\rho_1\ \rho_2=\phi_1\rho_1+\phi_2\rho_0 = 0.5\rho_1 + 0.2 \end{cases}$ ，</p>
<h5 id="例-4：【MA-模型】"><a href="#例-4：【MA-模型】" class="headerlink" title="例 4：【MA 模型】"></a>例 4：【MA 模型】</h5><p>确定常数 $C$ 的值，保证如下表达式为 MA (2) 模型:</p>
<script type="math/tex; mode=display">x_t = 10 + 0.5 x_{t - 1}+\varepsilon_t - 0.8\varepsilon_{t - 2}+C\varepsilon_{t - 3}</script><p>Ans：由 MA (2) 模型可知:<br>$x<em>t=\mu+\varepsilon_t-\theta_1\varepsilon</em>{t - 1}-\theta<em>2\varepsilon</em>{t - 2}$，$x<em>{t - 1}=\mu+\varepsilon</em>{t - 1}-\theta<em>1\varepsilon</em>{t - 2}-\theta<em>2\varepsilon</em>{t - 3}$<br>联立得: $x<em>t - 0.5 x</em>{t - 1}=0.5\mu+\varepsilon<em>t-(\theta_1 + 0.5)\varepsilon</em>{t - 1}-(\theta<em>2 - 0.5\theta_1)\varepsilon</em>{t - 2}+0.5\theta<em>2\varepsilon</em>{t - 3}$<br>即: $0.5\mu = 10$，$\theta_1 + 0.5 = 0$，$\theta_2 - 0.5\theta_1 = 0.8$，$0.5\theta_2 = C$<br>解得: $\mu = 20$，$\theta_1 = - 0.5$，$\theta_2 = 0.55$，所以 $C = 0.275$ </p>
<h5 id="例-5：【平稳性、可逆性】"><a href="#例-5：【平稳性、可逆性】" class="headerlink" title="例 5：【平稳性、可逆性】"></a>例 5：【平稳性、可逆性】</h5><p>判断 ARMA 模型平稳性和可逆性：</p>
</li>
</ol>
<ul>
<li>$Y<em>t = 0.8Y</em>{t - 1}+e<em>t - 0.4e</em>{t - 1}$ </li>
<li>$Y<em>t = 0.8Y</em>{t - 1}+1.4Y<em>{t - 2}+e_t + 1.6e</em>{t - 1}+0.5e_{t - 2}$<br>Ans：</li>
<li>AR 模型： $\phi_1 = 0.8 &lt; 1$ ，MA 模型： $\theta_1 = 0.4 &lt; 1$ 所以该模型平稳可逆 </li>
<li>AR 模型： $\phi_1 = 0.8$，$\phi_2 = - 1.4$，$|\phi_2|&gt;1$ 。不平稳。MA 模型： $\theta_1 = 1.6$，$\theta_2 = 0.5$，$|\theta_2|<1$， $\theta_2+\theta_1 = 2.1>1$ 。不可逆。<h5 id="例-6：【ACF-与-PACF】"><a href="#例-6：【ACF-与-PACF】" class="headerlink" title="例 6：【ACF 与 PACF】"></a>例 6：【ACF 与 PACF】</h5></li>
</ul>
<ol>
<li>若零均值平稳序列的样本 ACF 和样本 PACF 都呈现拖尾性。则可能建立的模型是：<br> A.MA (2)  B.ARMA (1, 1)  C.AR (2)   D.MA (1)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tx">| 模型  | 自相关系数 | 偏自相关系数 |<br>| --- | ----- | ------ |<br>|AR (p)|拖尾|p 阶截尾|<br>| MA (q)|q 阶截尾|拖尾 |<br>|ARMA (p, q)|拖尾|拖尾|<br></code></pre></td></tr></table></figure>
<ul>
<li>Ans：B</li>
</ul>
</li>
<li>对于一阶滑动平均模型 MA (1)：$Y=e<em>t-0.5e</em>{t-1}$，其一阶自相关函数为（）<br>  A. -0.5   B. 0.25   C. -0.4  D. 0.8<br> 对于 MA(1) 模型，ACF 为： $\rho<em>{0} = 1$， $\rho</em>{1} = \beta / (1 + \beta^{2})$ ， $\rho_{s} = 0, (s &gt; 1)$<br> Ans：C<ul>
<li>补充设问：其 PACF 是多少？（Hint：MA(1) 的 PACF = ACF）<h5 id="例-7：【区间外预测】"><a href="#例-7：【区间外预测】" class="headerlink" title="例 7：【区间外预测】"></a>例 7：【区间外预测】</h5></li>
</ul>
</li>
<li>己知某序列 $Y<em>t$ 服从 MA (2) 模型：<br> $Y_t=40+e_t-0.6 e</em>{t-1}+0.8 e<em>{t-2}$<br> 若 $\sigma^2=20$， $e_t=2$，$e</em>{t-1}=-4$，$e<em>{t-2}=-6$<br> (a) 预测未来 2 期的值:<br> (b) 求出未来两期预测值的 95%的预测区间。<br> （a）$$\begin{split}\hat{Y}_t(1) =&amp; E(Y</em>{t+1} | Y<em>1, Y_2, \dots, Y_t) \=&amp; E(40 + e</em>{t+1} - 0.6e<em>t + 0.8e</em>{t-1} | Y<em>1, Y_2, \dots, Y_t) \=&amp; 40 - 0.6e_t + 0.8e</em>{t-1} = 40 - 0.6×2 + 0.8×(-4) = 35.6\end{split}$$<script type="math/tex; mode=display">\begin{split}\hat{Y}_t(2) =& E(Y_{t+2} | Y_1, Y_2, \dots, Y_t) \\=& E(40 + e_{t+2} - 0.6e_{t+1} + 0.8e_t | Y_1, Y_2, \dots, Y_t) \\=& 40 + 0.8e_t = 40 + 0.8×2 = 41.6\end{split}</script> （b）  首先，根据公式 $Var[e<em>t(l)] = \sigma_e^2 \sum</em>{j=0}^{l - 1} \psi_j^2$ 计算预测误差方差： </li>
</ol>
<ul>
<li>当 $l = 1$ 时，$\sum_{j=0}^{0} \psi_j^2 = \psi_0^2 = 1$，则 $Var[e_t(1)] = 20×1 = 20$。 </li>
<li>当 $l = 2$ 时，$\sum_{j=0}^{1} \psi_j^2 = \psi_0^2 + \psi_1^2 = 1 + (-0.6)^2 = 1.36$，则 $Var[e_t(2)] = 20×1.36 = 27.2$。 </li>
<li>然后，利用 95% 预测区间公式 $(\hat{Y}<em>t(l) - z</em>{0.025} \sqrt{Var[e<em>t(l)]}, \hat{Y}_t(l) + z</em>{0.025} \sqrt{Var[e<em>t(l)]})$，其中 $z</em>{0.025} = 1.96$。</li>
<li>对于第一期，$\hat{Y}_t(1) = 35.6$，$\sqrt{20} ≈ 4.4721$，$1.96×4.4721 ≈ 8.7653$，预测区间为 $(35.6 - 8.7653, 35.6 + 8.7653) ≈ (26.8346, 44.3654)$。 </li>
<li>对于第二期，$\hat{Y}_t(2) = 41.6$，$\sqrt{27.2} ≈ 5.2154$，$1.96×5.2154 ≈ 10.2222$，预测区间为 $(41.6 - 10.2222, 41.6 + 10.2222) ≈ (31.3779, 51.8221)$。</li>
<li>综上，未来第一期预测区间 $(26.8346, 44.3654)$，未来第二期预测区间 $(31.3779, 51.8221)$。</li>
</ul>
<ol>
<li>AR (1) 模型: $x<em>t-\mu=\phi_1 (x</em>{t - 1}-\mu)+\varepsilon<em>t$，已求出 $\hat{\mu}=10$，$\hat{\phi}_1 = 0.3$，$\hat{\sigma}</em>{\varepsilon}^2 = 9$，求 $x_{t + 3}$ 的 95%的置信区间。</li>
</ol>
<ul>
<li>Ans：(3.84, 16.16)</li>
</ul>
<h1 id="Chapter-3-包含趋势的模型"><a href="#Chapter-3-包含趋势的模型" class="headerlink" title="Chapter 3: 包含趋势的模型"></a>Chapter 3: 包含趋势的模型</h1><blockquote>
<p>[!important] 本章学习目标</p>
<ol>
<li>形式化均值依赖于时间的变量的简单模型。</li>
<li>比较确定性趋势和随机趋势。</li>
<li>阐述标准回归和时间序列模型中的单位根问题，</li>
<li>阐述蒙特卡洛试验和模拟法如何得出假设检验的临界值。</li>
<li>提出并阐述用于检验是否存在单位根的 DF 检验和 ADF 检验。</li>
<li>将 DF 检验应用到美国 GDP 和汇率的实例中。</li>
<li>阐述 DF 检验在序列相关性、MA 模型、多元单位根、季节性单位根中的应用。</li>
<li>考察存在结构性变化的单位根检验。</li>
<li>阐述标准 DF 检验的缺陷。</li>
<li>阐述广义最小二乘法对 DF 检验的提升。</li>
<li>阐述如何用面板单位根检验来促进 DF 检验</li>
<li>把包含趋势的序列分解为平稳和趋势两个部分。<h2 id="3-1-趋势建模"><a href="#3-1-趋势建模" class="headerlink" title="3.1 趋势建模"></a>3.1 趋势建模</h2></li>
</ol>
</blockquote>
<p>在第 <a href="#Chapter%202%20平稳时间序列模型">2</a> 章，我们只讨论了平稳的时间序列。在本章，我们介绍 <strong>非平稳时间序列的处理方法</strong>。实际上，在自然界中绝大部分序列都是非平稳的，因而对非平稳序列的分析更普遍、更重要。</p>
<p>对于一个一般化的时间序列，最常用的确定性分析方法是确定性因素分解方法。</p>
<ul>
<li>该方法把所有序列的变化都归结为 4 个因素的综合影响：<ul>
<li>长期趋势 T。该因素的影响会导致序列呈现出明显的长期趋势 (递增、递减等)。</li>
<li>循环波动 C。该因素会导致序列呈现出从低到高再由高至低的反复循环波动。</li>
<li>季节性变化 S。该因素会导致序列呈现出和季节变化相关的稳定的周期波动。</li>
<li>随机波动 I。除了长期趋势、循环波动和季节性变化之外，序列还会受到各种其他因素的综合影响，而这些影响导致序列呈现出一定的随机波动。<br>人们在实际分析中进行了改进和简化，可以把序列分解为三大因素的综合影响：</li>
</ul>
</li>
</ul>
<ol>
<li>长期趋势波动，它包括长期趋势和无固定周期的循环波动。</li>
<li>季节性变化，它包括所有具有稳定周期的循环波动。</li>
<li>随机波动，除了长期趋势波动和季节性变化之外，其他因素的综合影响归为随机波动。</li>
</ol>
<p>通过乘法分解，我们可以将任何一个序列表示为各个因素的乘积；通过加法分解，我们可以将任何一个序列表示为各个因素的加总。</p>
<p>能否再进一步简化呢？当然是可以的。我们可以暂不具体划分确定性趋势，这样就得到：<b><span style="background:#fff88f">任何一个序列的波动都可以视为同时受到了确定性影响和随机性影响的综合作用</span></b>。</p>
<ul>
<li>要证明这一结论，就要涉及 <strong>Cramer 分解定理</strong>。对于 Cramer 分解定理的详细证明，可以参考中国人民大学统计学院王燕老师编著的《应用时间序列分析》，就不在此赘述了。</li>
<li>Cramer 分解定理扩展自我们在 <a href="#2.2.1%20Wold%20分解定理">第 2.2.1 节</a> 介绍的 Wold 分解定理，它将 Wold 分解定理的分解思路扩展到了非平稳序列。</li>
<li>从 Cramer 分解定理的结论引申，我们可以得到：平稳序列要求确定性影响和随机性影响都是稳定的，序列非平稳的原因就是这两方面的影响至少有一方面不稳定。</li>
</ul>
<p>在下面的分析中，我们先使用最简化的组成方式进行讨论。在进一步讨论之前，我们应当先认识下确定性趋势和随机趋势的表现形式：</p>
<ol>
<li>确定性趋势：从某个时期开始到下一个时期，一个序列总是变化固定相同的量： <script type="math/tex">Δy_t= a_0  \quad \Rightarrow \quad y_t=y_0+a_0t</script> 其中 $y_0$ 是第 0 期的初始值。</li>
<li>随机趋势：从某个时期开始到下一个时期，序列的变化量是白噪声：<script type="math/tex">Δy_t= \varepsilon_t  \quad \Rightarrow \quad y_t=y_0+\sum_{i=1}^t\varepsilon_i</script> 这被称为 <b> <font color="#245bdb"> 随机游走模型 </font> </b>（random walk），它在经济学和金融学中有着特殊的地位。一个非常典型的例子就是有效市场假设对股价随机游走的假定。<h2 id="3-2-随机趋势"><a href="#3-2-随机趋势" class="headerlink" title="3.2 随机趋势"></a>3.2 随机趋势</h2></li>
</ol>
<p>本节我们对随机游走进行进一步分析。对于随机游走的时间序列，$y_t$ 表示为白噪声项的累积和</p>
<script type="math/tex; mode=display">Δy_t= \varepsilon_t  \quad \Rightarrow \quad y_t=y_0+\sum_{i=1}^t\varepsilon_i</script><ol>
<li>随机游走的均值<br> 由于每个 $\varepsilon$ 的均值都为 0，$E(y_t)=y_0$</li>
<li>随机游走的方差<br> 由于白噪声项 $\varepsilon_i$ 不相关且方差相同（设为 $\sigma^2$），根据方差叠加性质：  <script type="math/tex">\text{var}(y_t) = \text{var}(\varepsilon_1) + \text{var}(\varepsilon_2) + \cdots + \text{var}(\varepsilon_t) = t \cdot \sigma^2</script> 方差 $\text{var}(y_t)$ 随时间线性增长，表明随机游走序列是 <strong>非平稳时间序列</strong>。  </li>
<li>随机游走的自相关系数（滞后 k 期）<script type="math/tex">\rho_k(t) = \frac{\text{Cov}(y_t, y_{t-k})}{\sqrt{\text{Var}(y_t) \cdot \text{Var}(y_{t-k})}}</script> 由于方差 $\text{Var}(y<em>t) = t\sigma^2$，协方差 $\text{Cov}(y_t, y</em>{t-k}) = (t - k)\sigma^2$，代入得：  <script type="math/tex">\rho_k(t) = \frac{(t - k)\sigma^2}{\sqrt{t\sigma^2 \cdot (t - k)\sigma^2}} = \sqrt{1 - \frac{k}{t}}</script><br>现在，我们将确定性趋势和随机趋势结合，得到 <strong>带漂移的随机游走模型</strong> <script type="math/tex">Δy_t= a_0+\varepsilon_t  \quad \Rightarrow \quad y_t=y_0+a_0t+\sum_{i=1}^t\varepsilon_i</script></li>
</ol>
<ul>
<li>这里 $y_t$ 的表现受线性确定性趋势和随机趋势这两个非平稳成分的影响。</li>
<li>带漂移的随机游走模型是一个纯趋势模型。</li>
</ul>
<p>更一般化地，我们可以再加入一个噪声项，得到：<strong>带噪声的趋势模型</strong></p>
<script type="math/tex; mode=display">y_t=y_0+a_0t+\sum_{i=1}^t\varepsilon_i+\eta_t</script><ul>
<li>它是确定性趋势、随机趋势和白噪声之和。</li>
<li>噪声序列并不要求一定是白噪声过程。</li>
</ul>
<h2 id="3-3-确定性趋势"><a href="#3-3-确定性趋势" class="headerlink" title="3.3 确定性趋势"></a>3.3 确定性趋势</h2><p>包含趋势的序列和平稳序列之间是有很大区别的。<strong>对平稳时间序列的冲击必然是短暂的，随时间推移，冲击的影响将消失，序列将回复到其长期均值水平。而对于包含趋势的序列，冲击后并不会回复到长期水平。</strong> 因此，对于包含趋势的时间序列，我们需要去除趋势来转化为平稳的时间序列，进而使用第 <a href="#Chapter%202%20平稳时间序列模型">2</a> 章的方法进行分析。</p>
<p>去除趋势影响的常规方法是 <strong>差分</strong> (diferencing) 和 <strong>去除趋势</strong> (detrending)。</p>
<ul>
<li><strong>去除趋势</strong>（detrending）操作必须作时间 $t$ 对变量 $y_t$ 的回归，并保留残差值。</li>
<li>一个包含单位根的序列可以通过 <strong>差分</strong>（diferencing）变得平稳。<h3 id="3-3-1-差分"><a href="#3-3-1-差分" class="headerlink" title="3.3.1 差分"></a>3.3.1 差分</h3>首先，考查带漂移的随机游走模型<script type="math/tex; mode=display">y_t=y_0+a_0t+\sum_{i=1}^t\varepsilon_i</script>取 1 阶差分，得到 <script type="math/tex">Δy_t= a_0+\varepsilon_t</script> 可以看出，$\Delta y_t$ 是平稳的时间序列，满足弱平稳的三大要求：</li>
</ul>
<ol>
<li>均值 $a_0$ 恒定：$E(\Delta y_t) = E(a_0 + \varepsilon_t) = a_0$  </li>
<li>方差 $\sigma^2$ 恒定，$\text{Var}(\Delta y_t) = \text{Var}(\varepsilon_t) = \sigma^2$</li>
<li>协方差仅由时间间隔决定。如果成立，对于滞后 $s \neq 0$ 协方差，仅与滞后阶数 s 有关，与具体时间 t 无关：<script type="math/tex">\text{cov}(\Delta y_t, \Delta y_{t-s}) = E[(\Delta y_t - a_0)(\Delta y_{t-s} - a_0)] = E(\varepsilon_t \varepsilon_{t-s}) = 0</script> 协方差为 0，与 $t$ 无关，表明序列无自相关（白噪声特性）。<br>我们可以将结论推广到带噪声的随机游走模型，如感兴趣可在教材 4.2.1 节查看具体证明。<h3 id="3-3-2-去除趋势"><a href="#3-3-2-去除趋势" class="headerlink" title="3.3.2 去除趋势"></a>3.3.2 去除趋势</h3>所有非平稳模型都能够通过差分转化为平稳的吗？答案是否定的。考虑下面这个模型：<script type="math/tex">y_t = y_0 + a_1 t + \varepsilon_t \quad \to \quad \Delta y_t = y_t - y_{t-1} = a_1 + \varepsilon_t - \varepsilon_{t-1}</script></li>
</ol>
<ul>
<li>差分后序列 $\Delta y<em>t$ 的表达式 $a_1 + \varepsilon_t - \varepsilon</em>{t-1}$ 是 MA (1) 过程。</li>
<li><strong>但其移动平均系数为 1，无法转换为 AR 形式，违背了可逆性条件</strong>。</li>
<li>关于可逆性，请回顾 <a href="#2.3.5.2%20可逆性"> 第 2.3.5.2 节</a> 关于可逆性的讨论。也就是，MA(1) 中 $\varepsilon_{t-1}$ 的系数应小于 1。</li>
</ul>
<p>怎么办？—— <strong>替代方法：回归去趋势</strong>。步骤：  </p>
<ol>
<li><strong>估计趋势项</strong>：用回归模型拟合趋势，例如： $Y_t = a_0 + a_1 t + a_2 t^2 + \cdots + a_n t^n + e_t$</li>
<li><strong>提取残差</strong>：计算残差序列 $e_t = y_t - \hat{y}_t$，其中 $\hat{y}_t$ 为趋势估计值。  </li>
<li><strong>分析平稳性</strong>：若残差序列 ${e_t}$ 平稳，可对其建立 ARMA 模型。<br>多项式恰当的阶数可以由标准 t 检验、F 检验和 AIC 或 SBC 统计量来确定。这一方法的优势是：避免差分导致的模型不可逆问题，直接分离趋势与平稳噪声。</li>
</ol>
<p>上面案例中的时间序列正是一个带有 <strong>单位根</strong> 的序列。在第 <a href="#2.3.3.1%20自相关函数（ACF）">2.3.3.1</a> 节中，我们曾剧透过：</p>
<ul>
<li><font color="#245bdb"> <b> 平稳时间序列 </b> 和 <b> 单位根非平稳时间序列 </b> 是值得研究的，而其他不平稳时间序列不常见也不值得研究。</font></li>
<li>我们在第 <a href="#Chapter%202%20平稳时间序列模型">2</a> 章已经介绍了平稳时间序列。什么是 <strong>单位根非平稳时间序列</strong> 呢？<blockquote>
<p>[!Note] <strong>什么是单位根？</strong><br> 带有 <strong>单位根</strong> 的序列，称为差分平稳 (difference stationary) 序列，可以通过差分转化为平稳序列。给定模型： <script type="math/tex">r_t = \phi_0 + \phi_1 r_{t-1} + a_t \qquad a_t \sim i.i.d</script><br>根据 $\phi_1$ 的取值，序列的平稳性可分为以下三类：</p>
<ol>
<li><strong>$|\phi_1| &lt; 1$：平稳时间序列</strong>  <ul>
<li><strong>平稳性条件</strong>：  </li>
<li>特征方程 $1 - \phi_1 B = 0$ 的根 $B =\dfrac{1}{\phi_1}$ 在单位圆外（ $|\phi_1| &lt; 1$，故 $|B| &gt; 1$）。  </li>
<li><strong>统计特性</strong>：  </li>
<li>均值收敛至 $\mu = \dfrac{\phi_0}{1 - \phi_1}$，  </li>
<li>方差恒定：$\text{var}(r_t) = \dfrac{\sigma_a^2}{1 - \phi_1^2}$，  </li>
<li>自相关系数（ACF）按几何速率衰减（如 $\rho_k = \phi_1^k$）。  </li>
<li><strong>示例</strong>：AR (1) 模型（如 $\phi_1 = 0.8$）。  </li>
</ul>
</li>
<li><strong>$|\phi_1| = 1$：单位根非平稳时间序列</strong>  <ul>
<li><strong>特性</strong>：</li>
<li>特征方程的根 $B =\dfrac{1}{\phi_1}$ 在单位圆上（因 $|\phi_1| = 1$），  </li>
<li>方差随时间线性增长：$\text{var}(r_t) = t \sigma_a^2$，  </li>
<li>自相关系数缓慢衰减（如 $\rho_k \approx \sqrt{1 - k/t}$）。  </li>
<li><strong>典型模型</strong>：随机游走 $r<em>t = r</em>{t-1} + a_t$（$\phi_1 = 1$）。  </li>
<li><strong>处理方法</strong>：通过一阶差分 $\Delta r_t = a_t$ 转为平稳序列。  </li>
</ul>
</li>
<li><strong>$|\phi_1| &gt; 1$：爆炸性非平稳时间序列</strong>  <ul>
<li><strong>特性</strong>：  <ul>
<li>特征方程的根 $B =\dfrac{1}{\phi_1}$ 在单位圆内（因 $|\phi_1| &gt; 1$），  </li>
<li>方差随时间指数增长，序列值迅速发散，无实际应用意义。  </li>
</ul>
</li>
<li><strong>示例</strong>：$\phi_1 = 1.2$ 时，序列呈爆炸性增长。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="3-4-样本平稳性检验"><a href="#3-4-样本平稳性检验" class="headerlink" title="3.4 样本平稳性检验"></a>3.4 样本平稳性检验</h2><p>当拿到一个时间序列后，应该如何对其进行平稳性的检验呢？目前，对时间序列的平稳性检验主要有两种方法：</p>
<ul>
<li>一种是图像法，即根据时序图和自相关图进行直观判断，</li>
<li>另一种是构造检验统计量进行单位根检验，有 ADF 检验、PP 检验和 KPSS 检验等方法。<br>检验观测数据平稳性时，通常假设观测数据是单位根非平稳的，而备择假设是观测数据是平稳的，因此 <strong>平稳性检验是单侧检验</strong>。<h3 id="3-4-1-图像法"><a href="#3-4-1-图像法" class="headerlink" title="3.4.1 图像法"></a>3.4.1 图像法</h3>在具体的假设检验之前，我们可以先将数据可视化，绘制时间序列的折线图，看曲线是否围绕某一数值上下波动（判断均值是否稳定）、曲线上下波动幅度变化大不大（判断方差是否稳定）、曲线不同时间段波动的频率变化大不大（判断协方差是否稳定），以此来判断时间序列是否平稳。<h4 id="3-4-1-1-迹图"><a href="#3-4-1-1-迹图" class="headerlink" title="3.4.1.1 迹图"></a>3.4.1.1 迹图</h4>迹图是待检验样本的时间图。<br><img src="迹图.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li>第一幅图，我们可以清楚地看到，均值随时间而变化，呈现上升的趋势。因此，这是一个非平稳序列。平稳序列不应该呈现出随时间变化的趋势。</li>
<li>第二幅图，我们看不到序列的趋势，但序列的变化幅度是一个时间的函数。平稳序列的方差必须是一个常数。</li>
<li>第三幅图，随着时间的增加，序列传播后变得更近，这意味着协方差是时间的函数。</li>
<li>所以上述三个例子均是非平稳时间序列。</li>
<li>第四幅图，均值、方差和协方差都是常数，这就是平稳时间序列。<h4 id="3-4-1-2-ACF-和-PACF-图"><a href="#3-4-1-2-ACF-和-PACF-图" class="headerlink" title="3.4.1.2 ACF 和 PACF 图"></a>3.4.1.2 ACF 和 PACF 图</h4>我们也可以绘制时间序列的自相关图和偏自相关图来了解序列平稳性。</li>
<li>平稳序列通常具有短期相关性，对于平稳的时间序列，自相关系数往往会迅速退化到零（滞后期越短相关性越高，滞后期为 0 时，相关性为 1）；</li>
<li>而对于非平稳的数据，退化会发生得更慢，或存在先减后增或者周期性的波动等变动。<br><img src="ACF和PACF确定平稳性.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li>白噪声的自相关系数很快就衰减到 0 附近，是明显的平稳序列。滞后期为 0 时自相关系数和偏自相关系数其实就是序列自己和自己的相关性，故为 1；滞后期为 1 时，自相关系数为 0，表示白噪声无自相关性。</li>
<li>随机游走，自相关系数下降非常缓慢，故为非平稳序列；另从偏自相关系数中可以看到随机游走只和前一项有关。</li>
<li>GDP 数据的自相关图中也可以看到存在一定的周期性，滞后 4、8、12 等自相关系数较大下降较慢，差分后下降多一些起到一定效果，认为差分后序列是平稳的。<h4 id="3-4-1-3-伪相关"><a href="#3-4-1-3-伪相关" class="headerlink" title="3.4.1.3 伪相关"></a>3.4.1.3 伪相关</h4>直观判断能让我们对数据有更直观的认识，但带有较强主观性。</li>
<li>在实践中，我们通常从探索数据开始，例如绘制并计算两个变量的相关性。</li>
<li>我们常常注意到变量之间的某些非常强的相关性。但是这些相关性可能是没有意义的。并没有因果关系来解释这些结果。这些都是虚假相关性。</li>
<li>具有潜在趋势的数据很可能产生虚假的相关性，例如碳排放量的上升和变暖的全球气温之间的相关性。</li>
<li>除了趋势之外，时间序列的其他一些共同特征也会引入虚假相关性。如：季节性：夏天热狗消费量和溺水死亡人数的相关性。</li>
<li>更多关于虚假相关性的例子，请见：<a target="_blank" rel="noopener" href="http://tylervigen.com/spurious-correlations">虚假相关性的例子</a><br>因此，我们需要经济直觉，也需要一些更严谨的假设检验。<h3 id="3-4-2-假设检验法"><a href="#3-4-2-假设检验法" class="headerlink" title="3.4.2 假设检验法"></a>3.4.2 假设检验法</h3>本节介绍平稳性的假设检验方法。一般认为现实中经济变量大多是趋势平稳过程或单位根过程，不太可能出现这种情形，因此，经济学家通常只考虑单位根检验，即检验序列中是否存在单位根，若存在，则为非平稳序列，不存在则为平稳序列。<h4 id="3-4-2-1-DF-检验和-ADF-检验"><a href="#3-4-2-1-DF-检验和-ADF-检验" class="headerlink" title="3.4.2.1 DF 检验和 ADF 检验"></a>3.4.2.1 DF 检验和 ADF 检验</h4>ADF 检验（Augmented Dickey-Fuller Testing）是最常用的单位根检验方法之一，通过检验序列是否存在单位根来判断序列是否是平稳的。ADF 检验是 DF 检验的增强版，在介绍 ADF 之前，我们先来看一下 DF 检验。</li>
</ul>
<ol>
<li><p><strong>DF 检验</strong></p>
<ul>
<li>Dickey &amp; Fuller(1979)提出的单位根检验方法</li>
<li>检验样本平稳性时，需要根据数据的本身的特征选择合适的形式。通常而言，单位根非平稳过程的表现形式有三种：<ul>
<li>(1) 当序列基本走势呈现无规则上升或下降并反复时，将其归为无漂移项自回归过程 $y<em>t =\rho y</em>{t−1} + \varepsilon_t$； </li>
<li>(2) 当序列基本走势呈现明显的随时间递增或递减且趋势并不太陡峭时，将其归为带漂移项自回归过程 $y<em>t =\mu+ \rho y</em>{t−1} +  \varepsilon_t$；</li>
<li>(3) 当序列基本走势随时间快速递增时，则将其归为带漂移项和趋势项的自回归过程 $y<em>t =\mu+\beta t+\rho y</em>{t−1} +  \varepsilon_t$。</li>
</ul>
</li>
<li>原假设 $H_0$ : $\rho = 1$ （存在单位根，时间序列是非平稳的）；备择假设 $H_0$ : $\rho &lt;1$  （不存在单位根，时间序列是平稳的）</li>
<li>对于带漂移项和趋势项的自回归过程，OLS 估计结果与 DF 统计量：<ul>
<li>初始条件 $y<em>0 = 0$，OLS 估计量 $\hat{\rho}$ 的表达式：  $$ \hat{\rho} = \frac{\sum</em>{t=1}^T y<em>t y</em>{t-1}}{\sum<em>{t=1}^T y</em>{t-1}^2} <script type="math/tex">标准误 $se (\hat{\rho})$ 的表达式：（其中 $\hat{\sigma}$ 为残差标准差估计值。）</script>se (\hat{\rho}) = \frac{\hat{\sigma}}{\sqrt{\sum<em>{t=1}^T y</em>{t-1}^2}}$$</li>
<li>基于 OLS 结果构造的统计量：  <script type="math/tex">T = \frac{\hat{\rho} - 1}{se (\hat{\rho})} = \frac{\sum_{t=1}^T \varepsilon_t y_{t-1}}{\hat{\sigma} \sqrt{\sum_{t=1}^T y_{t-1}^2}}</script> 该统计量称为 <strong>Dickey-Fuller (DF) 统计量</strong>。</li>
</ul>
</li>
<li>DF 统计量 <strong>不服从渐近正态分布</strong>，其临界值需通过 <strong>蒙特卡罗模拟</strong> 获得，而非传统 t 分布或正态分布表。</li>
<li>在存在截距项的情况下，Dickey 和 Fuller 发现：<ul>
<li>90%置信的估计值，偏离 $\rho = 1$ 的标准误为 2.58。</li>
<li>95%置信的估计值，偏离 $\rho = 1$ 的标准误为 2.89。</li>
<li>99%置信的估计值，偏离 $\rho = 1$ 的标准误为 3.51。<blockquote>
<p>[!note] 蒙特卡洛模拟<br>蒙特卡洛模拟是一种基于大数定理的数值计算方法，其核心思想是通过大量随机抽样逼近理论解。这样，我们无需解析解即可逼近真实分布。</p>
<p><strong>1. 基本原理与步骤</strong></p>
<ul>
<li><strong>大数定理</strong>：若生成独立同分布（i.i.d）的随机序列 ${v<em>i}$（均值为 $\mu$，方差为 $\sigma^2$），其样本均值 $\overline{v} = \frac{1}{T}\sum</em>{i=1}^T v_i$ 会随样本量 $T$ 增大而收敛于真实均值 $\mu$（如图可能显示 $\overline{v}$ 随 $T$ 增加逐渐稳定在 $\mu$ 附近）。</li>
<li><strong>中心极限定理</strong>：当 $T$ 足够大时，$\overline{v}$ 的分布趋近于正态分布 $N (\mu, \sigma^2/T)$（钟形曲线）。</li>
</ul>
<p><strong>2. 应用场景</strong></p>
<ul>
<li><strong>假设检验</strong>：DF 检验通过蒙特卡洛模拟生成临界值，判断时间序列是否存在单位根。</li>
<li><strong>小样本分析</strong>：在有限数据下，蒙特卡洛模拟数据生成过程，研究统计量的分布特性。</li>
</ul>
<p>更具体的操作过程，详见课本 4.4.3 部分。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ADF 检验</strong></p>
<ul>
<li>DF 的检验公式为一阶自回归过程，要求扰动项 $\varepsilon_t$ 无自相关。但扰动项经常呈现出自相关特征。</li>
<li>为了能适用于高阶自回归过程的平稳性检验，Dickey &amp; Fuller（1981）对 DF 检验进行了改进，<strong>引入了更高阶的滞后项来控制自相关特征</strong>。这就是 Augmented Dickey-Fuller 单位根检验，简称 ADF 检验。</li>
<li>给定适当的滞后期 p，使得 AR(p)的扰动项 $\varepsilon_t$ 为白噪声过程：<ul>
<li>(i) 无漂移项自回归过程：$y<em>{t}=\rho y</em>{t-1}+\sum<em>{i=1}^{k} \gamma_i \Delta y</em>{t-i}+\varepsilon_{t}$</li>
<li>(ii) 带漂移项自回归过程：$y<em>{t}=\mu+\rho y</em>{t-1}+\sum<em>{i=1}^{k} \gamma_i \Delta y</em>{t-i}+\varepsilon_{t}$</li>
<li>(iii) 带漂移项和趋势项自回归过程：$y<em>{t}=\mu+\beta t+\rho y</em>{t-1}+\sum<em>{i=1}^{k} \gamma_i \Delta y</em>{t-i}+\varepsilon<em>{t}$<br>其中 $\mu$ 是常数项，$\beta t$ 是时间趋势项，$\Delta y</em>{t-i}$ 是滞后差分项（lagged difference term）。$\varepsilon_{t}$ 为随机扰动项。</li>
</ul>
</li>
<li><strong>Problem 1：</strong> 无论是三种过程中的哪一个，我们要检验 AR (p) 模型是否存在单位根，只需检验 $y_{t-1}$ 的系数是否为 1。假设条件同 DF 检验一致：<ul>
<li>原假设 $H_0 : \rho = 1$ （存在单位根，时间序列是非平稳的） </li>
<li>备择假设 $H_1 : \rho &lt; 1$  （不存在单位根，时间序列是平稳的）。</li>
<li>使用 OLS 估计估计自回归过程，得到：$\hat{\rho}$ 和相应的 $t$ 统计量。 <script type="math/tex">t = \frac{\hat{\rho} - 1}{se(\hat{\rho})}</script> 该 $t$ 值被称为 ADF 统计量。类似的，临界值通过蒙特卡罗模拟得到。</li>
</ul>
</li>
<li><strong>Problem 2：</strong> 针对上述三种过程，不仅要确定数据序列是否存在单位根，即 $\hat{\rho}$ 是否显著异于 1，还要确定这三种过程哪种才是拟合数据生成过程的“最佳”形式。（即，考虑所用检验式是否应当包含时间趋势项、是否应当包含漂移项。）<ul>
<li>可以构造联合检验 F 统计量检验以选择模型 <script type="math/tex">\phi_i = \frac{(SSR(\text{约束}) - SSR(\text{无约束})) / r}{SSR(\text{无约束}) / (T - k)}</script> $SSR(\text{约束})$：约束模型的残差平方和；$SSR(\text{无约束})$：无约束模型的残差平方和；  $r$：约束条件的数量；$T$：样本量；$k$：无约束模型中的参数个数。  <blockquote>
<p>[!note] <strong>ADF 单位根检验案例</strong><br>检验目标：中国 1978-2003 年基本建设投资（lnI）<a target="_blank" rel="noopener" href="https://cstj.cqvip.com/Qikan/Article/Detail?id=23878297">参考来源：聂巧平和张晓峒，2007</a><br><strong>1. 检验是否含时间趋势项</strong>（式 3）</p>
<ul>
<li><p><strong>回归方程</strong>：  </p>
<script type="math/tex; mode=display">\Delta \ln I_t = 2.0759 - 0.3643 \ln I_{t-1} + 0.0665 t + 0.3662 \Delta \ln I_{t-1}</script><ul>
<li><strong>ADF 统计量</strong>：$\gamma$ 的 $t$ 值为 $-3.00$，5%临界值为 $-3.61$。  </li>
<li><strong>单位根检验结论</strong>：$-3.00 &gt; -3.61$，无法拒绝原假设（存在单位根）。</li>
</ul>
</li>
<li><p><strong>时间趋势项检验（$\delta = \gamma = 0$）</strong>：  </p>
<ul>
<li><strong>统计量</strong>：$\phi_3 = 4.8305$，临界值 $CV = 7.1707$。临界值计算需通过响应面函数 $CV = a + b/T + c/T^2$ 调整样本容量影响（本例 $T = 26$）。    </li>
<li><strong>结论</strong>：$4.8305 &lt; 7.1707$，不拒绝原假设，<strong>剔除时间趋势项</strong>。</li>
</ul>
</li>
</ul>
<p><strong>2. 检验漂移项（式 2）</strong></p>
<ul>
<li><p><strong>回归方程</strong>：  </p>
<script type="math/tex; mode=display">\begin{split}\Delta \ln I_t =& 0.0709 - 0.0131 \ln I_{t-1} + 0.3401 \Delta \ln I_{t-1} + 0.0828 \Delta \ln I_{t-2} \\&- 0.0562 \Delta \ln I_{t-3} - 0.4161 \Delta \ln I_{t-4}\end{split}</script><ul>
<li><strong>ADF 统计量</strong>：$\gamma$ 的 $t$ 值为 $-0.61$，5%临界值为 $-3.01$。  </li>
<li><strong>单位根检验结论</strong>：$-0.61 &gt; -3.01$，仍无法拒绝单位根原假设。</li>
</ul>
</li>
<li><p><strong>漂移项检验（$\alpha = \gamma = 0$）</strong>：  </p>
<ul>
<li><strong>统计量</strong>：$\phi_1 = 5.6193$，临界值 $CV = 5.1537$。  </li>
<li><strong>结论</strong>：$5.6193 &gt; 5.1537$，拒绝原假设，<strong>需保留漂移项</strong>。</li>
</ul>
</li>
</ul>
<p><strong>最终结论</strong>：</p>
<ul>
<li><strong>检验式选择</strong>：采用检验式 2（含漂移项，无时间趋势项）。  </li>
<li><strong>单位根判断</strong>：$\gamma$ 的 $t$ 值为 $-0.61$，与标准正态分布临界值 $-1.96$（5%水平）比较。  </li>
<li><strong>结论</strong>：$-0.61 &gt; -1.96$，无法拒绝 $\gamma = 0$，<strong>序列 $\ln I$ 为单位根过程</strong>。</li>
<li><strong>检验逻辑</strong>：先检验高阶项（时间趋势），再逐步简化模型，避免过度参数化。  <h4 id="3-4-2-2-PP-检验"><a href="#3-4-2-2-PP-检验" class="headerlink" title="3.4.2.2 PP 检验"></a>3.4.2.2 PP 检验</h4></li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>为了解决 DF 检验中残差项中潜在的序列相关和异方差问题</strong>，Phillips 和 Perron (1988) 提出一种非参数检验方法——Phillips-Perron 单位根检验（简称 PP 检验）。该方法使用 New-West 标准误对 DF 统计量进行修正：</li>
<li>原假设 $H_0 : \rho = 1$ （存在单位根，时间序列是非平稳的） 备择假设 $H_1 : \rho &lt; 1$  （不存在单位根，时间序列是平稳的）。</li>
<li>PP 检验的 $t$ 统计量渐近分布与 ADF 检验统计量相同，因而临界值也相同、也是左边单侧检验, 可作为 ADF 检验的补充。</li>
<li>PP 检验须指定用于计算 Newey-West 标准误的滞后阶数，默认值为 $4(\frac{T}{100})^\frac{2}{9}$。<h4 id="3-4-2-3-KPSS-检验"><a href="#3-4-2-3-KPSS-检验" class="headerlink" title="3.4.2.3 KPSS 检验"></a>3.4.2.3 KPSS 检验</h4></li>
<li>另一种单位根检验是 Kwiatkowski, Phillips, and Shin 在 1992 年提出的 KPSS 检验。</li>
<li>与以上检验方法相比，最大的不同点：<b> <font color="#245bdb"> KPSS 检验的原假设是平稳序列或趋势平稳序列，而备择假设是存在单位根。</font> </b></li>
<li>原假设：序列不存在单位根（时间序列是平稳的或趋势平稳的） </li>
<li>备择假设：序列存在单位根（时间序列是非平稳的）</li>
<li>假设时间序列 $y<em>t$ 可以分解为时间趋势、随机游走和平稳过程之和，即 $$y_t = \delta t + u_t + \varepsilon_t \quad  , \quad u_t = u</em>{t-1} + v_t \quad v_t \sim WN(0, \sigma_v^2)$$ 原假设 $H_0$：$\sigma_v^2 = 0$，即趋势平稳。备择假设 $H_1$：$\sigma_v^2 &gt; 0$，即不平稳。<h2 id="3-5-单位根检验的进阶方法"><a href="#3-5-单位根检验的进阶方法" class="headerlink" title="3.5 单位根检验的进阶方法"></a>3.5 单位根检验的进阶方法</h2>上一节介绍了一系列常见的单位根检验方法。这些检验中均不能 100%保证检验正确，请注意，ADF 检验的前提条件是没有异方差；PP 检验适用于异方差场合，可认为是 ADF 检验的补充；KPSS 检验不需要选择趋势类型，因而更具鲁棒性，同样也可和其他检验一同使用，当均认为是平稳或趋势平稳时方判定为平稳。</li>
</ul>
<p>事实上，这些方法都是非季节性时间序列单位根检验方法，并不是全部方法。总体而言，单位根检验方法分为 5 类，即：</p>
<ol>
<li>非季节性时间序列单位根检验：DF 检验、ADF 检验、WS 检验、RMA 检验、PP 检验、KPSS 检验、ERS 点检验、NP 检验。</li>
<li>季节时间序列的单位根检验：DHF 检验、HEGY 检验、Kunst 检验</li>
<li>退势单位根检验：GLS 退势检验、KGLS 退势检验、ROLS 退势检验。<strong>时间序列的退势是指从原时间序列中分离出确定性线性趋势项或周期性趋势项的处理过程。</strong></li>
<li>结构突变序列的单位根检验：Perron 检验、Zivot-Andrews 方法、BLS 检验、递归检验、滚动检验、循序检验</li>
<li>面板数据的单位根检验：Quah 检验、LLC 检验、IPS 检验、崔仁检验、MW 检验、Bai-Ng 检验、 Hadri 检验、Breitung 检验。<br>关于平稳性检验的代码实现，请参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/425664064">Python 实现</a>，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kisen/p/12587862.html">R 实现</a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/687947331">Stata 实现</a><h4 id="3-5-1-有效性问题与退势单位根检验"><a href="#3-5-1-有效性问题与退势单位根检验" class="headerlink" title="3.5.1 有效性问题与退势单位根检验"></a>3.5.1 有效性问题与退势单位根检验</h4><h5 id="3-5-1-1-有效性问题"><a href="#3-5-1-1-有效性问题" class="headerlink" title="3.5.1.1 有效性问题"></a>3.5.1.1 有效性问题</h5></li>
</ol>
<ul>
<li>通常一种检验的有效性 (power) 在于拒绝一个错误的原假设的可能性。当问题中的序列平稳时，一个有效的检验将会拒绝存在单位根的原假设。</li>
<li>蒙特卡洛试验已经证明，各种 DF 检验的有效性都较差。因此，这些检验往往显示序列存在单位根。而且它们在区分趋势平稳和漂移过程的时候有效性也很低。</li>
<li>怎么解决这个问题？有没有更好的办法？</li>
<li>一个重要的方法是对 DF 检验进行变形来提高有效性。下面我们就介绍两种【退势】的方法——LM 检验和 DF-GLS 检验（又叫 ERS 检验），经过去除趋势的操作，变形后的 DF 检验会更有效。<h5 id="3-5-1-2-LM-检验"><a href="#3-5-1-2-LM-检验" class="headerlink" title="3.5.1.2 LM 检验"></a>3.5.1.2 LM 检验</h5><ul>
<li>Schmidt 和 Phillips (1992) 提出了比 DF 检验更具有效性的 <strong>两步检验法</strong>——拉格朗日乘子 (Lagrange Multiplier，LM) 检验</li>
<li>LM 检验关键点是，不用持久性很强的解释变量 $y_{t-1}$ 的模型，估计趋势参数会更有效。如果能够有效地估计出趋势，那么就有可能剔除数据趋势，并在已剔除趋势的数据上进行单位根检验。</li>
<li><strong>原假设：序列存在单位根；备择假设：时间序列是平稳的或趋势平稳的</strong><blockquote>
<p>[!note]  LM 检验<br> <strong>LM 检验第一步：构建去除趋势的序列</strong></p>
<ul>
<li>与 DF 检验的设定不同，${y<em>t}$ 序列在原假设下是一个带漂移的随机游走过程，因此 $$ y_t = a_0 + a_2 t + \sum</em>{i=0}^{t-1} \varepsilon_{t-i} \quad \to \quad \Delta y_t = a_2 + \varepsilon_t$$</li>
<li>这种检验方法的思想在于使用回归方程 $\Delta y_t = a_2 + \varepsilon_t$ 估计趋势系数 $a_2$。因此，随机趋势 $\Sigma \varepsilon_i$ 的存在并不影响对 $a_2$ 的估计。</li>
<li>估计结果 $\hat{a}_2$ 是关于时间趋势斜率的估计。使用 $\hat{a}_2$ 构建去除趋势的序列： <script type="math/tex">y^d_t = y_t - (y_1 - \hat{a}_2) - \hat{a}_2 t</script> 其中，$y_1$ 为序列 ${y_t}$ 初始值。请注意，当 $t=1$ 时，确定性部分为 $y_1 = a_0 + a_2$。</li>
<li>因此，被估计的趋势线的截距为 $(y_1 - \hat{a}_2)$，斜率为 $\hat{a}_2$。这样做保证了去除趋势的序列（即 $y^d_t$）的初始值为零。</li>
</ul>
<p><strong>LM 检验第二步：使用去趋势序列替代</strong></p>
<ul>
<li>在 DF 检验方程的 $y<em>{t-1}$ 处用去除趋势的序列 $y^d</em>{t-1}$ 替代，估计变形的 DF 检验方程 <script type="math/tex">\Delta y_t = c_0 + \gamma y^d_{t-1} + \epsilon_t</script></li>
<li>如果残差中存在序列相关，则估计方程 <script type="math/tex">\Delta y_t = c_0 + \gamma y^d_{t-1} + \sum_{i=1}^{p} \beta_i \Delta y^d_{t-i} + \epsilon_t</script></li>
<li>如果得到 $\gamma \neq 0$，则拒绝存在单位根的原假设。<h5 id="3-5-1-3-DF-GLS-检验（ERS-检验）"><a href="#3-5-1-3-DF-GLS-检验（ERS-检验）" class="headerlink" title="3.5.1.3 DF-GLS 检验（ERS 检验）"></a>3.5.1.3 DF-GLS 检验（ERS 检验）</h5></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>DF-GLS 检验，是 Elliott, Rothenberg, and Stock 在 1996 年提出的一种单位根检验方法，全称 Dickey-Fuller Test with GLS Detredding，即“使用广义最小二乘法去除趋势的检验”；模拟试验证明 DF-GLS 检验有效性更强。</li>
<li>原假设：序列存在单位根（时间序列是非平稳的）</li>
<li>备择假设：序列不存在单位根（时间序列是平稳的或趋势平稳的）</li>
<li><strong>DF-GLS 检验的做法</strong><ul>
<li>利用广义最小二乘法，首先对要检验的数据进行一次“准差分”，</li>
<li>然后利用准差分的数据对原序列进行去除趋势处理，</li>
<li>再利用 ADF 检验的模型形式对去除趋势后的数据进行单位根检验，但此时 ADF 检验模型中不再包含常数项或者时间趋势变量。<blockquote>
<p>[!Note] DF-GLS 检验的做法<br> 考虑趋势平稳(TS)模型： $y_t=a_0+a_2t+B(L)\varepsilon_t$</p>
<ol>
<li><strong>消除趋势</strong><br>为消除 $y<em>t$ 的趋势，事先选择接近 1 的常数 $\alpha$ 进行近似差分变换 $$\widetilde{y}_t = y_t-\alpha y</em>{t - 1} \quad (t = 2,\cdots,T) \quad \to \quad \widetilde{y}_t=(1 - \alpha)a_0+a_2[(1 - \alpha)t+\alpha]+e_t<script type="math/tex">其中， $t = 1$ 时 $\widetilde{y}_1$ 设定等于 $y_1$。运行这一最小二乘估计，得到估计系数 $\hat{a}_0$ 和 $\hat{a}_2$  ，进而得到去除趋势的序列</script>y_t^d=y_t-\hat{a}_0-\hat{a}_2t$$ </li>
<li><strong>使用去趋势序列估计 DF 检验</strong><ul>
<li>使用去趋势数据估计基本 DF 检验回归方程 <script type="math/tex">\Delta y_t^d=\gamma y_{t - 1}^d+\varepsilon_t</script></li>
<li>若残差存在序列相关，估计扩展形式 <script type="math/tex">\Delta y_t^d=\gamma y_{t - 1}^d+\sum_{i = 1}^{p}c_i\Delta y_{t - i}^d+\varepsilon_t</script> </li>
<li><strong>滞后期 $p$ 的选择</strong>： ERS 的建议是使用 SBC 准则选取 p。</li>
</ul>
</li>
</ol>
<ol>
<li><strong>假设检验</strong>：根据 $\gamma$ 是否为 0 判断能否拒绝存在单位根的原假设。 <ul>
<li><strong>临界值确定依据</strong>：检验临界值依赖于数据中是否含有趋势。</li>
<li>存在截距无趋势时，临界值取 DF 的 $\tau$ 检验对应值；存在趋势时，临界值取决于“近似差分”时 $\alpha$ 的选择值。</li>
<li>对于存在截距情形，$\alpha=(1-\frac{7}{T})$ ；存在截距和趋势情形，$\alpha=(1 - \frac{13.5}{T})$ 。样本容量 $T$ 增加时，$\alpha$ 趋于 1 ，$\widetilde{y}_t$ 近似于 $\Delta y_t$ 。<h3 id="3-5-2-结构突变的-Perron-单位根检验"><a href="#3-5-2-结构突变的-Perron-单位根检验" class="headerlink" title="3.5.2 结构突变的 Perron 单位根检验"></a>3.5.2 结构突变的 Perron 单位根检验</h3></li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>自从 DF 检验、ADF 检验以及 PP 检验被提出以来，有关单位根检验的各种方法和应用研究不断地刊登在主流学术期刊上。然而，经典的单位根分析框架中并没有考虑真实数据的外部因素或自我调整因素引起的结构性变化。</li>
<li><b> <font color="#245bdb">“佩伦现象”</font> </b>：在进行单位根检验时，当存在结构性变化时，DF 检验将更倾向于接受存在单位根的原假设。（容易将具有结构突变的平稳过程误判为单位根过程）。 <a target="_blank" rel="noopener" href="https://www.shangyexinzhi.com/article/3214717.html">相关综述</a> </li>
<li>怎么解决“佩伦现象”？<ol>
<li>分样本 DF 检验<ul>
<li>不足：每个回归部分的自由度减少了，并且可能并不知道断点何时出现</li>
<li>因此，对整个样本进行一次性的检验更恰当。</li>
</ul>
</li>
<li><strong>Perron 检验</strong><ul>
<li>Perron(1989)扩展了用于在 $t=\tau+1$ 期存在结构性变化时检验单位根的方法。</li>
<li>需要考虑的核心问题：结构突变的影响？存在一次性跳跃</li>
<li><strong>原假设：</strong> 序列存在单位根；<script type="math/tex">y_t = \mu + y_{t-1} + \lambda_1 D_p + \varepsilon_t</script></li>
<li><strong>备择假设</strong>： 序列趋势平稳（趋势项 0 时为平稳过程）<script type="math/tex">y_t = \mu +  \beta t  + \lambda_2 D_L + \varepsilon_t</script><ul>
<li>$D_p$ 是脉冲虚拟变量（Pulse）；当 $t=τ+1$ 时，$D_P$ = 1，否则为 0；</li>
<li>$D_L$ 是水平虚拟变量（Level）；当 $t≥τ+1$ 时，$D_L$ = 1，否则为 0。</li>
<li>在原假设下，序列是一个单位根过程，并且在时期 $t=\tau+1$ 时，序列在原有水平上有一个一次性跳跃。</li>
<li>在备择假设下，序列趋势平稳，截距项有一个一次性跳跃。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="https://files.mdnice.com/user/77043/c17a3699-778e-4aac-b1f2-a0908f4df17f.png" srcset="/img/loading.gif" lazyload alt="结构性突变的单位根检验"></p>
<blockquote>
<p>[!Tip] Perron 检验的步骤<br><strong><font color="#245bdb"> 在 $t=\tau+1$ 期存在结构性变化时，单位根 Perron 检验步骤：</font></strong></p>
<ol>
<li><p><strong>第一步：构建回归方程并估计</strong></p>
<ul>
<li>将原假设（存在单位根且有结构性变化）与备择假设（趋势平稳且有结构性变化）结合为一个回归方程，常见形式为：<script type="math/tex">y_t = c_0 +  \beta t +\rho y_{t-1} + \mu_1 D_p + \mu_2 D_L + \varepsilon_t</script></li>
<li>$D<em>{P}$ 为脉冲虚拟变量（$t = \tau + 1$ 时，$D</em>{P} = 1$，否则为 0）；</li>
<li>$D<em>{L}$ 为水平虚拟变量（$t &gt; \tau$ 时，$D</em>{L} =1$，否则为 0）。</li>
<li>使用 OLS 估计该方程，得到残差 $\hat{\varepsilon_t}$。</li>
</ul>
<ol>
<li><strong>第二步：对残差进行诊断性检验</strong></li>
</ol>
<ul>
<li>对估计方程的残差进行诊断，检查是否存在序列相关。</li>
<li>怎么检验？请回顾 <a href="#2.3.5.1%20白噪声检验">2.3.5.1 白噪声检验</a>。实操可参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/547614582">用 Stata 做白噪声检验</a></li>
</ul>
<ol>
<li><strong>第三步：残差自回归估计</strong></li>
</ol>
<ul>
<li>若不存在序列相关：使用 OLS 方法对残差项 $\hat{\varepsilon}<em>t$ 进行自回归估计。$$ \hat{\varepsilon}_t = \rho \hat{\varepsilon}</em>{t-1} + v_t$$</li>
<li>若存在序列相关，则需要消除序列相关。残差的序列相关本质上反映原方程遗漏了相关项，需从原方程层面进行调整。第一步的回归方程改为 <script type="math/tex">y_{i} = c_0 + \beta t  + \rho y_{i - 1} + \mu_{1}D_{p} + \mu_{2}D_{L} + \sum_{i = 1}^{p}\beta_{i}\Delta y_{t - i} + \varepsilon_{t}</script></li>
<li>Perron 检验就是针对 $\rho$ 的检验。若原序列存在单位根，则应不显著异于 1。</li>
</ul>
</li>
<li><p><strong>第四步：计算统计量并检验</strong></p>
<ul>
<li>计算原假设 $\rho = 1$ 的 $t$ 统计量：<script type="math/tex">t_{\rho} = \frac{\rho - 1}{sd(\rho)}</script></li>
<li>将该统计量与 Perron 计算的临界值比较。若 $|t_{a_1}|$ 大于临界值，拒绝原假设（序列是发生结构性变化的趋势平稳过程）；若小于临界值，接受原假设（序列是发生结构性变化的单位根过程）。</li>
<li>怎么获得临界值？<ul>
<li>定义 $\lambda = \dfrac{\tau}{T}$，期中 $\tau$ 为冲击点前样本数，$T$ 为总样本数</li>
<li>若残差独立同分布，$\rho$ 的分布与 $\lambda$ 相关。Perron 根据不同 $\lambda$ 模拟了临界值，例如在 5% 显著水平下，不同 $\lambda$ 区间对应不同临界值。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>【拓展】Perron（<a target="_blank" rel="noopener" href="https://www.jstor.org/stable/1913712?seq=1">1989，ECMA</a>）将序列受到冲击后发生的结构性变化分为三类：</p>
<pre><code class="hljs"> - A：冲击前后序列的水平（序列均值）发生变化，但斜率不变；
 - B：冲击前后序列的斜率发生变化，但水平未变化；
 - C：冲击前后序列的水平和系列均发生了变化。
 - 对于三种情况的分别讨论，请参考 [三类结构性变化的详细讨论](https://zhuanlan.zhihu.com/p/563632525)。
</code></pre><p> 关于 Perron 检验的代码，请参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/563632525">R 语言实现</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/603543837">Stata 实现</a>。</p>
</blockquote>
<h3 id="3-5-3-面板数据的-IPS-单位根检验"><a href="#3-5-3-面板数据的-IPS-单位根检验" class="headerlink" title="3.5.3 面板数据的 IPS 单位根检验"></a>3.5.3 面板数据的 IPS 单位根检验</h3><ul>
<li>当存在许多类似的时间序列变量（面板数据）时，Im，Pesaran 和 Shin (2002) 提出了一种构造单位根检验的方法，简称 IPS 检验。</li>
<li>假设我们有 n 个序列，每个序列包含 T 个观测样本值。对于每个序列构建 ADF 检验形式：<script type="math/tex">\begin{split} y_{it} =& a_{i0} + \rho_i y_{it-1} + a_{i2} t + \sum_{j=1}^{p_i} \beta_{ij} \Delta y_{it-j} + \varepsilon_{it} \\\Downarrow \\ \Delta y_{it}= y_{it}-y_{it-1}=&a_{i0} + (\rho_i-1) y_{it-1} + a_{i2} t + \sum_{j=1}^{p_i} \beta_{ij} \Delta y_{it-j} + \varepsilon_{it}\\ =&a_{i0} + \gamma_i y_{it-1} + a_{i2} t + \sum_{j=1}^{p_i} \beta_{ij} \Delta y_{it-j} + \varepsilon_{it}\end{split}</script> 其中 $\gamma_i=\rho_i-1$ 。在 Panel 单位根检验中，原假设应该是：<ul>
<li>$H_0$：所有个体的时间序列都有单位根，即所有时间序列都是非平稳的。因此： <script type="math/tex">\rho_1=\rho_2=⋯=\rho_n=1 \to \gamma_1=\gamma_2=⋯=\gamma_n=0</script></li>
<li>$H_1$：至少有一个个体的时间序列是平稳的，即不存在单位根。拒绝原假设意味着 $\gamma_i$ 中至少有一个不为零。<br>在单独序列检验时，我们只要估计 $\gamma$，就可得到每个序列的 $t$ 统计量。</li>
</ul>
</li>
<li><strong>请思考：推广到面板数据，应该怎么检验呢？</strong></li>
<li><strong>IPS 检验通过结合每个个体的 ADF 检验的 t 值来构造一个综合的统计量</strong>。<ul>
<li>如果计算出的综合统计量对应的 p 值小于显著性水平（如 0.05），则拒绝原假设，认为至少有一个个体是平稳的。</li>
<li>反之，如果不能拒绝原假设，则认为所有个体都是非平稳的。</li>
<li>因此，可以通过把每个序列的 $t$ 统计量的取样本均值得到平均的 t 值 <script type="math/tex">\bar{t} = \left( \frac{1}{n} \right) \sum_{i=1}^{n} t_i</script> 从而构造 Z 统计量检验 <script type="math/tex">Z_\bar{t} = \frac{\bar{t} - E(\bar{t})}{\sqrt{\dfrac{\text{var}(\bar{t})}{n}}} \sim Normal</script> 式中，$E_i$ 和 $\text{var}(\bar{t})$ 表示 $\bar{t}$ 的理论均值和方差。如果各个检验的 $t_i$ 的 OLS 估计是无偏的，则 $E_i$ 的值为零。</li>
<li>为了修正事实存在的偏移，$E_i$ 和  $\text{var}(\bar{t})$ 的值可通过蒙特卡洛模拟计算。<blockquote>
<p>[!tip] 面板单位根检验的局限性（了解）</p>
<ol>
<li><p><strong>原假设的模糊性与结果敏感性</strong>  </p>
<ul>
<li><strong>原假设设定</strong>：IPS 检验的原假设为所有个体的自回归系数增量满足 $\gamma_1 = \gamma_2 = \cdots = \gamma_n = 0$（即 $\rho_i = 1$，存在单位根）。  </li>
<li>IPS 检验中，可能因为 $\gamma_i$ 中一个或两个值不为零而拒绝原假设。但没有特殊的方法可以知道 $\gamma_i$ 中的哪些值不为零。可能因少数平稳序列的存在而得出整体拒绝原假设的结论，掩盖其他个体的非平稳性。</li>
</ul>
</li>
<li><p><strong>对小样本不准确</strong>  </p>
<ul>
<li>检验的渐近性质对时间维度（$T$）和截面维度（$n$）的增长方式敏感：例如，对于小 $T$ 和大 $n$，临界值依赖于滞后项系数（如 $\beta_{ij}$）。  </li>
</ul>
</li>
<li><p><strong>误差项相关性与修正方法的不足</strong>  </p>
<ul>
<li><strong>序列相关与周期相关</strong>：检验要求误差项 $\epsilon_{it}$ 无自相关和跨期相关，但：  <ul>
<li>滞后阶数 $p<em>i$ 的选择可能无法完全消除自相关（$E</em>{e_{it}} \neq 0$）。  </li>
<li>截面相关性（个体间误差相关）会导致临界值失效。  </li>
</ul>
</li>
<li><strong>修正方法的局限性</strong>：  <ul>
<li>减去共同时间效应（如时间虚拟变量）可部分修正，但无法彻底解决。  </li>
<li>修正可能引入新的非平稳问题（如 $|\bar{\gamma}_i|$ 的非平稳性），影响检验可靠性。<h2 id="3-6-ARIMA-模型与滤波器"><a href="#3-6-ARIMA-模型与滤波器" class="headerlink" title="3.6 ARIMA 模型与滤波器"></a>3.6 ARIMA 模型与滤波器</h2><h3 id="3-6-1-ARIMA"><a href="#3-6-1-ARIMA" class="headerlink" title="3.6.1 ARIMA"></a>3.6.1 ARIMA</h3>前面我们已经学习了单位根过程和单位根的检验，事实上，单位根过程对应了 ARIMA(𝑝, 1, 𝑞) 模型。</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>ARIMA (AutoRegressive Integrated Moving Average) 在 ARMA 的基础上引入差分（Integration），模型表示为 ARIMA(p, d, q)。其中 d 为 <strong>差分阶数</strong>（将非平稳序列转换为平稳序列所需的差分次数）</li>
<li>ARMA（自回归移动平均模型）和 ARIMA（差分自回归移动平均模型）的核心区别在于 <strong>是否处理非平稳数据</strong>。ARIMA 适用于非平稳时间序列（通过差分消除趋势或季节性，得到平稳序列，再使用 ARMA (p, q) 建模）。</li>
<li><strong>如何使用 ARIMA 模型？</strong> <ol>
<li>检验平稳性：使用 ADF 检验或观察自相关图（ACF）。<ul>
<li>若平稳 → 直接使用 ARMA。</li>
<li>若非平稳 → 使用 ARIMA，并通过差分转换为平稳序列。</li>
</ul>
</li>
<li>确定差分阶数 d： 通常从 d = 1 开始，逐步增加直至序列平稳。</li>
<li>参数调优：通过 AIC/BIC 准则选择最优的 p 和  q，估计去趋势后的 ARMA 模型。<h3 id="3-6-2-Beveridge-Nelson-分解去趋势"><a href="#3-6-2-Beveridge-Nelson-分解去趋势" class="headerlink" title="3.6.2 Beveridge-Nelson 分解去趋势"></a>3.6.2 Beveridge-Nelson 分解去趋势</h3>为了将数据分解为随机趋势和平稳周期，我们可以采用 Beveridge-Nelson 分解法。</li>
</ol>
</li>
<li>Beveridge-Nelson（1981）提出将 <strong>非平稳时间序列</strong>（如 ARIMA 模型）分解为 <strong>随机趋势成分</strong>（带漂移的随机游走）和 <strong>平稳成分</strong>（无规则波动）。</li>
<li>其核心是通过长期预测函数识别趋势，剩余部分即为平稳成分。</li>
<li>当采用这种技术时，我们需要指定与平稳部分有关的滞后期的数量。<blockquote>
<p>[!note] Beveridge-Nelson 分解步骤（略）<br><strong>步骤 1：估计 ARIMA 模型</strong> </p>
<ul>
<li>对 ARIMA (p, 1, q)原始序列 $y_t$ 进行 1 阶差分，得到平稳的差分序列 $\Delta y_t$。 </li>
<li>使用 Box-Jenkins 方法拟合最优 ARMA (p, q) 模型，例如： <script type="math/tex">\Delta y_t = a_0 + \varepsilon_t + \beta_1 \varepsilon_{t-1} + \beta_2 \varepsilon_{t-2} + \cdots + \beta_q \varepsilon_{t-q}</script></li>
</ul>
<p><strong>步骤 2：构造预测函数</strong>  </p>
<ol>
<li><p><strong>计算多步预测值</strong><br>对差分后的平稳序列 $\Delta y<em>t$（服从 ARMA (p, q)），在时刻 $t$ 预测未来 $s$ 步的差分值：$$E_t[\Delta y</em>{t+1}], \, E<em>t[\Delta y</em>{t+2}], \, \dots, \, E<em>t[\Delta y</em>{t+s}]$$</p>
<ul>
<li><strong>短期预测</strong>：前 $q$ 步预测受移动平均（MA）项影响。例如，对 $\Delta y<em>{t+1}$ 的预测为： $$  E_t[\Delta y</em>{t+1}] = a<em>0 + \beta_1 \varepsilon_t + \beta_2 \varepsilon</em>{t-1} + \dots + \beta<em>q \varepsilon</em>{t-q+1}  $$</li>
<li><strong>长期预测</strong>：当 $s &gt; q$ 时，MA 项的影响消失，预测值仅由常数项 $a<em>0$ 主导： $$  E_t[\Delta y</em>{t+s}] = a_0 \quad (s &gt; q) $$ </li>
</ul>
</li>
<li><p><strong>预测值的长期极限</strong></p>
<ul>
<li>将未来 $s$ 步预测值累加，得到 $y<em>{t+s}$ 的预测：$$E_t[y</em>{t+s}] = y<em>t + \sum</em>{k=1}^s E<em>t[\Delta y</em>{t+k}]$$</li>
<li>当 $s \to \infty$ 时，累加和分解为两部分：</li>
<li><strong>确定性趋势</strong>：由常数项 $a_0$ 的累积构成，即 $a_0 \cdot s$。</li>
<li><strong>随机趋势</strong>：由历史冲击 ${\varepsilon<em>t, \varepsilon</em>{t-1}, \dots}$ 的长期影响构成，形式为： <script type="math/tex">\mu_t = \psi(1) \sum_{j=0}^\infty \varepsilon_{t-j}</script> 其中 $\psi(1) = 1 + \beta_1 + \beta_2 + \dots + \beta_q$ 是移动平均系数的累积效应。</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>随机趋势的显式构造</strong><br>随机趋势 $\mu<em>t$ 是历史冲击的加权和，权重为 $\psi(1)$，反映了每个冲击的影响：$$\mu_t = y_t + \sum</em>{j=0}^{q-1} \left( \sum<em>{i=j+1}^q \beta_i \right) \varepsilon</em>{t-j}$$</p>
<ul>
<li><strong>示例</strong>：若 $\Delta y<em>t$ 是 MA (2) 过程，则：  $$  \mu_t = y_t + (\beta_1 + \beta_2)\varepsilon_t + \beta_2 \varepsilon</em>{t-1}  $$</li>
</ul>
</li>
<li><p><strong>B-N 分解的组成</strong></p>
<ul>
<li><strong>确定性趋势</strong>：斜率 $a_0$ 的线性项 $a_0 \cdot t$，代表序列的长期增长趋势。</li>
<li><strong>随机趋势</strong>：$\mu<em>t$ 是一个随机游走过程，增量受冲击 $\varepsilon_t$ 驱动，即：  $$  \mu_t = \mu</em>{t-1} + a_0 + \psi(1)\varepsilon_t  $$</li>
<li><strong>平稳成分</strong>：原始序列与趋势的残差，即 $y_t - \mu_t$，为有限阶 MA 过程，例如 MA (q-1)。</li>
</ul>
</li>
</ol>
<p><strong>步骤 3：分离平稳成分</strong> </p>
<ul>
<li>平稳成分（无规则波动）为原始序列减去随机趋势：<script type="math/tex">\text{平稳成分} = y_t - \mu_t = -\left ( \sum_{i=1}^\infty \beta_i \right) \varepsilon_t - \left ( \sum_{i=1}^\infty \beta_i \right) \varepsilon_{t-1} - \cdots</script>   <script type="math/tex">Y_t - \mu_t = -(\beta_1 + \beta_2) \varepsilon_t - \beta_2 \varepsilon_{t-1}</script><h3 id="3-6-3-Hodrick-Prescott-去趋势"><a href="#3-6-3-Hodrick-Prescott-去趋势" class="headerlink" title="3.6.3 Hodrick-Prescott 去趋势"></a>3.6.3 Hodrick-Prescott 去趋势</h3></li>
</ul>
</blockquote>
</li>
</ul>
<ol>
<li>基本原理与步骤<br>HP 分解通过最小化目标函数，将时间序列 $y_t$ 分解为趋势成分 $\mu_t$ 和平稳成分 $y_t - \mu_t$：<script type="math/tex; mode=display">\min_{\{\mu_t\}} \left[ \frac{1}{T} \sum_{t=1}^T (y_t - \mu_t)^2 + \frac{\lambda}{T} \sum_{t=2}^{T-1} \left[ (\mu_{t+1} - \mu_t) - (\mu_t - \mu_{t-1}) \right]^2 \right]</script><ul>
<li>这个公式看上去很复杂！Hint：拉格朗日乘子法</li>
<li><strong>第一项</strong>：衡量趋势对原始序列的拟合程度（残差平方和）。</li>
<li><strong>第二项</strong>：惩罚趋势的二阶差分（即趋势的曲率），迫使趋势平滑。</li>
<li><strong>参数 $\lambda$</strong>：控制平滑程度。它是主观确定的常量，反映趋势中包含波动的惩罚。<ul>
<li>$\lambda \to 0$：当 $y_t=\mu_t$ 平方和最小，趋势为序列本身。</li>
<li>$\lambda \to \infty$：第二项更加重要，所以平方和最小时 $\mu<em>{t+1}-\mu_t=\mu_t-\mu</em>{t-1}$，这样，趋势变化恒定，退化为线性时间趋势。</li>
<li>$0 &lt; \lambda &lt; \infty$：允许趋势缓慢变化，适应长期波动。</li>
</ul>
</li>
</ul>
</li>
<li>优点<ul>
<li><strong>操作简单</strong>：无需预先建模（如 ARIMA），直接通过优化问题求解。</li>
<li><strong>多变量一致性</strong>：统一方法应用于多个变量，确保趋势同步（如经济周期模型）。</li>
<li><strong>灵活调节</strong>：通过调整 $\lambda$，可适应不同平滑需求。</li>
</ul>
</li>
</ol>
<blockquote>
<p>[!tip] 补充：HP 分解与 Beveridge-Nelson（BN）分解对比<br>| <strong>维度</strong>          | <strong>HP 分解</strong>                          | <strong>BN 分解</strong>                          |<br>|—————————-|——————————————————-|——————————————————|<br>| <strong>理论基础</strong>       | 基于优化平滑，无明确假设    | 基于 ARIMA，区分确定性与随机趋势 |<br>| <strong>趋势一致性</strong>     | 多变量共享同一趋势                  | 各变量独立分解，趋势可能不一致      |<br>| <strong>参数依赖性</strong>     | 依赖 $\lambda$ 的选择               | 依赖 ARIMA 模型阶数的选择             |<br>| <strong>适用序列类型</strong>   | 适合 $I(2)$ 或需强平滑的序列        | 适合 $I(1)$ 序列，需差分平稳        |<br>| <strong>端点敏感性</strong>     | 较高                                | 较低（依赖模型预测）                |<br> 什么是 I(1)、I(2)？这就是一阶和二阶单整。关于协整的内容，在课本第 6 章系统介绍。我们在此对协整做一个简单的介绍：</p>
<p><strong>协整</strong> 是指 <strong>两个非平稳序列的线性组合平稳的性质</strong>。</p>
<ul>
<li>我们称平稳的时间序列为“零阶单整”(Integrated of order zero)，记为 I(0)。</li>
<li>如果时间序列的一阶差分为平稳过程，称为“一阶单整”，记为 I(1)。这就是“单位根过程”。</li>
<li>同理，二阶单整序列就是二阶差分具有平稳性的序列。</li>
<li>一般地，如果时间序列的 d 阶差分为平稳过程，称为“d 阶单整”，记为 I(d)。</li>
</ul>
<p><strong>性质？</strong></p>
<ul>
<li>I(0)序列（平稳序列）对过去行为只有有限记忆，即发生在过去的扰动项对未来的影响随时间而衰减。因此，长期而言 0 阶单整有回到期望值的趋势，即：“均值回复”(mean-reverting)。</li>
<li>I(1)序列则对过去行为有无限长的记忆，即任何过去的冲击都将永久地改变未来的整个序列。</li>
<li>对 $y_t$ 进行单位根检验后，如认为非平稳，要进一步判断其为 I(1)或 I(2)。在经济变量中，I(0)与 I(1)最常见，I(2)很少见。<h1 id="Chapter-4-波动率模型"><a href="#Chapter-4-波动率模型" class="headerlink" title="Chapter 4: 波动率模型"></a>Chapter 4: 波动率模型</h1></li>
</ul>
<p>[!Important] 本章学习目标</p>
<ol>
<li>阐述与经济时间序列数据性质有关的“定式化事实”（见课本）。</li>
<li>介绍基本 ARCH 模型和 GARCH 模型。</li>
<li>阐述 ARCH 模型和 GARCH 模型如何用于估计通货膨胀率的波动性。</li>
<li>阐述 GARCH 模型如何捕捉石油价格、美国真实 GDP 和利差的波动。</li>
<li>阐述一个 GARCH 模型如何被用来估计某一经济部门的风险。</li>
<li>展示用 ARCH 模型如何估计一个随时间变化的风险溢价。</li>
<li>阐述 GARCH (1，1) 模型的特性并用 GARCH 模型进行预测。</li>
<li>得到一个 GARCH 过程的最大似然函数。</li>
<li>介绍 GARCH 的其他重要形式，包括 IGARCH、非对称 TARCH 和 EGARCH 模型</li>
<li>阐述用 NYSE 100 指数估计 GARCH 模型的过程</li>
<li>阐述如何用多元 GARCH 模型来捕捉波动溢出。</li>
<li>形成波动脉冲响应函数并阐述用汇率数据的估计方法。</li>
</ol>
</blockquote>
<h2 id="4-1-ARCH-和-GARCH-过程"><a href="#4-1-ARCH-和-GARCH-过程" class="headerlink" title="4.1 ARCH 和 GARCH 过程"></a>4.1 ARCH 和 GARCH 过程</h2><p><strong>在传统计量模型中，我们假设干扰项方差为常数。</strong></p>
<ul>
<li>对于资产收益率序列 ${𝑟_𝑡}$，如果它是高斯过程（满足同方差 homoskedasticily），则最优线性预测就是最优预测，通常只要建立一个 ARMA 这样的线性模型就足够了。</li>
<li>但是，<strong>许多序列的波动并不会一直持续</strong>。在金融市场中，资产收益率常常不是正态分布的，而且金融资产的收益率会随时间 𝑡 变化，存在“波动率聚集” 现象，即某一段时间波动较大，而另一段时间波动较小。</li>
<li><strong>在这种情况下，假设方差为常数 (同方差) 是不恰当的</strong>。</li>
<li>所以，我们有必要在对条件期望 $E(r<em>t |F</em>{t-1})$ 建模的同时对条件方差 $Var (r<em>t |F</em>{t-1})$ 建模。</li>
<li>作为资产持有者，我们会对该资产在持有期间的回报率及其方差的预测感兴趣。如果我们打算在 t 期买进该资产，在 t+1 期卖出，无条件方差 (即：方差的长期预测) 就不再重要。<br><strong>预测方差的一种方法是引入一个独立变量来估计波动性</strong>。</li>
</ul>
<h1 id="Chapter-5-多元时间序列"><a href="#Chapter-5-多元时间序列" class="headerlink" title="Chapter 5: 多元时间序列"></a>Chapter 5: 多元时间序列</h1><blockquote>
<p>[!IMPORTANT] 本章学习目标</p>
<ol>
<li>介绍干扰分析和传递函数分析。</li>
<li>阐述当系统中不存在信息反馈时，传递函数分析是预测和假设检验的有效工具。</li>
<li>使用恐怖主义和意大利旅游的数据解释估计自回归分布滞后 (ADL) 的适当方式。</li>
<li>阐述为什么传递函数和 ADL 模型的主要限制是许多经济系统都呈现出信息反馈性。</li>
<li>介绍向量自回归 (VAR) 的原理。</li>
<li>展示怎样估计 VAR 模型。阐述为什么向量自回归 (VAR) 的一个最基本形式就是均等地对待所有变量，而不涉及独立与否的争议。</li>
<li>展示怎样获得脉冲响应和方差分解。</li>
<li>阐述如何检验滞后期、Granger 因果关系和 VAR 的外生性。</li>
<li>采用打击国际恐怖活动的样本数据，阐述 VAR 的估计过程和获得脉冲响应的过程 </li>
<li>展示结合经济理论和多变量时间序列的结构性 VAR 和多变量分解两种方法。</li>
<li>阐述几种不同类型的可用于确定向量自回归模型的限制条件。</li>
<li>展示如何检验过度识别限制。使用宏观经济和农业的例子阐述方法。</li>
<li>阐述怎样检验长期中立可用来确定 VAR 的 Blanchard-Ouah 约束条件。</li>
<li>用实际和名义利率数据阐述 Blanchard-Quah 分解过程。</li>
</ol>
</blockquote>
<p>前面的章节仅涉及单变量时间序列的分析，从本章开始涉及多变量的分析。</p>
<ul>
<li>与单一变量的时间序列相比，多变量时间序列涉及两个或更多的变量相互之间的关系，</li>
<li>这样的数据结构更加复杂。它不仅要求我们理解每个变量自身的动态特征，还要掌握这些变量之间的互动模式。</li>
</ul>
<h2 id="5-1-干扰分析"><a href="#5-1-干扰分析" class="headerlink" title="5.1 干扰分析"></a>5.1 干扰分析</h2><p> 稳定的时间序列可能由于某些事件的发生变得不稳定，比如自然事件（如地震）、政策等。这时，我们希望研究外生变量 z 对时间序列变量 y 的影响。怎么做？<br><b> <center> 干扰分析（干预分析，intervention analysis）</center> </b></p>
<ul>
<li>干扰分析的一般模型形式如下：<script type="math/tex">y_t = a_0 + A(L)y_{t-1} + cz_t + B(L)\varepsilon_t</script></li>
<li>其中，A(L)、B(L)为滞后算子的多项式，$z_t$ 为外生变量，c 为为我们感兴趣的系数。</li>
<li>${y_t}$ 需要为平稳序列。也就是说，在进行干扰分析前应进行单位根检验，若原始序列为平稳序列，可以直接使用，若为非平稳序列，则需进行差分或去除趋势等平稳化操作。</li>
<li>如果干扰因素对时间序列数据的影响存在延迟，可取干扰变量的滞后形式 $z_{t-d}$ 替换 $z_t$ 。</li>
</ul>
<p><strong>干扰因素的出现使得时间序列数据被分为两段：干扰前和干扰后</strong>。针对不同的情况，可以选取不同的变量形式来刻画干扰因素：</p>
<ol>
<li><strong>虚拟变量</strong>  <ul>
<li>若在 t 时刻干扰因素存在，则 $z_t = 1$，否则 $z_t = 0$。  </li>
<li>举例来说，若某项政策在 $t = 10$ 时颁布后一直实行，则对于 $t &lt; 10$，可设 $z_t = 0$；对于 $t \geq 10$ 时，可设 $z_t = 1$，这是一种 <strong>纯粹跳跃</strong> 的情况。</li>
<li>若某项特殊政策仅在 $t = 10$ 时实行过一次，此后就恢复之前的状态了，那么可以仅在 $t = 10$ 时设 $z_t = 1$，其余时刻 $z_t = 0$，这种情况也称为 <strong>脉冲</strong>。  </li>
</ul>
</li>
<li><strong>渐进式</strong>（渐进变化函数）<ul>
<li>这种形式是对纯粹跳跃的改进，即干扰因素不是一次性地从 0 跳跃到 1，而是经历了一个渐进的过程。  </li>
<li>比如，设 $z<em>{10} = 0.25$，$z</em>{11} = 0.5$，$z<em>{12} = 0.75$，$z</em>{13} = 1$，此后均有 $z_t = 1$。  </li>
</ul>
</li>
<li><strong>衰减式</strong>（延长的脉冲函数）<ul>
<li>这种情况是对脉冲的改进。</li>
<li>脉冲形式假定干扰因素是一下子消失的，而衰减式则假定干扰因素是逐渐衰减的，也就是说 $z_t$ 从 1 恢复为 0 需要经历一个过程。 </li>
<li>比如，设 $z<em>{10} = 1$，$z</em>{11} = 0.75$，$z<em>{12} = 0.5$，$z</em>{13} = 0.25$，此后均有 $z_t = 0$。  </li>
</ul>
</li>
</ol>
<p><strong>干扰分析建模步骤</strong></p>
<ul>
<li><strong>步骤 1</strong>：把时间序列分为干扰前和干扰后两段，选择其中较长的一段识别 ARIMA 模型  </li>
<li><strong>步骤 2</strong>：以步骤 1 确定的模型阶数为基础，使用全样本（干扰前+干扰后）对干扰模型进行拟合。 </li>
<li><strong>步骤 3</strong>：诊断检验。一个估计出的好的干扰模型应具备如下特征<ul>
<li><strong>估计出的所有系数都应该是统计显著的</strong>。而且，自回归系数应该显示 $y_t$ 收敛。</li>
<li><strong>残差应该近似白噪声过程。</strong> 请注意：如果残差并不类似于正态分布，通常小样本的估计检验的推断是无效的；如果误差看上去服从 ARCH 过程，则需要将整个干扰模型当作 ARCH 模型重新进行估计。</li>
<li><strong>预测模型应当优于看似合理的备择模型</strong>。<h2 id="5-2-传递函数分析与-ADL-模型"><a href="#5-2-传递函数分析与-ADL-模型" class="headerlink" title="5.2 传递函数分析与 ADL 模型"></a>5.2 传递函数分析与 ADL 模型</h2><h3 id="5-2-1-传递函数模型"><a href="#5-2-1-传递函数模型" class="headerlink" title="5.2.1 传递函数模型"></a>5.2.1 传递函数模型</h3>对干扰模型的自然扩展就是 <strong>允许序列 ${z_t}$ 不仅仅是一个确定性的虚拟变量</strong>。<br>考虑传递函数的一般形式如下：  <script type="math/tex; mode=display">y_{t}=a_0+A(L)y_{t-1}+C(L)z_{t}+B(L)\varepsilon_{t}</script>式中，$A (L)$、$B (L)$ 和 $C (L)$ 是滞后算子 L 的多项式。 <ul>
<li>其中，$C (L)$ 被称为 <strong>传递函数</strong>，因为它展示了外生变量 ${z_t}$ 中的变动如何影响（转换为）内生变量 ${y_t}$  的时间路径。 </li>
<li>我们可以设 $C (L)=c_0+c_1L+c_2L^2+\cdots$ 。其中系数 $c_i$ 被称为传递函数权重。</li>
<li>在一个典型的传递函数分析中，研究者必将收集内生变量 ${y_t}$ 和外生变量 ${z_t}$ 的数据，其目的在于估计参数 $a_0$ 和多项式 $A (L)$、$B (L)$ 和 $C (L)$ 的参数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!note] 传递函数模型 v.s 干扰模型</p>
<ul>
<li>干扰模型和传递函数模型的共同点是：都假定 z 为外生变量，即只允许 z 影响 y，而不允许反过来 y 影响 z。</li>
<li>传递函数模型较干扰模型更具一般性：<ul>
<li>对于干扰模型，无论是当期值，还是滞后值，都仅含一项与 z 相关的项，</li>
<li>而在传递函数模型中， ${z_t}$ 并没有受到特殊的确定性时间路径的约束，而是允许干扰变量为任意随机外生过程，允许出现分布滞后项。</li>
</ul>
</li>
<li><strong>对于在多个时期分配 z 对 y 影响的模型，称为分布滞后（distributed lag）模型</strong>。<h3 id="5-2-2-特例：ADL-模型"><a href="#5-2-2-特例：ADL-模型" class="headerlink" title="5.2.2 特例：ADL 模型"></a>5.2.2 特例：ADL 模型</h3>ADL 模型是传递函数模型的特例。令 $B (L)=1$，模型形式如下：<script type="math/tex; mode=display">y_{t}=a_0+A(L)y_{t-1}+C(L)z_{t}+\varepsilon_{t}</script></li>
<li>此时，模型中仅含有的自回归项和分布滞后项，不含误差的移动平均项，因此称为 <strong>自回归分布滞后模型</strong>（ADL 模型）。</li>
<li>与纯粹的干扰模型相比，ADL 模型并没有干扰前和干扰后之分，所以我们不能按照估计干扰模型的那种形式估计。</li>
<li>尽管不能照搬，但其目的都是为了估计一个简练的模型，所以估计方法是类似的。</li>
</ul>
<p>[!tip] 拟合 ADL 模型的步骤<br> 我们考虑一个简单的 ADL 模型</p>
<script type="math/tex; mode=display">y_t = a_1 y_{t-1} + c_d z_{t-d} + \varepsilon_t</script><p> 其中，${z<em>{t}},{\varepsilon</em>{t}}$ 为独立的白噪声过程，$E(z<em>{t}\varepsilon</em>{t-i})=0$， $a_1,c_d$ 为未知系数，d 是我们设定的滞后期。</p>
<p> <strong>第一步</strong>：计算 $y<em>t$ 与不同 $z</em>{t-i}$ 的值的互相关系数(cross-correlations)。</p>
<ul>
<li>$y<em>t$ 和 $z</em>{t-i}$ 的互相关系数定义为<script type="math/tex; mode=display">\rho_{yz}(i) = \frac{Cov(y_t, z_{t-i})}{\sigma_y \sigma_z}</script></li>
<li>用 $\rho_{yz}$ 作图，得到 <strong>互相关函数</strong>（cross-correlation function, CCF）或互相关图。</li>
<li>在实践中，我们必须用到通过样本数据计算的互相关系数，因为我们并不知道准确的协方差和标准差。</li>
</ul>
<p><strong>第二步</strong>：计算互协方差</p>
<ul>
<li>求解前述 ADL 模型，得到  <script type="math/tex; mode=display">y_{t} = \frac{c_d z_{t-d}}{(1-a_1 L)} + \frac{\varepsilon_t}{(1-a_1 L)}</script></li>
<li>根据滞后算子的性质，展开表达式 $\dfrac{c<em>d z</em>{t-d}}{(1-a_1 L)}$ ，得到  <script type="math/tex; mode=display">y_{t} = c_d(z_{t-d}+a_1z_{t-d-1}+a_1^2z_{t-d-2}+a_1^3z_{t-d-3}+\cdots)+\frac{\varepsilon_t}{(1-a_1 L)}</script></li>
<li>我们通过用 $z<em>t, z</em>{t-1}, \cdots$ 依次乘以 $y_t$ 就可以得到互协方差(cross-covariances)。</li>
<li>进一步依次计算期望值，写出一般形式：<script type="math/tex">E\left(y_{t} z_{t-i}\right)=\left\{\begin{array}{ll}0, & \text { 当 } i<d \\ c_{d} a_1^{i-d} \sigma_{z}^{2}, & \text { 当 } i \geq d\end{array}\right.</script></li>
</ul>
<p><strong>第三步</strong>：代入得到互协方差 CCF 函数</p>
<script type="math/tex; mode=display">\rho_{y z}(i)=\frac{\operatorname{cov}\left(y_{t}, z_{t-i}\right)}{\sigma_{y} \sigma_{z}}=\frac{E\left(y_{t} z_{t-i}\right)}{\sigma_{y} \sigma_{z}}=\left\{\begin{array}{ll}0, & \text { 当 } i<d \\ \dfrac{c_{d} a_1^{i-d} \sigma_{z}}{\sigma_{y}}, & \text { 当 } i \geq d\end{array}\right.</script><ul>
<li>$Cov(X,Y) = E(X - EX)(Y - EY)=E(XY)-EXEY$，且 ${z_t}$ 白噪声，$E(z_t)=0$</li>
<li>第一个非零的互相关系数的大小的绝对值与 $c_d$ 和 $a_1$ 的数值正相关</li>
<li>此后，互相关系数按照比例 $a_1$ 衰减。<strong>互相关图的衰减与序列 $y_t$ 的 AR 相匹配。</strong></li>
<li>互相关系数为 $E(y<em>t z</em>{t-i}) / (\sigma<em>y \sigma_z)$。在文献中，用 $E(y_t z</em>{t-i}) / \sigma<em>z^2$ 表示标准化互协方差的做法很普遍。对两种表示方法的选择无关紧要，因为互协方差函数 CCF 和标准化的互协方差函数(CCVF)是互成比例的。根据互协方差为 $E(y_t z</em>{t-i})$，CCVF 为<br><script type="math/tex">\gamma_{yz}(i) = \begin{cases} 0, & \text{当 } i < d \\ c_d, & \text{当 } i = d \\ a_1^{i-d-1} (c_d a_1 + c_{d+1}), & \text{当 } i \geq d + 1 \end{cases}</script> 它前面的规律仍然适用：当 $i&gt;d+1$ 时，CCVF 呈指数衰减，衰减比例为 $a_1$。</li>
</ul>
<p><strong>更高阶 AR 过程的情况</strong></p>
<ul>
<li>当向模型中加入 $y<em>t$ 的滞后项 $y</em>{t-2}$（系数设定为 $a<em>2$），即保持 $C(L)$ 不变、改变 $A(L)$ 的形式时，$\gamma</em>{yz}(i)$ 存在如下关系：<script type="math/tex; mode=display">\gamma_{yz}(i) = a_1 \gamma_{yz}(i-1) + a_2 \gamma_{yz}(i-2) \quad i \geq d+2</script></li>
<li>所刻画的 $\gamma_{yz}(i)$ 的变化趋势与 $A(L)$ 对应的 AR(2) 的 ACF 变化趋势也完全一致。</li>
<li>拓展地看，当 ${ z_t }$ 为白噪声序列时，CCVF 从某一滞后期后的变化趋势能够大致反映出 $A(L)$ 的形式。此外，CCVF 也能大致反映 $C(L)$ 的形式：CCVF 的第一个非零值与 $C(L)$ 的第一个非零滞后项相对应；其峰值绝对值在 $C(L)$ 最大滞后项附近。</li>
</ul>
</blockquote>
<p>理论上，互相关函数 CCF 与 CCVF 具有如下的特征：  </p>
<ol>
<li>在多项式 $C (L)$ 的第一个非零元素出现之前，所有的 $\gamma_{yz}(i)=0$。  </li>
<li>CCVF 中的峰值表示 $C (L)$ 的非零元素。因此滞后期 $d$ 处的峰值表示 $z_{t-d}$ 直接影响 $y_t$。 </li>
<li>所有的峰值都以比例 $a_1$ 衰减。收敛性暗示 $a_1$ 的绝对值小于 1。如果 $0&lt;a_1&lt;1$，则互协方差是直接衰减的，而如果 $-1&lt;a_1&lt;0$，<strong>则互协方差是震荡衰减的</strong>。</li>
</ol>
<h3 id="5-2-3-滤波与-ADL-模型估计"><a href="#5-2-3-滤波与-ADL-模型估计" class="headerlink" title="5.2.3 滤波与 ADL 模型估计"></a>5.2.3 滤波与 ADL 模型估计</h3><p>现在我们知道。可以通过 CCF 或 CCVF 判断出 A (L) 和 C (L) 的阶数，但是这一结论是在 ${z_t}$ 为白噪音序列的前提下推导的，更一般的情况是：假设它为一个平稳 ARMA 过程：</p>
<script type="math/tex; mode=display">D(L)z_t = E(L)\varepsilon_{zt}</script><p>其中 $D(L)$、$E(L)$ 为滞后算子多项式，$\varepsilon_{zt}$ 为白噪音序列。</p>
<p>转换后，有：$z<em>t=\dfrac{E(L)}{D(L)}\varepsilon</em>{zt}$。进而有，</p>
<script type="math/tex; mode=display">\begin{split} y_t&= a_0+A(L)y_{t-1}+C(L)\frac{E(L)}{D(L)}\varepsilon_{zt}+B(L)\varepsilon_t \\ \downarrow \\
\frac{D(L)}{E(L)}y_t&=\frac{D(L)}{E(L)}a_0+\frac{D(L)}{E(L)}A(L)y_{t-1}+C(L)\varepsilon_{zt}+\frac{D(L)}{E(L)}B(L)\varepsilon_t \end{split}</script><p>令 $y_{ft}=\dfrac{D(L)}{E(L)}y_t$，则上式可转换为如下形式：</p>
<script type="math/tex; mode=display">y_{ft}=\frac{D(L)}{E(L)}a_0+A(L)y_{f(t-1)}+C(L)\varepsilon_{zt}+\frac{D(L)}{E(L)}B(L)\varepsilon_t</script><ul>
<li>这样，传递函数模型中的外生变量就转换成白噪音的形式了（即 $\varepsilon_{zt}$）。</li>
<li>对 $y<em>{ft}$ 和  $\varepsilon</em>{zt}$ 求互相关函数，其变化趋势仍能反映出原始模型中 $A(L)$、$C(L)$ 的形式。</li>
<li>$\dfrac{D(L)}{E(L)}$ 称为 <strong>滤波</strong>（filter）；$y_{ft}$ 是 $y_t$ 经过滤波后的值，称为 <strong>新息</strong>（innovation）。</li>
</ul>
<blockquote>
<p>[!tip] <strong>传递函数模型估计的步骤</strong>：</p>
<ol>
<li><strong>使用 AR 模型拟合 $z_t$</strong><ul>
<li>若 $z_t$ 存在自相关，用 <strong>AR 模型</strong> 捕捉其滞后结构。  </li>
<li>同时，可能需检验 $z_t$ 的平稳性（如 ADF 检验），避免伪回归。</li>
</ul>
</li>
<li><strong>识别 $C (L)$ 的合理候选（分布滞后项）</strong><ul>
<li>首先，使用 $z<em>t$ 的 AR 模型结果，借助滤波 $\dfrac{D(L)}{E(L)}$ **构建过滤序列 $y</em>{ft}$**，以去除 $y_t$ 中与 $z_t$ 相关的自相关噪声，突出 $z_t$ 对 $y_t$ 的直接影响。  </li>
<li><strong>识别 $C (L)$</strong>：<br>通过分析 $y_{ft}$ 与 $z_t$ 的互相关函数（CCF），确定 $z_t$ 的滞后阶数，初步构建分布滞后项 $C (L) z_t$。</li>
</ul>
</li>
<li><strong>识别 $A (L)$ 的合理候选（自回归项）</strong><ul>
<li>直接 $y<em>t$ 对 $z_t$ 进行回归（如 $y_t = c_0 z_t + c_1 z</em>{t-1} + e_t$），得到初步的分布滞后模型。  </li>
<li><strong>分离自回归项 $A (L)$</strong>：通过残差分析（如 ACF/PACF 检验）识别 $y<em>t$ 的自回归结构。例如，若残差存在一阶自相关，则引入 $y</em>{t-1}$。</li>
</ul>
</li>
<li><strong>将步骤 2 和 3 的结果整合为完整 ADL 模型</strong><ul>
<li>同时估计 A(L) 和 C(L) 。<script type="math/tex">Y_t = \underbrace{a_1 y_{t-1} + a_2 y_{t-2} + \dots}_{A (L)} + \underbrace{c_0 z_t + c_1 z_{t-1} + \dots}_{C (L)} + \varepsilon_t</script></li>
<li>注意：如果 ${y_t}$ 、 ${z_t}$ 任一个非平稳，则样本的互相关系数没有意义。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="5-3-向量自回归（VAR）模型"><a href="#5-3-向量自回归（VAR）模型" class="headerlink" title="5.3 向量自回归（VAR）模型"></a>5.3 向量自回归（VAR）模型</h2><p>上篇介绍的传递函数模型的假设是，$z_t$ 会影响到 $y_t$，而 $y_t$ 不会影响 $z_t$，因此称 $z_t$ 为外生变量（exogenous variable）。那么，如果 $z_t$ 和 $y_t$ 以及更多的变量之间能够相互影响呢？</p>
<ul>
<li>此时，它们就是内生变量（endogenous variable）。</li>
<li>当我们难以判断变量是否外生，传递函数分析的自然扩展就是均等地对待每一个变量。</li>
<li><strong>向量自回归模型</strong>（vector autoregressive model）研究了内生变量之间的相互影响作用。</li>
</ul>
<h3 id="5-3-1-VAR-模型含义与性质"><a href="#5-3-1-VAR-模型含义与性质" class="headerlink" title="5.3.1 VAR 模型含义与性质"></a>5.3.1 VAR 模型含义与性质</h3><p>考虑如下简单的双变量系统：</p>
<script type="math/tex; mode=display">
y_t = \alpha_1 + \beta_1 z_t + B_1(L)y_{t-1} + C_1(L)z_{t-1} + \varepsilon_{y_t}</script><script type="math/tex; mode=display">
z_t = \alpha_2 + \beta_2 y_t + B_2(L)y_{t-1} + C_2(L)z_{t-1} + \varepsilon_{z_t}</script><p>式中，$B_1 (L)$、$B_2 (L)$、$C_1 (L)$、$C_2 (L)$ 是阶数相同的滞后算子多项式，</p>
<ul>
<li>假设其阶数为 $p$，它也称作是 VAR 模型的阶数。</li>
<li>对于每个变量来说，预测变量包括本身的 $p$ 阶滞后值、其他变量的 $p$ 阶滞后值、其他变量的当期值（$z_t$ 或 $y_t$）。</li>
<li>$\varepsilon<em>{yt}$ 和 $\varepsilon</em>{zt}$ 为白噪声，且彼此互不相关。</li>
</ul>
<p>将模型形式中的当期值移到等号左侧，变成如下形式：</p>
<script type="math/tex; mode=display">
y_t - \beta_1 z_t = \alpha_1 + B_1 (L) y_{t-1} + C_1 (L) z_{t-1} + \varepsilon_{y_t}</script><script type="math/tex; mode=display">
-\beta_2 y_t + z_t = \alpha_2 + B_2 (L) y_{t-1} + C_2 (L) z_{t-1} + \varepsilon_{z_t}</script><p>以矩阵形式写出，</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1 & -\beta_1 \\-\beta_2 & 1\end{bmatrix}\begin{bmatrix}y_t \\z_t \end{bmatrix}=\begin{bmatrix}\alpha_1 \\\alpha_2 \end{bmatrix}+\begin{bmatrix}B_1 (L) & C_1 (L) \\B_2 (L) & C_2 (L)\end{bmatrix}\begin{bmatrix}y_{t-1} \\z_{t-1}\end{bmatrix}+\begin{bmatrix}\varepsilon_{y_t} \\\varepsilon_{z_t}\end{bmatrix}</script><p>再变换得，</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 
y_t \\
z_t
\end{bmatrix}=
\begin{bmatrix}
1 & -\beta_1 \\
-\beta_2 & 1
\end{bmatrix}^{-1}
\begin{bmatrix}
\alpha_1 \\
\alpha_2
\end{bmatrix}
+
\begin{bmatrix}
1 & -\beta_1 \\
-\beta_2 & 1
\end{bmatrix}^{-1}
\begin{bmatrix}
B_1 (L) & C_1 (L) \\
B_2 (L) & C_2 (L)
\end{bmatrix}
\begin{bmatrix}
y_{t-1} \\
z_{t-1}
\end{bmatrix}
+
\begin{bmatrix}
1 & -\beta_1 \\
-\beta_2 & 1
\end{bmatrix}^{-1}
\begin{bmatrix}
\varepsilon_{y_t} \\
\varepsilon_{z_t}
\end{bmatrix}</script><p>使用一些符号代替上式中的矩阵，得到下式：</p>
<script type="math/tex; mode=display">
X_t = A_0 + AX_{t-1} + e_t</script><p>式中，$X_t = [y_t, z_t]^{T}$，其余依次类推。</p>
<ul>
<li>这样，等号右侧不再包含变量的当期值，这被称为 <strong>VAR 模型的标准形式</strong>，</li>
<li>可以看出，模型的基本形式是弱平稳过程的自回归表达式。</li>
<li>包含当期值的形式则被称为 <strong>结构性 VAR 模型</strong>。</li>
<li>变量当期值之间的相关性被隐藏在模型残差 $e_t$ 之中。它是两个冲击 $\varepsilon$ 的组合</li>
</ul>
<script type="math/tex; mode=display">
e_t = \left[\begin{array}{cc}
1 & -\beta_1 \\
-\beta_2 & 1
\end{array}\right]^{-1} \left[\begin{array}{c}
\varepsilon_{y_t} \\
\varepsilon_{z_t}
\end{array}\right] = \frac{1}{1 - \beta_1 \beta_2} \left[\begin{array}{cc}
1 & \beta_1 \\
\beta_2 & 1
\end{array}\right] \left[\begin{array}{c}
\varepsilon_{y_t} \\
\varepsilon_{z_t}
\end{array}\right]</script><p>显然，若变量的当期值之间存在联系，即 $\beta<em>1$ 和 $\beta_2$ 至少有一个不为 0，则 $\varepsilon</em>{y<em>t}$ 和 $\varepsilon</em>{z<em>t}$ 必然相关；反之，若变量的当期值不存在相互影响，则 $\varepsilon</em>{y<em>t}$ 和 $\varepsilon</em>{z_t}$ 也不相关。</p>
<blockquote>
<p>[!note] 矩阵求逆<br>对于一个 2×2 矩阵 A，其逆矩阵为：</p>
<script type="math/tex; mode=display">
A = \left[\begin{array}{cc}
a & b \\
c & d
\end{array}\right]= ad-bc
\quad \to  \quad
A^{-1} = \frac{1}{|A|}adj(A) = \frac{1}{ad - bc} \left[\begin{array}{cc}
d & -b \\
-c & a
\end{array}\right]</script><p>Why?</p>
<ul>
<li>伴随矩阵 adj(A) 是余子式矩阵的转置</li>
<li>A 的余子式矩阵：$\left[\begin{array}{cc}d &amp; -c \-b &amp; a\end{array}\right]$</li>
<li>进一步 <strong>转置</strong> 才得到伴随矩阵 adj(A) 。</li>
</ul>
<p>应用到我们的矩阵：</p>
<script type="math/tex; mode=display">
A = \left[\begin{array}{cc}
1 & -\beta_1 \\
-\beta_2 & 1
\end{array}\right]
=  1 - \beta_1 \beta_2
\to
A^{-1} = \frac{1}{1 - \beta_1 \beta_2} \left[\begin{array}{cc}
1 & \beta_1 \\
\beta_2 & 1
\end{array}\right]</script></blockquote>
<p>因此：</p>
<script type="math/tex; mode=display">
\begin{cases}e_{1 t}=\dfrac{\varepsilon_{y t}-\beta_1 \varepsilon_{z t}}{1-\beta_1\beta_2}\\
e_{2 t}=\dfrac{\varepsilon_{z t}-\beta_2 \varepsilon_{y t}}{1-\beta_1\beta_2}
\end{cases}</script><p>因为 $\varepsilon<em>{y}$ 和 $\varepsilon</em>{z}$ 服从白噪声过程，所以，$e<em>{1t}$ 和 $e</em>{2t}$ 的均值为 0，方差恒定且独立不相关（自协方差 = 0，如果两个冲击相关，互协方差不为 0；如果两个冲击不相关，互协方差为 0）。</p>
<p>顺理成章地，我们可以推广到 k 维，也就是 k 元时间序列的 VAR 模型。</p>
<script type="math/tex; mode=display">
Y_{t}=\Phi_{0}+\Phi_{1} Y_{t-1}+\cdots+\Phi_{p} Y_{t-p}+B X_{t}+\varepsilon_{t}, \quad t = 1,2, \cdots, T</script><p>其中</p>
<script type="math/tex; mode=display">
\boldsymbol{Y}_{t}=\left (\begin{array}{c}
Y_{1 t} \\
Y_{2 t} \\
\vdots \\
Y_{k t}
\end{array}\right), \quad \boldsymbol{\varepsilon}_{t}=\left (\begin{array}{c}
\varepsilon_{1 t} \\
\varepsilon_{2 t} \\
\vdots \\
\varepsilon_{k t}
\end{array}\right), \quad \boldsymbol{\Phi}_{0}=\left (\begin{array}{c}
\phi_{10} \\
\phi_{20} \\
\vdots \\
\phi_{k 0}
\end{array}\right)</script><script type="math/tex; mode=display">
\boldsymbol{\Phi}_{i}=\left (\begin{array}{ccc}
\phi_{11}(i) & \cdots & \phi_{1 k}(i) \\
\phi_{21}(i) & \cdots & \phi_{2 k}(i) \\
\vdots & \ddots & \vdots \\
\phi_{k 1}(i) & \cdots & \phi_{k k}(i)
\end{array}\right), i = 1,2, \cdots, p</script><h3 id="5-3-2-多元时间序列平稳性、可逆性"><a href="#5-3-2-多元时间序列平稳性、可逆性" class="headerlink" title="5.3.2 多元时间序列平稳性、可逆性"></a>5.3.2 多元时间序列平稳性、可逆性</h3><h4 id="5-3-2-1-平稳性"><a href="#5-3-2-1-平稳性" class="headerlink" title="5.3.2.1 平稳性"></a>5.3.2.1 平稳性</h4><p>如果一个 $k$ 维时间序列 $Y_t$ 弱平稳，它需要满足下列两个条件：  </p>
<ul>
<li>$E (Y_t) = \mu$;  </li>
<li>$Cov (Y_t) = E[(Y_t - \mu)(Y_t - \mu)^T] = V$, 其中 $V$ 是 $k \times k$ 维的常数正定矩阵。</li>
</ul>
<p>为了使模型平稳，当 $k \to \infty$ 时，系数矩阵的幂收敛到零矩阵：$\Phi_1^{\infty} = 0$ </p>
<ul>
<li><strong>数学条件</strong>：矩阵 $\Phi_1$ 的特征根全部小于 1。</li>
<li>设 $\Phi_1$ 对应的特征根为 $\lambda$，即 $\lambda$ 是方程 $|\lambda I_2-\Phi_1|=0$ 的根。为使模型平稳，方程的根必须在单位圆内（也可以表述为：对应的特征方程的根全在单位圆外）</li>
</ul>
<h4 id="5-3-2-2-可逆性"><a href="#5-3-2-2-可逆性" class="headerlink" title="5.3.2.2 可逆性"></a>5.3.2.2 可逆性</h4><blockquote>
<p>[!tip] 多元时间序列可逆的定义：<br>如果一个 $k$ 维时间序列 $Y<em>t$ 可以表示如下形式则称该序列可逆：$$Y_t = c + \sum</em>{j=1}^{\infty} \pi<em>j Y</em>{t-j} + \varepsilon_t$$  </p>
<p>根据可逆性定义知，$k$ 元 VAR ($p$) 模型总是可逆的。</p>
<ul>
<li>事实上，请回忆：AR 模型是可逆的。</li>
<li>对于 VAR ($p$) 模型，对任意 $j &gt; p$，$\pi_j = 0$。因此也是可逆的。</li>
</ul>
</blockquote>
<p>由于 VAR 具有可逆性，每一个 VAR 模型都可以表示成为一个无限阶的向量 MA (∞) 过程。<br>我们知道双变量的 VAR 模型的标准形式如下：</p>
<script type="math/tex; mode=display">
X_t = A_0 + AX_{t-1} + e_t</script><p>通过不断迭代，可以将上式进行如下转换：</p>
<script type="math/tex; mode=display">
\begin{split}X_t =& A_0 + AX_{t-1} + e_t \\=& A_0 + A (A_0 + AX_{t-2} + e_{t-1}) + e_t \\
 =& (I + A) A_0 + A^2 X_{t-2} + Ae_{t-1} + e_t \\
 &... \\
 =& (I + A + A^2 + ... + A^n) + A^{n+1}X_{t-n-1} + \sum_{i = 0}^{n} A^ie_{t-i}\end{split}</script><p>当 $n \to \infty$，$A^{n+1} \to 0$，而 $\sum<em>{i=0}^{n} A^ie</em>{t-i}$ 的期望始终为 0，则 $I + A + A^2 + … + A^n$ 为 $X_t$ 的数学期望，记为 $\mu$。则有，</p>
<script type="math/tex; mode=display">
X_t = \mu + \sum_{i = 0}^{\infty} A^ie_{t-i}</script><p>我们还知道，</p>
<script type="math/tex; mode=display">
e_t = \frac{1}{1-\beta_1\beta_2}\begin{bmatrix} 1 & \beta_1 \\ \beta_2 & 1 \end{bmatrix}\begin{bmatrix} \varepsilon_{yt} \\ \varepsilon_{zt} \end{bmatrix}= \frac{1}{1-\beta_1\beta_2}\begin{bmatrix} 1 & \beta_1 \\ \beta_2 & 1 \end{bmatrix}\varepsilon_t</script><p>代入得到，</p>
<script type="math/tex; mode=display">
X_t = \mu + \frac{1}{1-\beta_1\beta_2}\sum_{i = 0}^{\infty} A^i\begin{bmatrix} 1 & \beta_1 \\ \beta_2 & 1 \end{bmatrix}\varepsilon_{t-i}</script><p>这被称为 VAR 的 <strong>移动平均形式 VMA</strong>（vector moving average）。</p>
<h3 id="5-3-3-VAR-参数估计、识别与预测"><a href="#5-3-3-VAR-参数估计、识别与预测" class="headerlink" title="5.3.3 VAR 参数估计、识别与预测"></a>5.3.3 VAR 参数估计、识别与预测</h3><ul>
<li>对于平稳 VAR(p)模型，使用普通最小二乘估计和广义最小二乘估计的结果是相同的；<ul>
<li>在正态分布的假设下，最大似然估计与最小二乘估计的结果近似相等。</li>
<li>一旦 VAR 被估计以后，它就能作为一个多元预测模型。</li>
<li>由于无约束 VAR 是过度参数化的，因而，预测可能不可信。为了得到一个精简模型，许多预测者将 VAR 中不重要的系数排除并用 SUR 重新估计。这就是近似 VAR 模型，在估计得到近似 VAR 模型后，用它进行预测。</li>
<li>另一些人在估计参数时，将 VAR 与贝叶斯方法联系，基于后验分布进行统计推断。</li>
</ul>
</li>
<li><strong>定阶</strong>：建立 VAR 模型除了要满足平稳性条件外，还应该正确确定滞后期。如果滞后期太少，误差项的自相关会很严重，并导致参数的非一致性估计。在 VAR 模型中适当加大 p 值（增加滞后变量个数），可以消除误差项中存在的自相关；但从另一方面看，p 值又不宜过大，p 值过大会导致自由度减小，直接影响模型参数估计量的有效性。<strong>我们可以基于似然比检验结果和信息准则确定滞后阶数 p。</strong>（课本 5.8 节）<ul>
<li><strong>似然比检验</strong>（Likelihood Ratio Test, <strong>LR</strong>），其思路是比较 VAR($k$) 和 VAR($k+1$) 模型的拟合能力。原假设 H0：$Φ_l$ = 0，备择假设 H1：$Φ_l$ ≠ 0。通过逐步回归，比较模型的似然比，构建统计量。<script type="math/tex">LR = −2(\log L(k) − \log L(k+1)) \sim χ²(N²)</script> k 表示 VAR 模型中滞后变量的最大滞后期。当 VAR 模型滞后期的增加不会给极大似然函数值带来显著性增大时，即 LR 统计量的值小于临界值时，新增加的滞后变量对 VAR 模型毫无意义。</li>
<li><strong>信息准则</strong>：<span style="background:#fff88f">AIC可能会超调（overshooting）真实值p；Hannan-Quinn IC和BIC结果比较一致。</span>（详见 <a target="_blank" rel="noopener" href="https://www.math.pku.edu.cn/teachers/lidf/course/fts/ftsnotes/html/_ftsnotes/fts-var.html#var-estorder">Link</a>）</li>
</ul>
</li>
<li><strong>模型验证</strong>：多元混成检验。<ul>
<li>准确的模型的残差应该是白噪声序列。</li>
<li>多元混成检验是为了检验残差的序列相关性，其原假设 H0 为：残差相关矩阵 $ρ<em>{a1} = · · · = ρ</em>{a m} = 0$，备择假设 H1 为：对于某些 1 ≤ j ≤ m，$ρ_{a j}= 0$。在这组假设下构造统计量。</li>
<li>多元混成检验把一元的 Ljung-Box 白噪声检验推广到了多元的情形。</li>
</ul>
</li>
</ul>
<h3 id="5-3-4-VAR-的脉冲响应函数"><a href="#5-3-4-VAR-的脉冲响应函数" class="headerlink" title="5.3.4 VAR 的脉冲响应函数"></a>5.3.4 VAR 的脉冲响应函数</h3><p>VAR 模型研究的是多个时间序列变量之间的相互影响关系，但是模型估计出的参数结果及其显著水平似乎并不能直观地反映这种影响关系，而要想直观地呈现这种关系，就需要使用 <strong>脉冲响应函数</strong>（impulse response function）。</p>
<p>对脉冲响应函数进行描图是展现 |y| 与 |z|对各种冲击的响应行为的实用方法。</p>
<p>我们从 VAR 的移动平均形式（VMA）出发： </p>
<script type="math/tex; mode=display">
X_t = \mu + \frac{1}{1-\beta_1\beta_2}\sum_{i = 0}^{\infty} A^i\begin{bmatrix} 1 & \beta_1 \\ \beta_2 & 1 \end{bmatrix}\varepsilon_{t-i}</script><p>通过定义如下符号：</p>
<script type="math/tex; mode=display">
\Phi_{i}=\frac{1}{1-\beta_1 \beta_2}A^i \begin{bmatrix}
1&\beta_1\\
\beta_2&1
\end{bmatrix}</script><p>VMA 可以写成如下形式：</p>
<script type="math/tex; mode=display">X_t = \mu + \sum_{i=0}^\infty \Phi_i \varepsilon_{t-i}= \mu + \Phi_0 \varepsilon_t + \Phi_1 \varepsilon_{t-1} + \Phi_2 \varepsilon_{t-2} + \ldots</script><p>可以看出，$\Phi<em>i$ 中的元素刻画了 $\varepsilon</em>{t-i}$ 的冲击对时间序列变量当期值的影响（也就是偏导数）。</p>
<p>以双变量为例，每个 $\Phi_i$ 都是一个二行、二列的矩阵：</p>
<ul>
<li>第一行、第一列：$\varepsilon_{yt-i}$ 的单位变化对 $y_t$ 的影响作用；</li>
<li>第一行、第二列：$\varepsilon_{zt-i}$ 的单位变化对 $y_t$ 的影响作用；</li>
<li>第二行、第一列：$\varepsilon_{yt-i}$ 的单位变化对 $z_t$ 的影响作用；</li>
<li>第二行、第二列：$\varepsilon<em>{zt-i}$ 的单位变化对 $z_t$ 的影响作用。<br>$\Phi_i$ 每个位置的元素构成了一个脉冲响应函数，反映了不同滞后期的 $\epsilon</em>{t-i}$ 的单位变化对 $X_t$ 的影响的变化趋势。</li>
<li>对于每一个误差项，内生变量都对应着一个脉冲响应函数。这样，一个含有 4 个内生变量的 VAR 将有 16 个脉冲响应函数。</li>
<li>对于 VAR(p)模型，有类似的分析，只是脉冲反应函数更加复杂。</li>
</ul>
<h3 id="5-3-5-格兰杰因果检验"><a href="#5-3-5-格兰杰因果检验" class="headerlink" title="5.3.5 格兰杰因果检验"></a>5.3.5 格兰杰因果检验</h3><p>VAR 模型还可用来检验 <strong>一个变量与另一个变量是否存在因果关系</strong>，</p>
<ul>
<li>$x_t$ 对 $y_t$ 是否存在因果关系的检验可通过检验 VAR 模型以 $y_t$ 为被解释变量的方程中是否可以把 $x_t$ 的全部滞后变量剔除掉而完成。</li>
<li>比如 VAR 模型中以 $y<em>t$ 为被解释变量的方程表示如下： $$ y_t = \sum</em>{i=1}^{k} \alpha<em>i y</em>{t-i} + \sum<em>{i=1}^{k} \beta_i x</em>{t-i} + u_{1,t} $$<ul>
<li>则检验 $x_t$ 对 $y_t$ 存在格兰杰非因果性的零假设是 <script type="math/tex">H_0: \beta_1 = \beta_2 = \ldots = \beta_k = 0</script></li>
<li>为了比较无约束与约束的模型，使用对数似然比检验（LR 检验），得到的统计量在约束参数等于零的零假设下渐近服从卡方分布。</li>
<li>如果 $x_t$ 的任何一个滞后变量的回归参数的估计值存在显著性，则拒绝原假设，$x_t$ 对 $y_t$ 存在格兰杰因果关系。</li>
<li><strong>注意：</strong> 在格兰杰因果检验中，我们关心 $\beta$ （二者之间的关系）而非 $\alpha$；关心滞后项系数（而不关心当期 $i=0$ 对应的 $x_t$ 系数）。</li>
<li>关于格兰杰检验的更多细节详见课本 5.8.1 -5.8.2 节。</li>
<li>格兰杰因果关系检验经常被解释为在 VAR 模型中，某个变量是否可以用来提高对其他相关变量的预测能力。因此格兰杰因果关系的实质是一种“预测”关系，而并非真正汉语意义上的“因果关系”。</li>
</ul>
</li>
</ul>
<h3 id="5-3-6-结构性-VAR-估计"><a href="#5-3-6-结构性-VAR-估计" class="headerlink" title="5.3.6 结构性 VAR 估计"></a>5.3.6 结构性 VAR 估计</h3><ul>
<li>在 20 世纪 80 年代，传统的联立方程模型曾经很流行。这些结构模型越建越大，仿佛能够很好的反应样本的情况，但是对样本外的数据预测能力却很弱。因此 Sim（1980）提出了标准 VAR 模型。</li>
<li>标准 VAR 只能捕捉变量间相关性，脉冲效应函数并不是唯一的，并且不包含变量之间的当期影响。</li>
<li>结构性 VAR（SVAR）借助结构限制条件，将复合冲击分解为结构性冲击，能够揭示经济变量因果机制，并且考虑变量之间的当期影响。这表明：SVAR 是在标准 VAR 模型基础上，通过引入经济理论限制来识别变量间同期因果关系和特定冲击影响。</li>
<li>估计方法：通常需先确定结构限制条件，再进行参数估计。比如可利用 Choleski 分解，它能将协方差矩阵分解为下三角矩阵与其转置的乘积形式，为识别结构性冲击提供一种方式，但变量排序会影响结果。<br><strong>SVAR 进行识别</strong></li>
<li>短期约束（Sim-Bernanke 方法）假设某些冲击对特定变量无即时影响。</li>
<li>长期约束（Blanchard-Quah 方法）假设某些冲击长期不影响特定变量。</li>
</ul>
<h2 id="第五章练习"><a href="#第五章练习" class="headerlink" title="第五章练习"></a>第五章练习</h2><ol>
<li>已知双变量 VAR 模型的矩阵形式如下：<script type="math/tex">\begin{pmatrix}y_{1t}\\ y_{2t}\end{pmatrix}=\begin{pmatrix}0.5 & 0.3\\ 0.3 & 0.5\end{pmatrix}\begin{pmatrix}y_{1t-1}\\ y_{2t-1}\end{pmatrix}+\begin{pmatrix}u_{1t}\\ u_{2t}\end{pmatrix}</script> 其中，$u<em>{1t}$ 和 $u</em>{2t}$ 是白噪声过程，且 Cov ($u<em>{1t},u</em>{2t})=0$。下列说法正确的是（）<br>A. 其它因素不变，$u<em>{1t}$ 变动 1 个单位，$y</em>{1t}$ 将变动 1 个单位<br>B. 其它因素不变，$u<em>{1t}$ 变动 1 个单位，$y</em>{1t+1}$ 将变动 0.5 个单位<br>C. 其它因素不变，$u<em>{1t}$ 变动 1 个单位，$y</em>{2t}$ 将变动 0.3 个单位<br>D. 其它因素不变，$u<em>{1t}$ 变动 1 个单位，$y</em>{2t+1}$ 将变动 0.3 个单位<br>E. 其它因素不变，$u<em>{1t}$ 变动 1 个单位，$y</em>{1t+2}$ 将变动 0.34 个单位</li>
</ol>
<p>改写： $$<br>\begin{cases}<br>Y<em>{1 t} = 0.5 y</em>{1 t-1} + 0.3 y<em>{2 t-1} + u</em>{1 t}, \<br>Y<em>{2 t} = 0.3 y</em>{1 t-1} + 0.5 y<em>{2 t-1} + u</em>{2 t},<br>\end{cases}</p>
<script type="math/tex; mode=display">通过计算脉冲响应函数，分析 $u_{1 t} = 1$ 在时间 $t = 0$ 的冲击：
- **在 $t=0$（冲击当期）**：
  - $y_{10} = 0.5 \cdot y_{1,-1} + 0.3 \cdot y_{2,-1} + u_{10} = 0.5 \cdot 0 + 0.3 \cdot 0 + 1 = 1$
  - $y_{20} = 0.3 \cdot y_{1,-1} + 0.5 \cdot y_{2,-1} + u_{20} = 0.3 \cdot 0 + 0.5 \cdot 0 + 0 = 0$
  - 因此，$y_{1 t}$ 变动 1 个单位，$y_{2 t}$ 变动 0 个单位。
- **在 $t=1$（下一期）**：
  - $y_{11} = 0.5 \cdot y_{10} + 0.3 \cdot y_{20} + u_{11} = 0.5 \cdot 1 + 0.3 \cdot 0 + 0 = 0.5$
  - $y_{21} = 0.3 \cdot y_{10} + 0.5 \cdot y_{20} + u_{21} = 0.3 \cdot 1 + 0.5 \cdot 0 + 0 = 0.3$
  - 因此，$y_{1 t+1}$ 变动 0.5 个单位，$y_{2 t+1}$ 变动 0.3 个单位。
- **在 $t=2$（下两期）**：
  - $y_{12} = 0.5 \cdot y_{11} + 0.3 \cdot y_{21} + u_{12} = 0.5 \cdot 0.5 + 0.3 \cdot 0.3 + 0 = 0.25 + 0.09 = 0.34$
  - $y_{22} = 0.3 \cdot y_{11} + 0.5 \cdot y_{21} + u_{22} = 0.3 \cdot 0.5 + 0.5 \cdot 0.3 + 0 = 0.15 + 0.15 = 0.3$
  - 因此，$y_{1 t+2}$ 变动 0.34 个单位。
  - Ans：选项 A、B、D、E 均正确， C 错误。

2. 给定模型：$$Y_t = 0.5 y_{t-1} + 0.3\varepsilon_{t-1} + \varepsilon_t$$ 已知 $y_3 = 4$, $\varepsilon_3 = 10$, $\varepsilon_4 = 1$。需要预测 $y_5$。

答案：$y_5$ 的预测值为 3.3。（Hint：$\varepsilon_5$ 是未来的误差项。在预测时，我们通常假设未来误差项的期望为 0，因为它们是白噪声。）

3. 给定向量移动平均（VMA）表示：$$\begin{bmatrix}Y_t \\Z_t\end{bmatrix}=
\sum_{i = 0}^{\infty}
\begin{bmatrix}
\phi_{11}(i) & \phi_{12}(i) \\
\phi_{21}(i) & \phi_{22}(i)
\end{bmatrix}
\begin{bmatrix}
\varepsilon_{y, t-i} \\
\varepsilon_{z, t-i}
\end{bmatrix}
$$ 问：$\phi_{11}(1)$ 的含义。
- 这考察的是脉冲响应的含义。 $\phi_{jk}(i)$ 表示滞后 $i$ 期时，冲击 $\varepsilon_{k}$ 对变量 $j$ 的影响系数。
- 在本题中， $\phi_{11}(i)$ 是 $\varepsilon_{y, t-i}$ 对 $y_t$ 的影响系数。特别地，$\phi_{11}(1)$ 表示滞后 1 期（即 $i = 1$) 时，$\varepsilon_{y, t-1}$ 对 $y_t$ 的影响。
- 答案： **A**。

# Chapter 6：协整与误差修正模型

> [!Tip] 本章学习目标
> 1. 介绍协整的基本概念，展示它在各种经济模型中的应用。
> 2. 介绍协整意味着将非静态变量的随机趋势联系起来。
> 3. 考察协整变量的动态路径。由于协整变量的趋势是相联系的，所以，这些变量的动态路径一定与现在偏离均衡关系的离差具有联系。
> 4. 阐述 Engle-Granger 协整检验。检验过程的计量经济学方法来源于齐次差分方程组的理论。
> 5. Engle-Granger 方法需要用模拟数据说明。
> 6. 用实际汇率说明 Engle-Granger 方法。
> 7. 阐述 Johansen 完整信息极大似然协整检验。
> 8. 介绍怎样限制协整向量。讨论含 I(1)和(2)变量模型的推论。
> 9. 用模拟数据说明 Johansen 检验。
> 10. 介绍怎样用非稳定变量估计 ADL 模型，研究 ADL 协整检验
> 11. 用利率数据比较 Engle-Granger、Johansen、ADL 协整检验。

## 6.1 从单整到协整
### 6.1.1 单整
在 [第 3 章](#Chapter%203%20包含趋势的模型) 的最后，我们介绍了 **【单整】** （Integration）的概念。我们不妨在此回顾一下：

如果序列在成为稳定序列之前必须经过 $d$ 次差分，则该序列被称为 $d$ 阶单整。记为 $I (d)$。换句话说，如果序列 $x_t$ 是非稳定序列，$\Delta^d x_t$ 是稳定序列，则是 $x_t$ 序列 $I (d)$。其中</script><p>\Delta x<em>t = x_t - x</em>{t-1}, \quad \Delta^2 x_t = \Delta (\Delta x_t), \quad \Delta^d x_t = \Delta (\Delta^{d-1} x_t)</p>
<script type="math/tex; mode=display">

- **单整的判别？**
    对于时间序列 $x_t$，建立下列方程：</script><p>x<em>t = \rho x</em>{t-1} + \varepsilon<em>t \quad or \quad \Delta x_t = (\rho - 1) x</em>{t-1} + \varepsilon_t </p>
<script type="math/tex; mode=display">

如果 $\rho-1$ 不显著为 0，则序列 $x_t$ 至少为 1 阶单整 $I (1)$。

那么，**如何判断 $\rho-1$ 是否显著为 0？**—— [第 3.4 节：样本平稳性检验（单位根检验）](#3.4%20样本平稳性检验)。

- **性质？**
    - I (0) 序列（平稳序列）对过去行为只有有限记忆，即发生在过去的扰动项对未来的影响随时间而衰减。因此，长期而言 0 阶单整有回到期望值的趋势（均值回复）。
    - I (1) 序列对过去行为有无限长记忆，任何过去的冲击都将永久改变未来的整个序列。
    - 对 $y_t$ 进行单位根检验后，如认为非平稳，要进一步判断其为 I (1) 或 I (2)。在经济变量中，I (0) 与 I (1) 最常见，I (2) 很少见。

### 6.1.2 协整
在多元时间序列情况下，我们不仅要考虑单个时间序列的平稳性，还要考虑变量组合的平稳性。那么，单整变量（非平稳）的线性组合一定非平稳吗？有可能是平稳的吗？
- 若多个 d 阶时间序列变量的线性组合的单整阶数 b 小于 d，则称这些变量具有 **协整关系**，记作 CI(d, d-b)。由线性组合系数组成的向量称作协整向量（cointegrating vector）。
- <b><span style="background:#fff88f"><font color="#245bdb">注意：协整通常要求序列具有相同的单整阶数，并存在线性组合使其阶数降低。</font></span></b>

现在，我们数学化地定义协整：
- 如果时间序列 $Y_{t1}, Y_{t2}, \ldots, Y_{tk}$ 都是 $d$ 阶单整的，存在向量 $\alpha = (\alpha_1, \alpha_2, \ldots, \alpha_k)$，使得 $$ Z_t = \alpha^T Y_t = \alpha_1 Y_{t1} + \alpha_2 Y_{t2} + \cdots + \alpha_k Y_{tk} \sim I(d-b), \quad d \geq b \geq 0$$ 则称序列 $Y_{t1}, Y_{t2}, \ldots, Y_{tk}$ 是 $(d,b)$ 阶协整，记为 CI $(d,b)$。
- <b><span style="background:#fff88f">请注意：d 是原始序列单整阶数，b 是组合序列单整阶数。</span></b>
- $CI (d, b)$ 的经济意义：虽然变量具有各自的长期波动规律，但是如果它们是 $(d, b)$ 阶协整的，则它们之间 **存在着一个长期稳定的比例关系**。<font color="#245bdb"> 即使这些时间序列单独来看是非平稳的，也可以用经典的回归分析方法建立回归模型。</font>
- 例如，居民收入时间序列 $Y_t$ 为 1 阶单整序列，居民消费时间序列 $C_t$ 也为 1 阶单整序列，如果二者的线性组合 $a_1 Y_t + a_2 C_t$ 构成的新序列为 0 阶单整序列，于是认为序列 $Y_t$ 与 $C_t$ 是（1，1）阶协整。

> [!caution] 组成协整的单整阶数限制 
> 注意：**协整通常要求序列具有相同的单整阶数**
> 
> 如果有两个序列分别为 $d$ 阶单整和 $e$ 阶单整，即 $$x_t \sim I (d), \quad y_t \sim I (e), \quad e > d$$ 则两个序列的线性组合是 $e$ 阶单整序列，即 $$z_t = \alpha x_t + \beta y_t \sim I (\max (d, e))</script><blockquote>
<p>由于 $e &gt; d$，这两个序列不存在协整关系，其线性组合需要经过 $\max (d, e)$ 次差分才能转化为平稳序列（而不能直接分析）。</p>
<p>请思考：<strong>对于多个变量，协整阶数一定完全相等吗？——多重协整</strong></p>
<ul>
<li>若序列线性组合的单整阶数小于它们自身，但它们的阶数并不一定完全相等，则称它们具有多重协整（multi-cointegration）关系。</li>
<li>两个序列不可能出现 <strong>多重</strong> 协整！所以多重协整至少要三个序列。</li>
<li><strong>举例：</strong> x 和 y 是 CI(2,1)，记它们的一阶单整的线性组合为 xy；若 xy 又和 z 是 CI(1,1)，则 x、y、z 三个变量的线性组合就可以是平稳的，即 <strong>线性组合阶数小于它们各自的阶数</strong>。</li>
<li>你可能已经意识到：多重协整并不容易实现。上面的例子是 <strong>两次协整</strong> 实现的效果。</li>
</ul>
</blockquote>
<h2 id="6-2-协整的检验"><a href="#6-2-协整的检验" class="headerlink" title="6.2 协整的检验"></a>6.2 协整的检验</h2><p>进一步的疑问：<strong>有了数据怎么检验协整关系？有了协整关系又有什么用？</strong></p>
<ul>
<li>如果 k 个序列都是 d 阶单整的，可以建立回归方程，得到其残差序列，对残差序列进行平稳性检验，如果不存在单位根，则可以说明 k 个序列是协整关系。</li>
<li>在协整关系确定的基础上，再可以做格兰杰因果检验去判断“谁引起谁的变化”。</li>
</ul>
<h3 id="6-2-1-两变量-Engle-Granger-检验"><a href="#6-2-1-两变量-Engle-Granger-检验" class="headerlink" title="6.2.1 两变量 Engle-Granger 检验"></a>6.2.1 两变量 Engle-Granger 检验</h3><p>我们首先解决第一个问题，我们的目标是：<strong>检验两变量 $y_t, x_t$ 是否协整。</strong> 一种常用的方法是：Engle 和 Granger（1987）提出的两步检验法。</p>
<p>这种方法的核心是：<b> 对<span style="background:#fff88f">一阶残差</span>进行平稳性检验，如果是平稳的时间序列则证明是协整的。</b></p>
<p><strong>步骤一：协整回归计算非均衡误差</strong></p>
<ul>
<li>用 OLS 估计如下方程：<script type="math/tex; mode=display">y_t = \alpha x_t + \varepsilon_t</script></li>
<li>得到估计的误差 <script type="math/tex">\hat{y_t} = \hat{\alpha} x_t  \quad \to \quad e_t = y_t - \hat{y}_t = (\alpha- \hat{\alpha}) x_t+ \varepsilon_t</script><br><strong>步骤二： 检验 $e_t$ 的单整性（平稳性）</strong>：</li>
<li>如果 $e_t$ 是平稳序列（即 0 阶单整），则 $y_t, x_t \sim CI (1,1)$，$x_t$ 与 $y_t$ 之间存在协整关系；</li>
<li>如果 $e_t$ 是非平稳的，则 $x_t$ 与 $y_t$ 之间不存在协整关系。</li>
<li>检验方法：DF 检验或 ADF 检验</li>
<li>拓展：这里的检验对象是协整回归计算出的误差项，并非真正的非均衡误差。由于 OLS 估计最小化残差平方和的原理，估计量 $\delta$ 是向下偏倚的，拒绝零假设的机会比实际大。因此对于 $e_t$ 的平稳性检验的 DF 与 ADF 临界值比正常的 DF 与 ADF 检验的临界值小。</li>
<li>也可进行协整回归 Durbin-Watson 检验，DW 检验常用于检验回归分析中残差一阶自相关性。DW 统计量：$DW=\dfrac{\sum<em>{i=2}^n\left(\boldsymbol{e}_i-\boldsymbol{e}</em>{i-1}\right)^2}{\sum_{i=1}^n\left(\boldsymbol{e}_i-\bar{e}\right)^2}$。DW 检验的原假设是 DW 统计量 = 0。若 H0 成立，则残差为随机游走，不存在协整，反之则存在协整。DW 检验只能检验一阶自相关，<a href="#3.5.1.2%20LM%20检验">LM 检验</a> 可以检验一阶或高阶自相关，但需要构建辅助回归模型。</li>
</ul>
<h3 id="6-2-2-误差修正模型"><a href="#6-2-2-误差修正模型" class="headerlink" title="6.2.2 误差修正模型"></a>6.2.2 误差修正模型</h3><h4 id="6-2-2-1-一般差分模型的问题"><a href="#6-2-2-1-一般差分模型的问题" class="headerlink" title="6.2.2.1 一般差分模型的问题"></a>6.2.2.1 一般差分模型的问题</h4><p>对于非平稳时间序列，可以通过差分的方法将其化为稳定序列。</p>
<script type="math/tex; mode=display">Y_t = \alpha_0 + \alpha_1 X_t + \mu_t \quad \to \quad \Delta Y_t = \alpha_1 \Delta X_t + v_t \quad (v_t = \mu_t - \mu_{t-1})</script><p>但是这种做法会引起两个问题：  </p>
<ul>
<li>如果 $X$ 与 $Y$ 之间存在长期稳定的均衡关系，且误差项 $\mu_t$ 不存在序列相关性，则差分式中的 $v_t$ 是一阶移动平均时间序列，存在序列相关的问题。  </li>
<li><strong>如果采用差分形式进行估计，则关于变量水平值的重要信息将被忽略，这时的模型只表达了 $X$ 和 $Y$ 之间的短期关系，而没有揭示它们间的长期关系</strong>。</li>
</ul>
<p>例如，当我们使用 $\Delta Y_t = \alpha_1 \Delta X_t + v_t$ 进行回归分析时，容易出现截距项显著不为 0 的情况，即我们得到的估计方程是</p>
<script type="math/tex; mode=display">\Delta Y_t = \hat{\alpha}_0 + \hat{\alpha}_1 \Delta X_t + \hat{v}_t,\quad \hat{\alpha}_0 \neq 0</script><p>此时即使保持 $X$ 不变，$Y$ 也会出于长期的上升或下降的过程中，这意味着 $X$ 与 $Y$ 之间不存在静态均衡，与大多数具有长期均衡的经济理论假说不相符。</p>
<h4 id="6-2-2-2-误差修正模型-ECM"><a href="#6-2-2-2-误差修正模型-ECM" class="headerlink" title="6.2.2.2 误差修正模型 ECM"></a>6.2.2.2 误差修正模型 ECM</h4><p>如何克服一般差分的局限？——误差修正模型（Error Correction Model，ECM）</p>
<ul>
<li>什么是误差修正模型呢？长期均衡的两个序列，短期的误差都会被修正。</li>
<li><strong>注意：只有存在协整关系才可以做误差修正模型。</strong></li>
</ul>
<blockquote>
<p>[!note] 需要修正的是什么误差？</p>
<ul>
<li>假设 $X$ 与 $Y$ 之间的非均衡关系体现为如下（1,1）阶分布滞后模型的形式：  <script type="math/tex; mode=display">Y_t = \beta_0 + \beta_1 X_t + \beta_2 X_{t-1} + \delta Y_{t-1} + u_t,</script>该模型显示出 $t$ 期的 $Y$ 不仅与 $X$ 的变化有关，而且与 $t-1$ 期的 $X$ 与 $Y$ 的状态值有关。但由于变量可能具有非平稳性，因此不能直接进行 OLS 估计。</li>
<li>差分变形得  <script type="math/tex; mode=display">\begin{split}\Delta Y_t =& \beta_0 + \beta_1 \Delta X_t + (\beta_1 + \beta_2) X_{t-1} - (1-\delta) Y_{t-1} + u_t \\=& \beta_1 \Delta X_t - (1-\delta)\left(Y_{t-1} - \frac{\beta_0}{1-\delta} - \frac{\beta_1 + \beta_2}{1-\delta} X_{t-1}\right) + u_t \\\triangleq& \beta_1 \Delta X_t - \lambda (Y_{t-1} - \alpha_0 - \alpha_1 X_{t-1}) + u_t\end{split}</script></li>
<li>将上式中的误差项与一般差分模型差分方法的误差项对比：<script type="math/tex">Y_t = \alpha_0 + \alpha_1 X_t + \mu_t \quad \to \quad \Delta Y_t = \beta_1 \Delta X_t + v_t</script></li>
<li>不难发现，二者的差别是多出了一项： $- \lambda (Y<em>{t-1} - \alpha_0 - \alpha_1 X</em>{t-1})$ 。</li>
<li>其中， $Y<em>{t-1} - \alpha_0 - \alpha_1 X</em>{t-1}=\mu_{t-1}$ ，<strong>正是 $t-1$ 期的非均衡误差项。</strong></li>
<li>这表明 $Y$ 的短期变化 $\Delta Y_t$ 不仅受 $X$ 的短期变化 $\Delta X_t$ 影响，而且根据前一时期的非均衡程度进行相应的修正调整。</li>
</ul>
</blockquote>
<p>由此，我们得到了误差修正项 $ecm$：</p>
<script type="math/tex; mode=display">ecm_{t-1} = Y_{t-1} - (\alpha_0 + \alpha_1 X_{t-1})</script><p>对于上述 (1, 1) 阶自回归分布滞后模型，在一般差分的基础上，我们纳入误差修正项，就得到 <font color="#245bdb"> 一阶误差修正模型 </font>：</p>
<script type="math/tex; mode=display">\Delta Y_t = \beta_1 \Delta X_t - \lambda \cdot ecm_{t-1} + u_t</script><ul>
<li>由于 $\delta$ 反映了 $Y<em>t$ 与 $Y</em>{t-1}$ 的关系，一般情况下 $|\delta| &lt; 1$，因此 $0 &lt; \lambda=1-\delta &lt; 1$。</li>
<li>据此分析 ECM 模型的修正作用：<ul>
<li>若上期的实际值大于长期均衡值，即 $Y<em>{t-1} &gt; \alpha_0 + \alpha_1 X</em>{t-1}$，则 $ecm$ 为正，当期的短期变动 $\Delta Y_t$ 减少；</li>
<li>若上期的实际值小于长期均衡值，即 $Y<em>{t-1} &lt; \alpha_0 + \alpha_1 X</em>{t-1}$，则 $ecm$ 为负，当期的短期变动 $\Delta Y_t$ 增大。</li>
</ul>
</li>
<li>是否变量间的关系都可以通过 ECM 来表述？——Granger 表述定理：如果变量 X 与 Y 是协整的，则它们间的短期非均衡关系总能由一个误差修正模型表述。</li>
</ul>
<h4 id="6-2-2-3-建立误差修正模型的步骤"><a href="#6-2-2-3-建立误差修正模型的步骤" class="headerlink" title="6.2.2.3 建立误差修正模型的步骤"></a>6.2.2.3 建立误差修正模型的步骤</h4><ol>
<li>总体思路<ul>
<li>首先，对经济系统进行观察和分析，提出长期均衡关系假设。</li>
<li>然后，对变量进行协整分析，检验长期均衡关系假设，并构成误差修正项。</li>
<li>最后，建立短期模型，将误差修正项看作一个解释变量，连同其他反映短期波动的解释变量一起，建立短期模型，即误差修正模型。</li>
</ul>
</li>
<li><strong>EG 两步法</strong><ul>
<li>第一步：利用 OLS 进行协整回归，检验变量间的协整关系，估计协整向量（长期均衡关系参数）</li>
<li>第二步：若协整性存在，则以 <font color="#245bdb"><span style="background:#fff88f">第一步求得的残差在滞后一期之后</span></font> 作为非均衡误差项 ecm 加入到误差修正模型中，并用 OLS 估计相应参数</li>
<li>注意：第二步在确定 <strong>ECM 模型滞后项阶数</strong> 时，需要先对模型进行回归，之后检验 ECM 模型的残差是否具有自相关性，或者采用 Q 统计量检验残差是否为白噪声。如果接受了不具有自相关性的零假设，则说明 ECM 模型的滞后阶数选择正确，否则需重新调整参数。</li>
</ul>
</li>
</ol>
<blockquote>
<p>[!tip] 通过 Stata 代码理解 EG 两步法<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">*Step 1：E-G两步法*</span><br>（1）生成残差<br><span class="hljs-keyword">reg</span> y x  <span class="hljs-comment">//OLS回归</span><br><span class="hljs-keyword">predict</span> <span class="hljs-keyword">e</span>, residual <span class="hljs-comment">//生成残差</span><br>（2）对残差做单位根检验<br><span class="hljs-keyword">tsset</span> year <span class="hljs-comment">//先将e设置成时间序列</span><br><span class="hljs-keyword">dfuller</span> <span class="hljs-keyword">e</span>，nocons <span class="hljs-keyword">reg</span>  <span class="hljs-comment">//进行单位根检验</span><br><br><span class="hljs-comment">*Step 2：如果1.2有协整关系，建立误差修正模型(ECM)*</span><br>（1）生成残差的滞后项<br><span class="hljs-keyword">gen</span> ecm=<span class="hljs-keyword">l</span>.<span class="hljs-keyword">e</span> <br>（2）生成被解释变量的滞后项（注：dy、dx是Δy和Δx）<br><span class="hljs-keyword">gen</span> dy_lar=<span class="hljs-keyword">l</span>.dy<br>（3）用OLS法估计误差修正模型的参数（加入了被解释变量和残差的滞后项）<br><span class="hljs-keyword">reg</span> dy dx dy_lar ecm<br></code></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="6-2-3-多变量协整关系的检验"><a href="#6-2-3-多变量协整关系的检验" class="headerlink" title="6.2.3 多变量协整关系的检验"></a>6.2.3 多变量协整关系的检验</h3><p>Engle-Granger 检验通常用于检验两变量之间的协整关系，对于多变量之间的协整关系，通常使用 Johansen 协整检验来确定变量之间是否有协整关系，并由此估计模型。 </p>
<ul>
<li>Johansen 协整检验分为两种，一个叫迹检验（trace test），有一个叫极大特征根检验（maximum eigenvalue test），这两个检验通常会给出一样的结论。</li>
<li>关于 Johansen 检验的原理，详见 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144783461">链接</a></li>
</ul>
<blockquote>
<p>[!tip] 【了解】为什么多变量协整关系的检验比双变量复杂？<br>协整变量间可能存在多种稳定的线性组合。<br>例如：假设有 4 个 I(1)的变量 Z, X, Y, W，它们有如下的长期均衡关系：<br>$Z_t = \alpha_0 + \alpha_1W_t + \alpha_2X_t + \alpha_3Y_t + \mu_t,$<br>得到非均衡误差 $\mu_t$ 是 I(0)序列<br>$\mu_t = Z_t - \alpha_0 - \alpha_1W_t - \alpha_2X_t - \alpha_3Y_t \sim I(0).$<br>但存在另一种情况，假设 Z 与 W，X 与 Y 之间分别存在长期均衡关系<br>$Z_t = \beta_0 + \beta_1W_t + u_t,$<br>$X_t = \gamma_0 + \gamma_1Y_t + v_t,$<br>则非均衡误差项 $u_t$ 和 $v_t$ 一定平稳。它们的线性组合也一定是平稳序列，如：<br>$w_t = u_t + v_t = Z_t - \beta_0 - \gamma_0 - \beta_1W_t + X_t - \gamma_1Y_t \sim I(0).$<br>因此存在多组协整向量。</p>
</blockquote>
<p><strong>多变量的协整检验步骤</strong>：</p>
<ul>
<li>与双变量基本相同，需要检验变量是否具有同阶单整性，以及是否存在稳定的线性组合。</li>
<li>在检验是否存在稳定的线性组合时，需要通过设置一个变量为被解释变量，其他变量为解释变量，进行 OLS 估计并检验残差序列是否为平稳序列。如果不平稳则需更换被解释变量，进行同样的 OLS 估计和相应的残差序列的平稳性检验。</li>
<li>当所有的变量都被作为被解释变量检验之后，仍不能得到平稳的残差项序列，则认为这些变量间不存在 ( 1 , 1 )  阶协整。</li>
</ul>
<h3 id="6-2-4-小结"><a href="#6-2-4-小结" class="headerlink" title="6.2.4 小结"></a>6.2.4 小结</h3><ol>
<li>检验协整的一种方法是分析偏离长期均衡关系的残差。如果残差存在单位根，则变量间不是 (1,1) 阶协整的。（E-G 方法）</li>
<li>在 I(1) 变量中检验协整的另一种方法是估计 1 阶差分 VAR 模型，该模型包含变量的滞后值。Johansen 方法运用 $\lambda<em>{trace}$ 和 $\lambda</em>{max}$ 检验统计量来确定变量间是否是协整的和协整向量的数量。这些检验对包含在协整向量的确定性回归变量很敏感。协整向量和 (或) 速度调整系数的约束条件可以用 X 统计量进行检验。我们应该知道在协整框架下确定性回归变量所起的作用。为了确定是否存在确定性趋势、协整向量之外的漂移项或协整向量中出现的常数，Johansen (1994) 提出了如何进行检验的方法。</li>
<li>第三个检验协整的方法是估计误差修正模型。如果只有一个变量对偏离长期均衡的离差做出反应进行调整的话，则倾向于估计自回归分布滞后模型 ADL。用 OLS 估计模型，并进行协整向量系数的假设检验很直截了当。</li>
<li>对于更复杂的情况，附录 6.2 讨论了 Phillips-Hansen (1990) 单方程结构建模的方法。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/Notes/" class="print-no-link">#Notes</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>时间序列分析自学笔记</div>
      <div>https://zhangwj235.github.io/2025/09/13/Time Series Note/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jack Zhang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>September 13, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../Better%20Lucky%20Than%20Rich/" title="Better Lucky Than Rich? Welfare Analysis of Automobile Licence Allocations in Beijing and Shanghai">
                        <span class="hidden-mobile">Better Lucky Than Rich? Welfare Analysis of Automobile Licence Allocations in Beijing and Shanghai</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://zhangwj235.github.io" target="_blank" rel="nofollow noopener"><span>Homepage</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/zhangwj235" target="_blank" rel="nofollow noopener"><span>Github</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        Views: 
        <span id="leancloud-site-pv"></span>
        
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        Visitors: 
        <span id="leancloud-site-uv"></span>
        
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="../../../../js/leancloud.js" ></script>

  <script  src="../../../../js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
